<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>System Dziaek Minecraft</title>
    <link rel="icon" type="image/x-icon" href="Red.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        #map-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        #map-svg {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111827;
        }
        .plot-rect {
            stroke-width: 0.5;
            transition: fill 0.2s ease-in-out, fill-opacity 0.3s ease-in-out, filter 0.3s ease-in-out;
        }
        .plot-rect:hover {
            fill-opacity: 0.6;
        }
        .plot-rect.dimmed {
            fill-opacity: 0.4 !important;
        }
        .plot-rect.highlighted {
            fill-opacity: 1 !important;
            filter: brightness(1.2);
        }
        .street-rect {
            fill: #6b7280;
            fill-opacity: 0.6;
            stroke: #9ca3af;
            stroke-width: 0.5;
        }
        .street-rect:hover {
            fill-opacity: 0.8;
        }
        .merged-plot {
            stroke: #f59e0b;
            stroke-width: 2;
            stroke-dasharray: 5,3;
        }
        .plot-text {
            font-size: 4px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        .street-text {
            font-size: 3px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        #tooltip {
            background-color: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid #4b5563;
            transition: opacity 0.2s ease-in-out;
        }
        #modal {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }
        #modal.show {
            transform: translateX(0);
        }
        .grab { cursor: grab; }
        .grabbing { cursor: grabbing; }
        
        @media (max-width: 768px) {
            #tooltip {
                font-size: 12px;
                max-width: 90vw;
                max-height: 50vh;
                overflow-y: auto;
            }
            .plot-text {
                font-size: 3px;
            }
            .controls {
                bottom: 10px;
                right: 10px;
            }
            .control-button {
                width: 44px;
                height: 44px;
            }
            #modal {
                width: 100vw;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Search Bar -->
    <div class="absolute top-5 left-5 z-30">
        <div class="flex bg-gray-800 rounded-lg border border-gray-600 shadow-lg">
            <input 
                type="text" 
                id="search-input" 
                placeholder="Wyszukaj dziak (D4/021 lub 021)"
                class="bg-transparent text-white px-4 py-2 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                maxlength="10"
            >
            <button 
                id="search-button" 
                class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-r-lg transition-colors"
            >
                
            </button>
        </div>
    </div>

    <!-- Main container for the map -->
    <div id="map-container" class="grab">
        <svg id="map-svg"></svg>
    </div>

    <!-- Simple Tooltip -->
    <div id="tooltip" class="hidden absolute p-2 rounded-lg shadow-xl text-sm z-10 pointer-events-none"></div>

    <!-- Right Side Modal -->
    <div id="modal" class="fixed top-0 right-0 w-96 h-full bg-gray-800 border-l border-gray-600 shadow-2xl z-20 overflow-y-auto">
        <div class="p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Szczeg贸y dziaki</h2>
                <button id="close-modal" class="text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>
            <div id="modal-content"></div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loader" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-20">
        <div class="text-center">
            <svg class="animate-spin h-8 w-8 text-white mx-auto mb-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-lg font-medium">Pobieranie danych o dziakach...</p>
            <p class="text-sm text-gray-400">Prosz czeka</p>
        </div>
    </div>

    <!-- Controls -->
    <div class="absolute controls flex flex-col space-y-2" style="bottom: 20px; right: 20px;">
        <button id="zoom-in" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        </button>
        <button id="zoom-out" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600">
           <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        </button>
        <button id="reset-view" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"></path><path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path><path d="M21 22v-6h-6"></path><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path></svg>
        </button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const SHEET_ID = '1swtElpz27sqLMNbATocFe9VHc1yZTSRxvHyikFL_R7U';
            const PLOTS_GID = '0';
            const MERGED_GID = '43897086';
            const STREETS_GID = '2101138806';

            const PLOTS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${PLOTS_GID}`;
            const MERGED_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${MERGED_GID}`;
            const STREETS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${STREETS_GID}`;

            const MAP_IMAGE_URL = 'map.png';
            const MAP_WIDTH = 4296;
            const MAP_HEIGHT = 2360;

            const svg = document.getElementById('map-svg');
            const tooltip = document.getElementById('tooltip');
            const modal = document.getElementById('modal');
            const modalContent = document.getElementById('modal-content');
            const loader = document.getElementById('loader');
            const mapContainer = document.getElementById('map-container');
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const closeModal = document.getElementById('close-modal');

            let viewBox = { x: 0, y: 0, w: 0, h: 0 };
            let mapBounds = { minX: -MAP_WIDTH / 2, maxX: MAP_WIDTH / 2, minY: -MAP_HEIGHT / 2, maxY: MAP_HEIGHT / 2 };
            let isPanning = false;
            let startPoint = { x: 0, y: 0 };
            let touchDistance = 0;
            let lastTouchTime = 0;
            const initialViewBox = {};
            
            let allPlots = [];
            let mergedPlots = [];
            let streets = [];

            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

            function setViewBox(x, y, w, h) {
                const minZoom = isMobile ? 50 : 100;
                const maxZoom = Math.max(MAP_WIDTH, MAP_HEIGHT) * 2;
                
                w = Math.max(minZoom, Math.min(w, maxZoom));
                h = Math.max(minZoom, Math.min(h, maxZoom));
                
                if (x < mapBounds.minX) x = mapBounds.minX;
                if (y < mapBounds.minY) y = mapBounds.minY;
                if (x + w > mapBounds.maxX) x = mapBounds.maxX - w;
                if (y + h > mapBounds.maxY) y = mapBounds.maxY - h;
                
                viewBox.x = x;
                viewBox.y = y;
                viewBox.w = w;
                viewBox.h = h;
                
                svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
            }

            function getColorForType(type) {
                const alpha = 0.8;
                switch (type) {
                    case 'Parkowa':               return `rgba(34, 197, 94, ${alpha})`;
                    case 'Rolna':                 return `rgba(126, 42, 12, ${alpha})`;
                    case 'Hotelowa':              return `rgba(6, 182, 212, ${alpha})`;
                    case 'Mieszkalna':            return `rgba(202, 138, 4, ${alpha})`;
                    case 'Sakralna':              return `rgba(168, 85, 247, ${alpha})`;
                    case 'Przemysowo-biurowa':   return `rgba(236, 72, 153, ${alpha})`;
                    case 'Mieszkalno-usugowa':   return `rgba(59, 130, 246, ${alpha})`;
                    case 'Publiczna':             return `rgba(249, 115, 22, ${alpha})`;
                    case 'Medyczna':              return `rgba(251, 44, 54, ${alpha})`;
                    default:                      return `rgba(255, 255, 255, 0.1)`;
                }
            }

            async function fetchAllData() {
                try {
                    const [plotsResponse, mergedResponse, streetsResponse] = await Promise.all([
                        fetch(PLOTS_URL),
                        fetch(MERGED_URL),
                        fetch(STREETS_URL)
                    ]);

                    if (!plotsResponse.ok || !mergedResponse.ok || !streetsResponse.ok) {
                        throw new Error('Network response was not ok');
                    }

                    const [plotsText, mergedText, streetsText] = await Promise.all([
                        plotsResponse.text(),
                        mergedResponse.text(),
                        streetsResponse.text()
                    ]);

                    // Parse plots data
                    Papa.parse(plotsText, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            allPlots = results.data.filter(p => 
                                p['Nr porzdkowy'] && p['X (lewy g贸rny)'] && p['Z (lewy g贸rny)'] && p['Bok X'] && p['Bok Z']
                            ).map(d => ({
                                id: d['Nr porzdkowy'],
                                name: d['Nazwa porzdkowa dziaki'],
                                type: d['Typ'],
                                x1: parseInt(d['X (lewy g贸rny)'], 10),
                                z1: parseInt(d['Z (lewy g贸rny)'], 10),
                                x2: parseInt(d['X (prawy dolny)'], 10),
                                z2: parseInt(d['Z (prawy dolny)'], 10),
                                width: parseInt(d['Bok X'], 10),
                                height: parseInt(d['Bok Z'], 10),
                                area: d['Powierzchnia'],
                                value: d['Warto'],
                                prevOwner: d['Poprzedni waciciel'],
                                owner: d['Aktualny waciciel'],
                                sector: d['Sektor'],
                                district: d['Dzielnica'],
                                street: d['Ulica'],
                                buildingNumber: d['Numer budynku'],
                                apartmentCount: d['Ilo lokali']
                            }));
                        }
                    });

                    // Parse merged plots data
                    console.log(mergedText);
                    Papa.parse(mergedText, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            const connections = results.data.filter(m => 
                                m['Identyfikator pierwszej dziaki'] && m['Identyfikator drugiej dziaki']
                            ).map(d => ({
                                plot1: d['Identyfikator pierwszej dziaki'],
                                plot2: d['Identyfikator drugiej dziaki']
                            }));
                            
                            mergedPlots = processMergedPlots(connections);
                        }
                    });

                    // Parse streets data
                    console.log(streetsText);
                    Papa.parse(streetsText, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            streets = results.data.filter(s => 
                                s['Numer porzdkowy'] && s['X (lewy g贸rny)'] && s['Z (lewy g贸rny)'] && s['X (prawy dolny)'] && s['Z (prawy dolny)']
                            ).map(d => ({
                                id: d['Numer porzdkowy'],
                                name: d['Nazwa ulicy'],
                                x1: parseInt(d['X (lewy g贸rny)'], 10),
                                z1: parseInt(d['Z (lewy g贸rny)'], 10),
                                x2: parseInt(d['X (prawy dolny)'], 10),
                                z2: parseInt(d['Z (prawy dolny)'], 10),
                                width: parseInt(d['X (prawy dolny)'], 10) - parseInt(d['X (lewy g贸rny)'], 10),
                                height: parseInt(d['Z (prawy dolny)'], 10) - parseInt(d['Z (lewy g贸rny)'], 10)
                            }));
                            
                            console.log('Parsed streets:', streets);
                            drawMap();
                            loader.style.display = 'none';
                        }
                    });

                } catch (error) {
                    console.error("Bd podczas pobierania danych:", error);
                    loader.innerHTML = `<div class="text-center"><p class="text-lg font-medium text-red-500">Bd adowania danych</p><p class="text-sm text-gray-400">Sprawd藕 konsol, aby uzyska wicej informacji.</p></div>`;
                }
            }

            function processMergedPlots(connections) {
                const groups = [];
                const processed = new Set();

                connections.forEach(conn => {
                    if (processed.has(conn.plot1) || processed.has(conn.plot2)) {
                        // Add to existing group
                        const group = groups.find(g => g.includes(conn.plot1) || g.includes(conn.plot2));
                        if (group) {
                            if (!group.includes(conn.plot1)) group.push(conn.plot1);
                            if (!group.includes(conn.plot2)) group.push(conn.plot2);
                        }
                    } else {
                        // Create new group
                        groups.push([conn.plot1, conn.plot2]);
                    }
                    processed.add(conn.plot1);
                    processed.add(conn.plot2);
                });

                // Calculate merged plot properties
                return groups.map(group => {
                    const plots = group.map(id => allPlots.find(p => p.id === id)).filter(Boolean);
                    if (plots.length === 0) return null;

                    const minX = Math.min(...plots.map(p => p.x1));
                    const maxX = Math.max(...plots.map(p => p.x2));
                    const minZ = Math.min(...plots.map(p => p.z1));
                    const maxZ = Math.max(...plots.map(p => p.z2));
                    
                    const originalArea = plots.reduce((sum, p) => sum + parseInt(p.area || 0), 0);
                    const mergedArea = (maxX - minX) * (maxZ - minZ);

                    return {
                        plots: group,
                        x1: minX,
                        z1: minZ,
                        x2: maxX,
                        z2: maxZ,
                        width: maxX - minX,
                        height: maxZ - minZ,
                        originalArea,
                        mergedArea
                    };
                }).filter(Boolean);
            }

            function drawMap() {
                if (!allPlots.length) return;
                svg.innerHTML = ''; 

                // Add map background image
                const mapImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                mapImage.setAttribute('href', MAP_IMAGE_URL);
                mapImage.setAttribute('x', -MAP_WIDTH / 2);
                mapImage.setAttribute('y', -MAP_HEIGHT / 2);
                mapImage.setAttribute('width', MAP_WIDTH);
                mapImage.setAttribute('height', MAP_HEIGHT);
                svg.appendChild(mapImage);

                console.log('Drawing streets:', streets.length);
                console.log('Drawing merged plots:', mergedPlots.length);

                // Draw streets first (under everything)
                drawStreets();

                // Draw district boundaries
                drawDistrictBoundaries();

                // Draw merged plots
                drawMergedPlots();

                // Draw regular plots (on top)
                drawPlots();

                const padding = 50;
                const minX = Math.min(...allPlots.map(p => p.x1));
                const maxX = Math.max(...allPlots.map(p => p.x2));
                const minZ = Math.min(...allPlots.map(p => p.z1));
                const maxZ = Math.max(...allPlots.map(p => p.z2));

                viewBox.x = minX - padding;
                viewBox.y = minZ - padding;
                viewBox.w = (maxX - minX) + (padding * 2);
                viewBox.h = (maxZ - minZ) + (padding * 2);

                Object.assign(initialViewBox, viewBox);
                setViewBox(viewBox.x, viewBox.y, viewBox.w, viewBox.h);
            }

            function drawStreets() {
                console.log('Drawing streets - count:', streets.length);
                streets.forEach(street => {
                    console.log('Drawing street:', street.name, street.x1, street.z1, street.width, street.height);
                    
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', street.x1);
                    rect.setAttribute('y', street.z1);
                    rect.setAttribute('width', street.width);
                    rect.setAttribute('height', street.height);
                    rect.setAttribute('class', 'street-rect');

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', street.x1 + street.width / 2);
                    text.setAttribute('y', street.z1 + street.height / 2);
                    text.setAttribute('class', 'street-text');
                    text.textContent = street.name;

                    g.appendChild(rect);
                    g.appendChild(text);

                    // Street hover tooltip
                    g.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold">${street.name}</div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    g.addEventListener('mouseleave', hideTooltip);
                    g.addEventListener('mousemove', moveTooltip);

                    svg.appendChild(g);
                });
            }

            function drawMergedPlots() {
                console.log('Drawing merged plots - count:', mergedPlots.length);
                mergedPlots.forEach((merged, index) => {
                    console.log('Drawing merged plot', index, ':', merged.plots.join(','), merged.x1, merged.z1, merged.width, merged.height);
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', merged.x1);
                    rect.setAttribute('y', merged.z1);
                    rect.setAttribute('width', merged.width);
                    rect.setAttribute('height', merged.height);
                    rect.setAttribute('class', 'merged-plot');
                    rect.style.fill = 'none';

                    // Add merged plot info on hover
                    rect.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `
                            <div class="font-semibold mb-1">Poczone dziaki</div>
                            <div class="text-xs">
                                <div>Dziaki: ${merged.plots.join(', ')}</div>
                                <div>Powierzchnia oryginalna: ${merged.originalArea} m虏</div>
                                <div>Powierzchnia po poczeniu: ${merged.mergedArea} m虏</div>
                            </div>
                        `;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    rect.addEventListener('mouseleave', hideTooltip);
                    rect.addEventListener('mousemove', moveTooltip);

                    svg.appendChild(rect);
                });
            }

            function drawPlots() {
                const fragment = document.createDocumentFragment();
                
                allPlots.forEach(plot => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', plot.x1);
                    rect.setAttribute('y', plot.z1);
                    rect.setAttribute('width', plot.width);
                    rect.setAttribute('height', plot.height);
                    rect.setAttribute('class', 'plot-rect');
                    
                    rect.style.fill = getColorForType(plot.type);
                    
                    const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                    rect.style.stroke = isOwned ? '#ef4444' : '#22c55e';

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', plot.x1 + plot.width / 2);
                    text.setAttribute('y', plot.z1 + plot.height / 2);
                    text.setAttribute('class', 'plot-text');
                    text.textContent = plot.id;
                    
                    g.appendChild(rect);
                    g.appendChild(text);
                    g.dataset.plotData = JSON.stringify(plot);

                    // Plot hover and click events
                    g.addEventListener('mouseenter', (e) => {
                        showSimpleTooltip(e, plot);
                        if (plot.district) highlightDistrict(plot.district);
                    });
                    g.addEventListener('mouseleave', () => {
                        hideTooltip();
                        clearHighlight();
                    });
                    g.addEventListener('mousemove', moveTooltip);
                    g.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showModal(plot);
                    });

                    // Mobile events
                    if (isMobile) {
                        g.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            showModal(plot);
                        });
                    }

                    fragment.appendChild(g);
                });
                
                svg.appendChild(fragment);
            }

            function drawDistrictBoundaries() {
                const districts = {};
                allPlots.forEach(plot => {
                    if (plot.district && plot.district.trim() !== '') {
                        const districtName = plot.district.trim();
                        if (!districts[districtName]) {
                            districts[districtName] = [];
                        }
                        districts[districtName].push(plot);
                    }
                });

                Object.entries(districts).forEach(([districtName, districtPlots]) => {
                    if (districtPlots.length === 0) return;

                    const clusters = createDistrictClusters(districtPlots, 30);

                    clusters.forEach((cluster, clusterIndex) => {
                        // Create complex boundary following plot edges
                        const boundary = createComplexBoundary(cluster);
                        
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', boundary);
                        path.style.fill = 'none';
                        path.style.stroke = '#8b5cf6';
                        path.style.strokeWidth = '2';
                        path.style.strokeDasharray = '8,4';
                        path.style.opacity = '0.7';
                        path.style.cursor = 'pointer';
                        path.dataset.districtName = districtName;
                        
                        path.addEventListener('mouseenter', () => highlightDistrict(districtName));
                        path.addEventListener('mouseleave', () => clearHighlight());

                        svg.appendChild(path);

                        // Add district label
                        const minX = Math.min(...cluster.map(p => p.x1));
                        const maxX = Math.max(...cluster.map(p => p.x2));
                        const minZ = Math.min(...cluster.map(p => p.z1));
                        
                        const districtLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        districtLabel.setAttribute('x', minX + (maxX - minX) / 2);
                        districtLabel.setAttribute('y', minZ - 8);
                        districtLabel.style.fill = '#8b5cf6';
                        districtLabel.style.fontSize = '7px';
                        districtLabel.style.fontWeight = 'bold';
                        districtLabel.style.textAnchor = 'middle';
                        districtLabel.style.pointerEvents = 'none';
                        districtLabel.textContent = clusters.length > 1 ? `${districtName} (${clusterIndex + 1})` : districtName;
                        svg.appendChild(districtLabel);
                    });
                });
            }

            function createComplexBoundary(plots) {
                // Sort plots by position to create a more natural boundary
                plots.sort((a, b) => {
                    if (Math.abs(a.z1 - b.z1) < 5) return a.x1 - b.x1; // Same row, sort by x
                    return a.z1 - b.z1; // Different rows, sort by z
                });

                if (plots.length === 0) return '';
                if (plots.length === 1) {
                    // Single plot - simple rectangle
                    const p = plots[0];
                    const padding = 3;
                    return `M ${p.x1 - padding} ${p.z1 - padding} L ${p.x2 + padding} ${p.z1 - padding} L ${p.x2 + padding} ${p.z2 + padding} L ${p.x1 - padding} ${p.z2 + padding} Z`;
                }

                // For multiple plots, create a convex hull-like boundary
                const allPoints = [];
                plots.forEach(plot => {
                    allPoints.push(
                        { x: plot.x1, y: plot.z1 }, // top-left
                        { x: plot.x2, y: plot.z1 }, // top-right
                        { x: plot.x2, y: plot.z2 }, // bottom-right
                        { x: plot.x1, y: plot.z2 }  // bottom-left
                    );
                });

                // Find the convex hull points
                const hull = convexHull(allPoints);
                const padding = 3;
                
                if (hull.length < 3) {
                    // Fallback to simple rectangle
                    const minX = Math.min(...plots.map(p => p.x1)) - padding;
                    const maxX = Math.max(...plots.map(p => p.x2)) + padding;
                    const minZ = Math.min(...plots.map(p => p.z1)) - padding;
                    const maxZ = Math.max(...plots.map(p => p.z2)) + padding;
                    return `M ${minX} ${minZ} L ${maxX} ${minZ} L ${maxX} ${maxZ} L ${minX} ${maxZ} Z`;
                }

                // Create path from hull points with padding
                let pathData = `M ${hull[0].x + (hull[0].x < 0 ? -padding : padding)} ${hull[0].y + (hull[0].y < 0 ? -padding : padding)}`;
                for (let i = 1; i < hull.length; i++) {
                    const point = hull[i];
                    pathData += ` L ${point.x + (point.x < 0 ? -padding : padding)} ${point.y + (point.y < 0 ? -padding : padding)}`;
                }
                pathData += ' Z';
                
                return pathData;
            }

            function convexHull(points) {
                // Simple convex hull algorithm (Graham scan)
                if (points.length < 3) return points;
                
                // Find the bottom-most point (and left-most in case of tie)
                let start = 0;
                for (let i = 1; i < points.length; i++) {
                    if (points[i].y < points[start].y || 
                        (points[i].y === points[start].y && points[i].x < points[start].x)) {
                        start = i;
                    }
                }
                
                // Swap start point to beginning
                [points[0], points[start]] = [points[start], points[0]];
                const startPoint = points[0];
                
                // Sort points by polar angle with respect to start point
                points.slice(1).sort((a, b) => {
                    const angleA = Math.atan2(a.y - startPoint.y, a.x - startPoint.x);
                    const angleB = Math.atan2(b.y - startPoint.y, b.x - startPoint.x);
                    if (Math.abs(angleA - angleB) < 0.001) {
                        // Same angle, sort by distance
                        const distA = Math.pow(a.x - startPoint.x, 2) + Math.pow(a.y - startPoint.y, 2);
                        const distB = Math.pow(b.x - startPoint.x, 2) + Math.pow(b.y - startPoint.y, 2);
                        return distA - distB;
                    }
                    return angleA - angleB;
                });
                
                // Graham scan
                const hull = [points[0], points[1]];
                for (let i = 2; i < points.length; i++) {
                    while (hull.length > 1) {
                        const o = orientation(hull[hull.length - 2], hull[hull.length - 1], points[i]);
                        if (o !== 2) break; // Not a right turn
                        hull.pop();
                    }
                    hull.push(points[i]);
                }
                
                return hull;
            }

            function orientation(p, q, r) {
                const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
                if (Math.abs(val) < 0.001) return 0; // Collinear
                return val > 0 ? 1 : 2; // Clockwise or Counterclockwise
            }

            function createDistrictClusters(plots, maxDistance) {
                if (plots.length === 0) return [];
                
                const clusters = [];
                const processed = new Set();

                plots.forEach((plot, index) => {
                    if (processed.has(index)) return;

                    const cluster = [plot];
                    processed.add(index);

                    const findNearbyPlots = (centerPlot) => {
                        plots.forEach((otherPlot, otherIndex) => {
                            if (processed.has(otherIndex)) return;

                            // Calculate distance between plot centers
                            const centerX1 = centerPlot.x1 + centerPlot.width / 2;
                            const centerZ1 = centerPlot.z1 + centerPlot.height / 2;
                            const centerX2 = otherPlot.x1 + otherPlot.width / 2;
                            const centerZ2 = otherPlot.z1 + otherPlot.height / 2;
                            
                            const distance = Math.sqrt(
                                Math.pow(centerX2 - centerX1, 2) + Math.pow(centerZ2 - centerZ1, 2)
                            );

                            if (distance <= maxDistance) {
                                cluster.push(otherPlot);
                                processed.add(otherIndex);
                                findNearbyPlots(otherPlot);
                            }
                        });
                    };

                    findNearbyPlots(plot);
                    clusters.push(cluster);
                });

                return clusters;
            }

            function highlightDistrict(districtName) {
                const allPlotRects = svg.querySelectorAll('.plot-rect');
                allPlotRects.forEach(plotRect => {
                    const plotGroup = plotRect.parentElement;
                    const plotData = JSON.parse(plotGroup.dataset.plotData);
                    
                    if (plotData.district === districtName) {
                        plotRect.classList.add('highlighted');
                        plotRect.classList.remove('dimmed');
                    } else {
                        plotRect.classList.add('dimmed');
                        plotRect.classList.remove('highlighted');
                    }
                });
            }

            function clearHighlight() {
                const allPlotRects = svg.querySelectorAll('.plot-rect');
                allPlotRects.forEach(plotRect => {
                    plotRect.classList.remove('highlighted', 'dimmed');
                });
            }

            function showSimpleTooltip(event, plotData) {
                const isOwned = plotData.owner && plotData.owner.trim() !== '' && plotData.owner.toLowerCase().trim() !== 'skarb miasta';
                tooltip.innerHTML = `
                    <div class="font-semibold ${isOwned ? 'text-red-400' : 'text-green-400'}">
                        ${isOwned ? 'Zajta' : 'Wolna'}
                    </div>
                `;
                tooltip.classList.remove('hidden');
                moveTooltip(event);
            }

            function showModal(plotData) {
                const isOwned = plotData.owner && plotData.owner.trim() !== '' && plotData.owner.toLowerCase().trim() !== 'skarb miasta';
                
                modalContent.innerHTML = `
                    <div class="space-y-4">
                        <h3 class="text-lg font-bold border-b border-gray-600 pb-2">
                            ${plotData.name || `Dziaka nr ${plotData.id}`}
                        </h3>
                        
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <span class="text-gray-400">Status:</span>
                                <div class="font-semibold ${isOwned ? 'text-red-400' : 'text-green-400'}">
                                    ${isOwned ? 'Zajta' : 'Wolna'}
                                </div>
                            </div>
                            
                            <div>
                                <span class="text-gray-400">Waciciel:</span>
                                <div class="break-words">${plotData.owner || 'Brak'}</div>
                            </div>
                            
                            <div>
                                <span class="text-gray-400">Sektor:</span>
                                <div>${plotData.sector}</div>
                            </div>
                            
                            ${plotData.district ? `
                                <div>
                                    <span class="text-gray-400">Dzielnica:</span>
                                    <div class="break-words">${plotData.district}</div>
                                </div>
                            ` : ''}
                            
                            <div>
                                <span class="text-gray-400">Typ:</span>
                                <div class="break-words">${plotData.type}</div>
                            </div>
                            
                            <div>
                                <span class="text-gray-400">Powierzchnia:</span>
                                <div>${plotData.area} m虏</div>
                            </div>
                            
                            <div>
                                <span class="text-gray-400">Wymiary:</span>
                                <div>${plotData.width}x${plotData.height}</div>
                            </div>
                            
                            <div>
                                <span class="text-gray-400">Warto:</span>
                                <div class="flex items-center gap-1">
                                    ${plotData.value || 'Brak'} 
                                    ${plotData.value ? '<img src="minecoin.png" class="inline w-4 h-4" alt="MC">' : ''}
                                </div>
                            </div>
                            
                            <div>
                                <span class="text-gray-400">Koordynaty:</span>
                                <div>(${plotData.x1}, ${plotData.z1})</div>
                            </div>
                            
                            ${plotData.street ? `
                                <div>
                                    <span class="text-gray-400">Adres:</span>
                                    <div class="break-words">
                                        ${plotData.street}${plotData.buildingNumber ? ` ${plotData.buildingNumber}` : ''}
                                    </div>
                                </div>
                            ` : ''}
                            
                            ${plotData.apartmentCount ? `
                                <div>
                                    <span class="text-gray-400">Ilo lokali:</span>
                                    <div>${plotData.apartmentCount}</div>
                                </div>
                            ` : ''}
                            
                            ${plotData.prevOwner ? `
                                <div class="col-span-2">
                                    <span class="text-gray-400">Poprzedni waciciel:</span>
                                    <div class="break-words">${plotData.prevOwner}</div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
                
                modal.classList.add('show');
            }

            function hideTooltip() {
                tooltip.classList.add('hidden');
            }
            
            function moveTooltip(event) {
                const PADDING = 15;
                const rect = mapContainer.getBoundingClientRect();
                
                let clientX = event.clientX || (event.touches && event.touches[0] ? event.touches[0].clientX : 0);
                let clientY = event.clientY || (event.touches && event.touches[0] ? event.touches[0].clientY : 0);
                
                tooltip.style.visibility = 'hidden';
                tooltip.classList.remove('hidden');
                const tooltipRect = tooltip.getBoundingClientRect();
                tooltip.style.visibility = 'visible';
                
                let x = clientX + PADDING;
                let y = clientY + PADDING;
                
                if (x + tooltipRect.width > window.innerWidth) {
                    x = clientX - tooltipRect.width - PADDING;
                }
                if (y + tooltipRect.height > window.innerHeight) {
                    y = clientY - tooltipRect.height - PADDING;
                }
                
                x = Math.max(PADDING, Math.min(x, window.innerWidth - tooltipRect.width - PADDING));
                y = Math.max(PADDING, Math.min(y, window.innerHeight - tooltipRect.height - PADDING));
                
                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;
            }

            function searchPlot(query) {
                query = query.trim().toLowerCase();
                
                let plot = null;
                
                // Search by full ID (SS/III format)
                if (query.includes('/')) {
                    plot = allPlots.find(p => p.id.toLowerCase() === parseInt(query) || p.name.toLowerCase() == query);
                } else {
                    // Search by number only (III format) - find first match
                    plot = allPlots.find(p => {
                        const parts = p.id.split('/');
                        return parts.length === 2 && parts[1].toLowerCase() === query;
                    });
                }
                
                if (plot) {
                    // Center view on the plot
                    const centerX = plot.x1 + plot.width / 2;
                    const centerZ = plot.z1 + plot.height / 2;
                    const zoomLevel = Math.min(viewBox.w, viewBox.h) * 0.1; // Zoom in significantly
                    
                    setViewBox(
                        centerX - zoomLevel / 2,
                        centerZ - zoomLevel / 2,
                        zoomLevel,
                        zoomLevel
                    );
                    
                    // Show modal for the found plot
                    setTimeout(() => showModal(plot), 300);
                    
                    return true;
                }
                return false;
            }

            function getEventPoint(event) {
                if (event.touches && event.touches.length > 0) {
                    return { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
                return { x: event.clientX, y: event.clientY };
            }

            function getTouchDistance(touches) {
                if (touches.length < 2) return 0;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Event listeners

            // Search functionality
            searchButton.addEventListener('click', () => {
                const query = searchInput.value.trim();
                if (query) {
                    if (!searchPlot(query)) {
                        alert('Nie znaleziono dziaki o podanym identyfikatorze');
                    }
                }
            });

            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    searchButton.click();
                }
            });

            // Modal close
            closeModal.addEventListener('click', () => {
                modal.classList.remove('show');
            });

            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('show');
                }
            });

            // Mouse events
            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = mapContainer.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const w = viewBox.w;
                const h = viewBox.h;
                const dw = w * -Math.sign(e.deltaY) * 0.1;
                const dh = h * -Math.sign(e.deltaY) * 0.1;
                const dx = dw * mx / mapContainer.clientWidth;
                const dy = dh * my / mapContainer.clientHeight;
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w - dw, viewBox.h - dh);
            });

            mapContainer.addEventListener('mousedown', (e) => {
                isPanning = true;
                mapContainer.classList.remove('grab');
                mapContainer.classList.add('grabbing');
                startPoint = getEventPoint(e);
            });

            mapContainer.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const endPoint = getEventPoint(e);
                const dx = (startPoint.x - endPoint.x) * (viewBox.w / mapContainer.clientWidth);
                const dy = (startPoint.y - endPoint.y) * (viewBox.h / mapContainer.clientHeight);
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                startPoint = endPoint;
            });

            mapContainer.addEventListener('mouseup', () => {
                isPanning = false;
                mapContainer.classList.remove('grabbing');
                mapContainer.classList.add('grab');
            });

            mapContainer.addEventListener('mouseleave', () => {
                if (isPanning) {
                    isPanning = false;
                    mapContainer.classList.remove('grabbing');
                    mapContainer.classList.add('grab');
                }
            });

            // Touch events
            mapContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const now = Date.now();
                
                if (e.touches.length === 1) {
                    isPanning = true;
                    startPoint = getEventPoint(e);
                    
                    if (now - lastTouchTime < 300) {
                        const w = viewBox.w;
                        const h = viewBox.h;
                        const dw = w * -0.3;
                        const dh = h * -0.3;
                        setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh);
                    }
                    lastTouchTime = now;
                } else if (e.touches.length === 2) {
                    isPanning = false;
                    touchDistance = getTouchDistance(e.touches);
                }
            });

            mapContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                if (e.touches.length === 1 && isPanning) {
                    const endPoint = getEventPoint(e);
                    const dx = (startPoint.x - endPoint.x) * (viewBox.w / mapContainer.clientWidth);
                    const dy = (startPoint.y - endPoint.y) * (viewBox.h / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                    startPoint = endPoint;
                } else if (e.touches.length === 2) {
                    const newDistance = getTouchDistance(e.touches);
                    if (touchDistance > 0) {
                        const scale = touchDistance / newDistance;
                        const w = viewBox.w;
                        const h = viewBox.h;
                        const dw = w * (1 - scale);
                        const dh = h * (1 - scale);
                        setViewBox(viewBox.x + dw/2, viewBox.y + dh/2, viewBox.w - dw, viewBox.h - dh);
                    }
                    touchDistance = newDistance;
                }
            });

            mapContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                isPanning = false;
                touchDistance = 0;
            });

            // Control buttons
            document.getElementById('zoom-in').addEventListener('click', () => {
                const w = viewBox.w;
                const h = viewBox.h;
                const dw = w * -0.2;
                const dh = h * -0.2;
                setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh);
            });

            document.getElementById('zoom-out').addEventListener('click', () => {
                const w = viewBox.w;
                const h = viewBox.h;
                const dw = w * 0.2;
                const dh = h * 0.2;
                setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh);
            });

            document.getElementById('reset-view').addEventListener('click', () => {
                Object.assign(viewBox, initialViewBox);
                setViewBox(viewBox.x, viewBox.y, viewBox.w, viewBox.h);
            });

            // Hide tooltip on outside touch/click
            document.addEventListener('touchstart', (e) => {
                if (!tooltip.contains(e.target) && !svg.contains(e.target)) {
                    hideTooltip();
                }
            });

            // Initialize
            fetchAllData();
        });
    </script>
</body>
</html>