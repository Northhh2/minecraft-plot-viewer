<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>System Dziaek Minecraft</title>
    <link rel="icon" type="image/x-icon" href="Red.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        #map-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        #map-svg {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111827;
        }

        .plot-rect {
            stroke-width: 0.5;
            transition: fill 0.2s ease-in-out, fill-opacity 0.3s ease-in-out, filter 0.3s ease-in-out, stroke 0.3s, stroke-width 0.3s;
        }

        .plot-rect:hover {
            fill-opacity: 0.7;
        }

        .plot-rect.dimmed {
            fill-opacity: 0.2 !important;
            filter: grayscale(80%);
        }

        .plot-rect.highlighted {
            fill-opacity: 1 !important;
            filter: brightness(1.2);
            stroke: #facc15;
            stroke-width: 1.5;
        }

        .street-rect {
            fill: #4b5563;
            fill-opacity: 0.9;
            stroke: transparent;
            stroke-width: 0.25;
            transition: fill-opacity 0.2s, stroke 0.2s;
            cursor: pointer;
        }

        .street-rect:hover {
            fill-opacity: 0.7;
            stroke: #9ca3af;
        }

        .merged-plot {
            stroke: #f59e0b;
            stroke-width: 1.5;
            stroke-dasharray: 4, 2;
            fill: none;
            pointer-events: all;
            cursor: pointer;
        }

        .plot-text {
            font-size: 4px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 0.5px;
            stroke-linecap: butt;
            stroke-linejoin: miter;
        }

        .street-text {
            font-size: 3px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .street-text.street-vertical {
            writing-mode: vertical-rl;
        }

        #tooltip {
            background-color: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid #4b5563;
            transition: opacity 0.2s ease-in-out;
        }

        #modal {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }

        #modal.show {
            transform: translateX(0);
        }

        #modal-content {
            transition: opacity 0.15s ease-out;
        }

        #modal-content.fade-out {
            opacity: 0;
        }

        .grab {
            cursor: grab;
        }

        .grabbing {
            cursor: grabbing;
        }

        .toggle-button {
            opacity: 0.5;
            border: 1px solid #4b5563;
        }

        .toggle-button.active {
            opacity: 1;
            background-color: #4338ca;
            border-color: #6d28d9;
        }

        .hidden-layer {
            display: none;
        }

        .chart-container {
            height: 200px;
            width: 100%;
        }

        .clickable {
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .clickable:hover {
            color: #a78bfa;
        }

        #search-suggestions {
            max-height: 300px;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            #tooltip {
                font-size: 12px;
                max-width: 90vw;
                max-height: 50vh;
                overflow-y: auto;
            }

            .plot-text {
                font-size: 3px;
            }

            .controls {
                bottom: 10px !important;
                right: 10px !important;
            }

            .control-button {
                width: 44px;
                height: 44px;
            }

            #modal {
                width: 100vw;
            }
        }
    </style>
</head>

<body class="bg-gray-900 text-white">

    <!-- Search Bar -->
    <div class="absolute top-5 left-5 z-30">
        <div class="relative">
            <div class="flex bg-gray-800 rounded-lg border border-gray-600 shadow-lg">
                <input type="text" id="search-input" placeholder="Wyszukaj (dziaka, waciciel, adres...)"
                    class="bg-transparent text-white px-4 py-2 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-purple-500 w-48 md:w-64"
                    maxlength="30" autocomplete="off">
                <button id="search-button"
                    class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-r-lg transition-colors"></button>
            </div>
            <div id="search-suggestions"
                class="absolute left-0 mt-2 w-full bg-gray-800 border border-gray-600 rounded-lg shadow-lg z-10 hidden">
                <!-- Suggestions will be populated here by JS -->
            </div>
        </div>
    </div>

    <!-- Main container for the map -->
    <div id="map-container" class="grab">
        <svg id="map-svg"></svg>
    </div>

    <!-- Simple Tooltip -->
    <div id="tooltip" class="hidden absolute p-2 rounded-lg shadow-xl text-sm z-40 pointer-events-none"></div>

    <!-- Right Side Modal -->
    <div id="modal"
        class="fixed top-0 right-0 w-full md:w-96 h-full bg-gray-800 border-l border-gray-600 shadow-2xl z-50 overflow-y-auto">
        <div class="p-6">
            <div class="flex justify-between items-center mb-4">
                <div class="flex items-center space-x-3">
                    <button id="back-modal"
                        class="hidden text-gray-400 hover:text-white text-2xl font-bold transition-opacity"
                        title="Wr贸">&larr;</button>
                    <h2 id="modal-title" class="text-xl font-bold">Szczeg贸y</h2>
                </div>
                <button id="close-modal" class="text-gray-400 hover:text-white text-2xl"
                    title="Zamknij">&times;</button>
            </div>
            <div id="modal-content" class="space-y-4"></div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loader" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50">
        <div class="text-center">
            <svg class="animate-spin h-8 w-8 text-white mx-auto mb-3" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            <p class="text-lg font-medium">Pobieranie danych...</p>
            <p class="text-sm text-gray-400">Prosz czeka</p>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls absolute flex flex-col items-end z-30" style="bottom: 20px; right: 20px;">
        <div class="flex flex-col space-y-2">
            <button id="zoom-in"
                class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600"
                title="Powiksz"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg></button>
            <button id="zoom-out"
                class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600"
                title="Pomniejsz"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg></button>
            <button id="reset-view"
                class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600"
                title="Resetuj widok"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 2v6h6"></path>
                    <path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path>
                    <path d="M21 22v-6h-6"></path>
                    <path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path>
                </svg></button>
        </div>
        <div id="layer-toggles" class="mt-2 flex flex-col space-y-2">
            <button id="toggle-plots"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka偶/Ukryj Dziaki"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                </svg></button>
            <button id="toggle-streets"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka偶/Ukryj Ulice"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <line x1="4" y1="20" x2="4" y2="4"></line>
                    <line x1="20" y1="20" x2="20" y2="4"></line>
                    <line x1="12" y1="4" x2="12" y2="20"></line>
                </svg></button>
            <button id="toggle-districts"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka偶/Ukryj Dzielnice"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg></button>
            <button id="toggle-merged"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka偶/Ukryj Poczone Dziaki"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                </svg></button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const SHEET_ID = '1swtElpz27sqLMNbATocFe9VHc1yZTSRxvHyikFL_R7U';
            const PLOTS_GID = '0';
            const MERGED_GID = '43897086';
            const STREETS_GID = '2101138806';
            const LOCALS_GID = '875214507';
            const OWNERS_GID = '92681717'; // NOWA TABELA

            const PLOTS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${PLOTS_GID}`;
            const MERGED_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${MERGED_GID}`;
            const STREETS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${STREETS_GID}`;
            const LOCALS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${LOCALS_GID}`;
            const OWNERS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${OWNERS_GID}`;

            const MAP_IMAGE_URL = 'map.webp';
            const MAP_WIDTH = 4296;
            const MAP_HEIGHT = 2360;

            const svg = document.getElementById('map-svg');
            const tooltip = document.getElementById('tooltip');
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContent = document.getElementById('modal-content');
            const loader = document.getElementById('loader');
            const mapContainer = document.getElementById('map-container');
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const searchSuggestions = document.getElementById('search-suggestions');
            const closeModalBtn = document.getElementById('close-modal');

            let viewBox = { x: 0, y: 0, w: 0, h: 0 };
            let isPanning = false;
            let startPoint = { x: 0, y: 0 };
            const initialViewBox = {};
            let layerVisibility = { plots: true, streets: true, districts: true, merged: true };
            let touchStartInfo = { time: 0, x: 0, y: 0 };
            let activeCharts = [];
            let maxViewboxWidth = MAP_WIDTH;
            let isAnimatingModal = false;

            let allPlots = [];
            let allLocals = [];
            let allOwners = []; // NOWA ZMIENNA
            let mergedPlots = [];
            let streets = [];

            let modalHistory = [];

            const layers = {
                districts: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                merged: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                streets: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                plots: document.createElementNS('http://www.w3.org/2000/svg', 'g')
            };

            function setViewBox(x, y, w, h) {
                const isMobile = window.innerWidth <= 768;
                const minZoom = isMobile ? 50 : 100;
                w = Math.max(minZoom, w);
                w = Math.min(w, maxViewboxWidth);
                if (initialViewBox.w) { h = (w / initialViewBox.w) * initialViewBox.h; }
                const minX_bound = -MAP_WIDTH / 2, minY_bound = -MAP_HEIGHT / 2;
                const maxX_bound = MAP_WIDTH / 2, maxY_bound = MAP_HEIGHT / 2;
                if (x < minX_bound) x = minX_bound;
                if (y < minY_bound) y = minY_bound;
                if (x + w > maxX_bound) x = maxX_bound - w;
                if (y + h > maxY_bound) y = maxY_bound - h;
                viewBox = { x, y, w, h };
                svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
            }

            function getColorForType(type, alpha = 0.8) {
                switch (type) {
                    case 'Parkowa': return `rgba(0, 170, 0, ${alpha})`;
                    case 'Rolna': return `rgba(180, 104, 77, ${alpha})`;
                    case 'Hotelowa': return `rgba(44, 186, 168, ${alpha})`;
                    case 'Mieszkalna': return `rgba(222, 177, 45, ${alpha})`;
                    case 'Sakralna': return `rgba(154, 92, 198, ${alpha})`;
                    case 'Przemysowo-biurowa': return `rgba(255, 85, 255, ${alpha})`;
                    case 'Mieszkalno-usugowa': return `rgba(33, 73, 123, ${alpha})`;
                    case 'Publiczna': return `rgba(255, 170, 0, ${alpha})`;
                    case 'Medyczna': return `rgba(170, 0, 0, ${alpha})`;
                    case 'Usugowa': return `rgba(17, 160, 54, ${alpha})`;
                    default: return `rgba(255, 255, 255, 0.1)`;
                }
            }

            function openNewModal(state) {
                modalHistory = [];
                navigateToModal(state);
            }

            function navigateToModal(state) {
                modalHistory.push(state);
                renderCurrentModal();
            }

            function goBackModal() {
                if (modalHistory.length > 1) {
                    modalHistory.pop();
                    renderCurrentModal(true);
                }
            }

            function closeModal() {
                destroyActiveCharts();
                modalHistory = [];
                modal.classList.remove('show');
            }

            async function fetchAllData() {
                try {
                    const responses = await Promise.all([
                        fetch(PLOTS_URL), fetch(MERGED_URL), fetch(STREETS_URL), fetch(LOCALS_URL), fetch(OWNERS_URL)
                    ]);

                    if (responses.some(res => !res.ok)) throw new Error('Network response was not ok');

                    const texts = await Promise.all(responses.map(res => res.text()));

                    const [plotsResult, mergedResult, streetsResult, localsResult, ownersResult] = await Promise.all([
                        new Promise(resolve => Papa.parse(texts[0], { header: true, skipEmptyLines: true, complete: resolve })),
                        new Promise(resolve => Papa.parse(texts[1], { header: true, skipEmptyLines: true, complete: resolve })),
                        new Promise(resolve => Papa.parse(texts[2], { header: true, skipEmptyLines: true, complete: resolve })),
                        new Promise(resolve => Papa.parse(texts[3], { header: true, skipEmptyLines: true, complete: resolve })),
                        new Promise(resolve => Papa.parse(texts[4], { header: true, skipEmptyLines: true, complete: resolve }))
                    ]);

                    allPlots = plotsResult.data.filter(p => p['Nr porzdkowy'] && p['X (lewy g贸rny)'])
                        .map(d => ({
                            id: d['Nr porzdkowy'], name: d['Nazwa porzdkowa dziaki'], type: d['Typ'],
                            x1: parseInt(d['X (lewy g贸rny)'], 10), z1: parseInt(d['Z (lewy g贸rny)'], 10),
                            x2: parseInt(d['X (prawy dolny)'], 10), z2: parseInt(d['Z (prawy dolny)'], 10),
                            width: parseInt(d['Bok X'], 10), height: parseInt(d['Bok Z'], 10), area: d['Powierzchnia'],
                            value: d['Warto'], owner: d['Aktualny waciciel'], district: d['Dzielnica'],
                            street: d['Ulica'], buildingNumber: d['Numer budynku']
                        }));

                    allLocals = localsResult.data.filter(l => l['Numer porzdkowy'] && l['Numer dziaki'])
                        .map(l => ({
                            id: l['Numer porzdkowy'], plotName: l['Numer dziaki'], street: l['Ulica'],
                            building: l['Numer budynku'], localNum: l['Numer lokalu'], floor: l['Pitro'],
                            area: parseInt(l['Powierzchnia']) || 0, beds: parseInt(l['Ilo 贸偶ek']) || 0,
                            workplaces: parseInt(l['Ilo miejsc pracy']) || 0, tenant: l['Najemca']
                        }));

                    allOwners = ownersResult.data.map(o => ({
                        name: o['Nazwa'], type: o['Typ'], photo: o['Zdjcie'],
                        nio: o['NIO'], age: o['Wiek'], profession: o['Zaw贸d'],
                        legalForm: o['Forma prawna']
                    }));

                    const connections = mergedResult.data.filter(m => m['Dziaka g贸wna'] && m['Dziaka doczana'])
                        .map(d => ({ plot1: d['Dziaka g贸wna'], plot2: d['Dziaka doczana'] }));
                    mergedPlots = processMergedPlots(connections);

                    streets = streetsResult.data.filter(s => s['X (lewy g贸rny)'])
                        .map(d => ({
                            name: d['Nazwa ulicy'],
                            x1: parseInt(d['X (lewy g贸rny)'], 10), z1: parseInt(d['Z (lewy g贸rny)'], 10),
                            width: parseInt(d['X (prawy dolny)'], 10) - parseInt(d['X (lewy g贸rny)'], 10) + 1,
                            height: parseInt(d['Z (prawy dolny)'], 10) - parseInt(d['Z (lewy g贸rny)'], 10) + 1
                        }));

                    drawMap();
                    loader.style.display = 'none';

                } catch (error) {
                    console.error("Bd podczas pobierania danych:", error);
                    loader.innerHTML = `<div class="text-center"><p class="text-lg font-medium text-red-500">Bd adowania danych</p><p class="text-sm text-gray-400">Sprawd藕 konsol.</p></div>`;
                }
            }

            function processMergedPlots(connections) {
                const adj = new Map();
                const allPlotIdsInConnections = new Set();
                connections.forEach(({ plot1, plot2 }) => {
                    if (!adj.has(plot1)) adj.set(plot1, []);
                    if (!adj.has(plot2)) adj.set(plot2, []);
                    adj.get(plot1).push(plot2);
                    adj.get(plot2).push(plot1);
                    allPlotIdsInConnections.add(plot1);
                    allPlotIdsInConnections.add(plot2);
                });
                const visited = new Set();
                const groups = [];
                for (const plotId of allPlotIdsInConnections) {
                    if (!visited.has(plotId)) {
                        const group = [];
                        const stack = [plotId];
                        visited.add(plotId);
                        while (stack.length > 0) {
                            const currentId = stack.pop();
                            group.push(currentId);
                            const neighbors = adj.get(currentId) || [];
                            for (const neighbor of neighbors) {
                                if (!visited.has(neighbor)) {
                                    visited.add(neighbor);
                                    stack.push(neighbor);
                                }
                            }
                        }
                        groups.push(group);
                    }
                }
                return groups.map(group => {
                    const plotsInGroup = group.map(id => allPlots.find(p => p.name === id)).filter(Boolean);
                    if (plotsInGroup.length === 0) return null;
                    const minX = Math.min(...plotsInGroup.map(p => p.x1));
                    const maxX = Math.max(...plotsInGroup.map(p => p.x2));
                    const minZ = Math.min(...plotsInGroup.map(p => p.z1));
                    const maxZ = Math.max(...plotsInGroup.map(p => p.z2));
                    const originalArea = plotsInGroup.reduce((sum, p) => sum + (parseInt(p.area) || 0), 0);
                    return {
                        plots: group, x1: minX, z1: minZ, x2: maxX, z2: maxZ,
                        width: maxX - minX, height: maxZ - minZ, originalArea, mergedArea: (maxX - minX) * (maxZ - minZ)
                    };
                }).filter(Boolean);
            }

            function drawMap() {
                if (!allPlots.length) return;
                svg.innerHTML = '';
                const mapImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                mapImage.setAttribute('href', MAP_IMAGE_URL);
                mapImage.setAttribute('x', -MAP_WIDTH / 2);
                mapImage.setAttribute('y', -MAP_HEIGHT / 2);
                mapImage.setAttribute('width', MAP_WIDTH);
                mapImage.setAttribute('height', MAP_HEIGHT);
                svg.appendChild(mapImage);
                Object.values(layers).forEach(layer => layer.innerHTML = '');
                layers.districts.id = 'districts-layer';
                layers.merged.id = 'merged-layer';
                layers.streets.id = 'streets-layer';
                layers.plots.id = 'plots-layer';
                svg.appendChild(layers.districts);
                svg.appendChild(layers.merged);
                svg.appendChild(layers.streets);
                svg.appendChild(layers.plots);
                drawStreets();
                drawPlots();
                drawMergedPlots();
                drawDistrictBoundaries();
                const padding = 100;
                const minX = Math.min(...allPlots.map(p => p.x1));
                const maxX = Math.max(...allPlots.map(p => p.x2));
                const minZ = Math.min(...allPlots.map(p => p.z1));
                const maxZ = Math.max(...allPlots.map(p => p.z2));
                const mapContentWidth = maxX - minX + 2 * padding;
                const mapContentHeight = maxZ - minZ + 2 * padding;
                const clientRatio = mapContainer.clientWidth / mapContainer.clientHeight;
                const contentRatio = mapContentWidth / mapContentHeight;
                let w, h;
                if (clientRatio > contentRatio) {
                    h = mapContentHeight;
                    w = h * clientRatio;
                } else {
                    w = mapContentWidth;
                    h = w / clientRatio;
                }
                initialViewBox.x = minX - (w - mapContentWidth + 2 * padding) / 2;
                initialViewBox.y = minZ - (h - mapContentHeight + 2 * padding) / 2;
                initialViewBox.w = w;
                initialViewBox.h = h;
                const mapRatio = MAP_WIDTH / MAP_HEIGHT;
                if (clientRatio > mapRatio) {
                    maxViewboxWidth = MAP_HEIGHT * clientRatio;
                } else {
                    maxViewboxWidth = MAP_WIDTH;
                }
                setViewBox(initialViewBox.x, initialViewBox.y, initialViewBox.w, initialViewBox.h);
            }

            function drawStreets() {
                streets.forEach(street => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', street.x1); rect.setAttribute('y', street.z1);
                    rect.setAttribute('width', street.width); rect.setAttribute('height', street.height);
                    rect.setAttribute('class', 'street-rect');
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', street.x1 + street.width / 2);
                    text.setAttribute('y', street.z1 + street.height / 2);
                    text.setAttribute('class', 'street-text');
                    if (street.height > street.width) {
                        text.classList.add('street-vertical');
                    }
                    text.textContent = street.name;
                    g.appendChild(rect); g.appendChild(text);
                    g.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold">${street.name}</div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    g.addEventListener('mouseleave', hideTooltip);
                    g.addEventListener('mousemove', moveTooltip);
                    layers.streets.appendChild(g);
                });
            }

            function drawMergedPlots() {
                mergedPlots.forEach((merged) => {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', merged.x1); rect.setAttribute('y', merged.z1);
                    rect.setAttribute('width', merged.width); rect.setAttribute('height', merged.height);
                    rect.setAttribute('class', 'merged-plot');
                    rect.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold mb-1">Poczone dziaki</div><div class="text-xs">Kliknij, by zobaczy szczeg贸y</div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    rect.addEventListener('mouseleave', hideTooltip);
                    rect.addEventListener('mousemove', moveTooltip);
                    rect.addEventListener('click', (e) => { e.stopPropagation(); openNewModal({ type: 'merged', data: merged }); });

                    let mergedTouchStartInfo = {};
                    rect.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 1) mergedTouchStartInfo = { time: Date.now(), x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }, { passive: true });

                    rect.addEventListener('touchend', (e) => {
                        if (mergedTouchStartInfo.time) {
                            const timeDiff = Date.now() - mergedTouchStartInfo.time;
                            const dist = Math.hypot(e.changedTouches[0].clientX - mergedTouchStartInfo.x, e.changedTouches[0].clientY - mergedTouchStartInfo.y);
                            if (timeDiff < 250 && dist < 10) { e.preventDefault(); openNewModal({ type: 'merged', data: merged }); }
                            mergedTouchStartInfo = {};
                        }
                    });

                    layers.merged.appendChild(rect);
                });
            }

            function drawPlots() {
                allPlots.forEach(plot => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.dataset.plotId = plot.id;
                    g.dataset.plotName = plot.name;
                    g.dataset.plotDistrict = plot.district || '';
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', plot.x1); rect.setAttribute('y', plot.z1);
                    rect.setAttribute('width', plot.width); rect.setAttribute('height', plot.height);
                    rect.setAttribute('class', 'plot-rect');
                    rect.style.fill = getColorForType(plot.type);
                    const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                    rect.style.stroke = isOwned ? '#ef4444' : '#22c55e';
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', plot.x1 + plot.width / 2);
                    text.setAttribute('y', plot.z1 + plot.height / 2);
                    text.setAttribute('class', 'plot-text');
                    text.textContent = plot.id.padStart(3, '0');
                    g.appendChild(rect); g.appendChild(text);
                    g.addEventListener('mouseenter', (e) => { showSimpleTooltip(e, plot); if (plot.district) highlightDistrict(plot.district); });
                    g.addEventListener('mouseleave', () => { hideTooltip(); clearHighlight(); });
                    g.addEventListener('mousemove', moveTooltip);
                    g.addEventListener('click', (e) => { e.stopPropagation(); openNewModal({ type: 'plot', data: plot }); });

                    g.addEventListener('touchend', (e) => {
                        if (touchStartInfo.time) {
                            const timeDiff = Date.now() - touchStartInfo.time;
                            const dist = Math.hypot(e.changedTouches[0].clientX - touchStartInfo.x, e.changedTouches[0].clientY - touchStartInfo.y);
                            if (timeDiff < 250 && dist < 10) { e.preventDefault(); openNewModal({ type: 'plot', data: plot }); }
                        }
                    });

                    layers.plots.appendChild(g);
                });
            }

            function drawDistrictBoundaries() {
                const districts = {};
                allPlots.forEach(plot => {
                    if (plot.district && plot.district.trim() !== '') {
                        const districtName = plot.district.trim();
                        if (!districts[districtName]) districts[districtName] = [];
                        districts[districtName].push(plot);
                    }
                });
                Object.entries(districts).forEach(([districtName, districtPlots]) => {
                    if (districtPlots.length === 0) return;
                    const clusters = createDistrictClusters(districtPlots, 50);
                    clusters.forEach((cluster) => {
                        const boundary = createDistrictOutline(cluster);
                        if (!boundary) return;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', boundary);
                        path.style.cssText = "fill:none; stroke:#8b5cf6; stroke-width:2; stroke-dasharray:8,4; opacity:0.7; cursor:pointer; pointer-events:all;";
                        path.dataset.districtName = districtName;
                        path.addEventListener('mouseenter', () => highlightDistrict(districtName));
                        path.addEventListener('mouseleave', () => clearHighlight());
                        path.addEventListener('click', (e) => { e.stopPropagation(); openNewModal({ type: 'district', data: { name: districtName, plots: cluster } }); });
                        layers.districts.appendChild(path);
                        const minX = Math.min(...cluster.map(p => p.x1));
                        const maxX = Math.max(...cluster.map(p => p.x2));
                        const minZ = Math.min(...cluster.map(p => p.z1));
                        const districtLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        districtLabel.setAttribute('x', minX + (maxX - minX) / 2);
                        districtLabel.setAttribute('y', minZ - 8);
                        districtLabel.style.cssText = "fill:#a78bfa; font-size:7px; font-weight:bold; text-anchor:middle; pointer-events:none;";
                        districtLabel.textContent = districtName;
                        layers.districts.appendChild(districtLabel);
                    });
                });
            }

            function createDistrictClusters(plots, maxDistance) {
                const clusters = []; let visited = new Set();
                plots.forEach(plot => {
                    if (!visited.has(plot.id)) {
                        const newCluster = []; const queue = [plot];
                        visited.add(plot.id);
                        while (queue.length > 0) {
                            const currentPlot = queue.shift();
                            newCluster.push(currentPlot);
                            plots.forEach(otherPlot => {
                                if (!visited.has(otherPlot.id)) {
                                    if (currentPlot.x1 <= otherPlot.x2 + maxDistance && currentPlot.x2 >= otherPlot.x1 - maxDistance &&
                                        currentPlot.z1 <= otherPlot.z2 + maxDistance && currentPlot.z2 >= otherPlot.z1 - maxDistance) {
                                        visited.add(otherPlot.id);
                                        queue.push(otherPlot);
                                    }
                                }
                            });
                        }
                        clusters.push(newCluster);
                    }
                });
                return clusters;
            }

            function createDistrictOutline(plots) {
                if (plots.length === 0) return '';
                const borders = { top: [], right: [], bottom: [], left: [] };
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                plots.forEach(plot => {
                    const x_min = Math.min(plot.x1, plot.x2), x_max = Math.max(plot.x1, plot.x2);
                    const z_min = Math.min(plot.z1, plot.z2), z_max = Math.max(plot.z1, plot.z2);
                    minX = Math.min(minX, x_min); maxX = Math.max(maxX, x_max);
                    minZ = Math.min(minZ, z_min); maxZ = Math.max(maxZ, z_max);
                    borders.top.push({ fcrd: z_min, scrd: [x_min, x_max] });
                    borders.bottom.push({ fcrd: z_max, scrd: [x_min, x_max] });
                    borders.left.push({ fcrd: x_min, scrd: [z_min, z_max] });
                    borders.right.push({ fcrd: x_max, scrd: [z_min, z_max] });
                });
                const sweepAndFindBorders = (a_borders, span, sortAsc) => {
                    const externalBorders = []; let uncoveredSpan = [span];
                    a_borders.sort((a, b) => sortAsc ? a.fcrd - b.fcrd : b.fcrd - a.fcrd);
                    for (const border of a_borders) {
                        if (uncoveredSpan.length === 0) break;
                        const [border_start, border_end] = border.scrd; const nextUncovered = [];
                        for (const [span_start, span_end] of uncoveredSpan) {
                            const overlap_start = Math.max(border_start, span_start), overlap_end = Math.min(border_end, span_end);
                            if (overlap_end > overlap_start) {
                                externalBorders.push({ ...border, scrd: [overlap_start, overlap_end] });
                                if (span_start < overlap_start) nextUncovered.push([span_start, overlap_start]);
                                if (span_end > overlap_end) nextUncovered.push([overlap_end, span_end]);
                            } else { nextUncovered.push([span_start, span_end]); }
                        }
                        uncoveredSpan = nextUncovered;
                    }
                    return externalBorders;
                };
                const topExt = sweepAndFindBorders(borders.top, [minX, maxX], true);
                const bottomExt = sweepAndFindBorders(borders.bottom, [minX, maxX], false);
                const leftExt = sweepAndFindBorders(borders.left, [minZ, maxZ], true);
                const rightExt = sweepAndFindBorders(borders.right, [minZ, maxZ], false);
                const allSegmentsRaw = [
                    ...topExt.map(s => [[s.scrd[0], s.fcrd], [s.scrd[1], s.fcrd]]),
                    ...bottomExt.map(s => [[s.scrd[0], s.fcrd], [s.scrd[1], s.fcrd]]),
                    ...leftExt.map(s => [[s.fcrd, s.scrd[0]], [s.fcrd, s.scrd[1]]]),
                    ...rightExt.map(s => [[s.fcrd, s.scrd[0]], [s.fcrd, s.scrd[1]]]),
                ];

                const minLength = 8;
                const allSegments = allSegmentsRaw.filter(seg => {
                    const p1 = seg[0];
                    const p2 = seg[1];
                    const length = Math.abs(p2[0] - p1[0]) + Math.abs(p2[1] - p1[1]);
                    return length >= minLength;
                });

                if (allSegments.length === 0) return '';

                const points = new Map();
                allSegments.forEach(seg => {
                    const p1_key = seg[0].join(',');
                    const p2_key = seg[1].join(',');
                    if (!points.has(p1_key)) points.set(p1_key, []);
                    if (!points.has(p2_key)) points.set(p2_key, []);
                    points.get(p1_key).push(p2_key);
                    points.get(p2_key).push(p1_key);
                });

                let svgPath = '';
                const visited = new Set();
                for (const startNode of points.keys()) {
                    if (visited.has(startNode)) continue;
                    const path = [startNode];
                    visited.add(startNode);
                    let currentNode = startNode;
                    while (true) {
                        const neighbors = points.get(currentNode);
                        const nextNode = neighbors.find(n => !visited.has(n));
                        if (!nextNode) break;
                        visited.add(nextNode);
                        path.push(nextNode);
                        currentNode = nextNode;
                    }
                    if (path.length > 1) {
                        svgPath += `M ${path[0].replace(',', ' ')} `;
                        for (let i = 1; i < path.length; i++) {
                            svgPath += `L ${path[i].replace(',', ' ')} `;
                        }
                        const lastNode = path[path.length - 1];
                        const lastNodeNeighbors = points.get(lastNode);
                        if (lastNodeNeighbors && lastNodeNeighbors.includes(startNode)) {
                            svgPath += 'Z ';
                        }
                    }
                }
                return svgPath.trim();
            }


            function highlightDistrict(districtName) {
                svg.querySelectorAll('.plot-rect').forEach(rect => {
                    if (rect.parentElement.dataset.plotDistrict !== districtName) {
                        rect.classList.add('dimmed');
                    }
                });
            }

            function clearHighlight() {
                svg.querySelectorAll('.plot-rect.dimmed').forEach(rect => rect.classList.remove('dimmed'));
                svg.querySelectorAll('.plot-rect.highlighted').forEach(rect => rect.classList.remove('highlighted'));
            }

            function showSimpleTooltip(e, plot) {
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                tooltip.innerHTML = `<div class="font-bold">${plot.name || `Dziaka ${plot.id}`}</div><div class="text-xs ${isOwned ? 'text-red-400' : 'text-green-400'}">${isOwned ? 'Zajta' : 'Wolna'}</div>`;
                tooltip.classList.remove('hidden');
                moveTooltip(e);
            }

            function renderCurrentModal() {
                if (modalHistory.length === 0 || isAnimatingModal) return;
                isAnimatingModal = true;
                const currentState = modalHistory[modalHistory.length - 1];
                modalContent.classList.add('fade-out');

                setTimeout(() => {
                    destroyActiveCharts();
                    const { type, data } = currentState;
                    let contentHTML = '', title = '';
                    switch (type) {
                        case 'plot': title = `Dziaka: ${data.name}`; contentHTML = renderPlotContent(data); break;
                        case 'merged': title = 'Poczone dziaki'; contentHTML = renderMergedContent(data); break;
                        case 'local': title = `Lokal #${data.localNum}`; contentHTML = renderLocalContent(data); break;
                        case 'owner': title = `Aktywa: ${data}`; contentHTML = renderOwnerContent(data); break;
                        case 'district': title = `Dzielnica: ${data.name}`; contentHTML = renderDistrictContent(data.name, data.plots); break;
                        case 'street': title = `Ulica: ${data}`; contentHTML = renderStreetContent(data); break;
                        case 'plotType': title = `Typ: ${data}`; contentHTML = renderPlotTypeContent(data); break;
                    }
                    modalTitle.textContent = title;
                    modalContent.innerHTML = contentHTML;
                    addModalEventListeners();
                    document.getElementById('back-modal').classList.toggle('hidden', modalHistory.length <= 1);
                    modal.classList.add('show');
                    modalContent.classList.remove('fade-out');
                    isAnimatingModal = false;
                }, 150);
            }

            function createPlotListItemHTML(plot) {
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                const statusText = isOwned ? 'Zajta' : 'Wolna';
                const statusColor = isOwned ? 'text-red-400' : 'text-green-400';
                return `
                <div data-plot-name="${plot.name}" class="bg-gray-700 p-2 rounded-md hover:bg-gray-600 cursor-pointer transition-colors">
                    <div class="font-semibold text-purple-400">${plot.name} (${plot.area} m虏)</div>
                    <div class="text-xs text-gray-400">Waciciel: <span class="font-medium text-gray-200">${plot.owner || 'Brak'}</span></div>
                    <div class="text-xs ${statusColor}">${statusText}</div>
                </div>`;
            }

            function createOwnerCardHTML(ownerName, isSelf = false) {
                if (!ownerName) return '';
                const owner = allOwners.find(o => o.name === ownerName);
                const isClickable = !isSelf && ownerName.toLowerCase() !== 'skarb miasta';
                const photo = owner?.photo || 'placeholder.webp';
                const type = owner?.type ? (owner.type.charAt(0).toUpperCase() + owner.type.slice(1)) : '';
                return `<div class="flex items-center bg-gray-700 p-2 rounded-md transition-colors ${isClickable ? 'clickable hover:bg-gray-600' : ''}" ${isClickable ? `data-owner-name="${ownerName}"` : ''}>
        <img src="${photo}" onerror="this.onerror=null;this.src='placeholder.webp';" class="w-10 h-10 rounded-full mr-3 object-cover">
        <div><div class="font-semibold text-white">${ownerName}</div><div class="text-xs text-gray-400">${type}</div></div></div>`;
            }

            function renderPlotContent(plot) {
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                const ownerInfo = isOwned ? plot.owner : 'Skarb Miasta';
                const localsOnPlot = allLocals.filter(l => l.plotName === plot.name);
                let localsHTML = '';
                if (localsOnPlot.length > 0) {
                    const localDetailsList = localsOnPlot.map(l => `<div data-local-id="${l.id}" class="bg-gray-700 p-2 rounded-md hover:bg-gray-600 cursor-pointer transition-colors">
            <div class="font-semibold text-purple-400">Lokal #${l.localNum} (${l.area} m虏)</div>
            <div class="text-xs text-gray-400">Najemca: <span class="font-medium text-gray-200">${l.tenant || 'Brak'}</span></div></div>`).join('');
                    localsHTML = `<div class="border-t border-gray-700 pt-3 mt-3"><h4 class="text-md font-semibold mb-3">Lokale w budynku (${localsOnPlot.length})</h4><div class="space-y-2">${localDetailsList}</div></div>`;
                }

                let address = '';
                if (plot.street && plot.buildingNumber) {
                    address += `<span data-street-name="${plot.street}" class="clickable">${plot.street}</span> ${plot.buildingNumber}, `;
                }
                if (plot.district) {
                    address += `<span data-district-name="${plot.district}" class="clickable">${plot.district}</span>`;
                }

                const typeColorDot = `<span class="inline-block w-2.5 h-2.5 rounded-full mr-2" style="background-color: ${getColorForType(plot.type, 1)}"></span>`;
                return `<div><h3 class="text-2xl font-bold ${isOwned ? 'text-red-400' : 'text-green-400'}">${plot.name}</h3><p class="text-gray-400 text-sm">${address}</p></div>
        <div class="space-y-3">
            ${createOwnerCardHTML(ownerInfo)}
            <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm pt-3 border-t border-gray-700">
                <span class="text-gray-400">Typ:</span><span class="font-medium flex items-center clickable" data-plot-type="${plot.type}">${typeColorDot} ${plot.type || 'Brak'}</span>
                <span class="text-gray-400">Warto:</span><span class="font-medium flex items-center">${plot.value || '0'} <img src="minecoin.webp" class="inline w-4 h-4 ml-1" alt="MC"></span>
                <span class="text-gray-400">Powierzchnia:</span><span class="font-medium">${plot.area || 'Brak'} m虏</span>
            </div></div>${localsHTML}`;
            }

            function renderMergedContent(mergedPlot) {
                const constituentPlotsDetails = mergedPlot.plots
                    .map(plotName => allPlots.find(p => p.name === plotName))
                    .filter(Boolean)
                    .map(plot => createPlotListItemHTML(plot))
                    .join('');
                return `
                    <div><h3 class="text-2xl font-bold text-amber-400">Poczone Dziaki</h3><p class="text-gray-400">Grupa ${mergedPlot.plots.length} dziaek</p></div>
                    <div class="space-y-3">
                        <div>
                            <span class="text-gray-400 block mb-2">Dziaki wchodzce w skad:</span>
                            <div class="font-medium space-y-2">${constituentPlotsDetails}</div>
                        </div>
                        <div class="grid grid-cols-2 gap-x-4 gap-y-2 pt-3 border-t border-gray-700 text-sm">
                            <span class="text-gray-400">Pow. oryginalna:</span><span class="font-medium">${mergedPlot.originalArea} m虏</span>
                            <span class="text-gray-400">Pow. poczona:</span><span class="font-medium">${mergedPlot.mergedArea} m虏</span>
                        </div>
                    </div>`;
            }

            function renderLocalContent(local) {
                const plot = allPlots.find(p => p.name === local.plotName);
                let address = '';
                if (local.street && local.building) {
                    address += `<span data-street-name="${local.street}" class="clickable">${local.street}</span> ${local.building}/${local.localNum}, `;
                }
                if (plot?.district) {
                    address += `<span data-district-name="${plot.district}" class="clickable">${plot.district}</span>`;
                }

                return `<div><h3 class="text-2xl font-bold text-cyan-400">Lokal #${local.localNum}</h3><p class="text-gray-400 text-sm">${address}</p></div>
         <div class="space-y-3">
            <div><span class="text-gray-400 text-sm">Najemca:</span>${createOwnerCardHTML(local.tenant || 'Brak')}</div>
            <div><span class="text-gray-400 text-sm">Waciciel budynku:</span>${createOwnerCardHTML(plot?.owner)}</div>
            <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm pt-3 border-t border-gray-700">
                <span class="text-gray-400">Powierzchnia:</span><span class="font-medium">${local.area} m虏</span>
                <span class="text-gray-400">Pitro:</span><span class="font-medium">${local.floor}</span>
                <span class="text-gray-400">Miejsca pracy:</span><span class="font-medium">${local.workplaces}</span>
                <span class="text-gray-400">Ilo 贸偶ek:</span><span class="font-medium">${local.beds}</span>
            </div></div>`;
            }

            function renderOwnerContent(ownerName) {
                const owner = allOwners.find(o => o.name === ownerName);
                const ownedPlots = allPlots.filter(p => p.owner === ownerName);
                const rentedLocals = allLocals.filter(l => l.tenant === ownerName);
                const totalPlotArea = ownedPlots.reduce((sum, p) => sum + (parseInt(p.area) || 0), 0);
                let ownerDetailsHTML = '';
                if (owner) {
                    ownerDetailsHTML += `<div class="grid grid-cols-2 gap-x-4 gap-y-1 text-sm"><span class="text-gray-400">NIO:</span><span>${owner.nio || 'Brak'}</span>`;
                    if (owner.type === 'fizyczna') ownerDetailsHTML += `<span class="text-gray-400">Wiek:</span><span>${owner.age || 'Brak'}</span><span class="text-gray-400">Zaw贸d:</span><span>${owner.profession || 'Brak'}</span>`;
                    else if (owner.type === 'prawna') ownerDetailsHTML += `<span class="text-gray-400">Forma Prawna:</span><span>${owner.legalForm || 'Brak'}</span>`;
                    ownerDetailsHTML += '</div>';
                }
                const rentedLocalsHTML = rentedLocals.map(l => `<div class="bg-gray-700 p-2 rounded-md"><div data-local-id="${l.id}" class="cursor-pointer">
        <div class="font-semibold text-purple-400">Lokal #${l.localNum} w ${l.plotName}</div><div class="text-xs text-gray-400">Powierzchnia: ${l.area} m虏</div></div>
        <div class="mt-2 text-xs text-gray-400">Wynajmowane od:</div>${createOwnerCardHTML(allPlots.find(p => p.name === l.plotName)?.owner)}</div>`).join('');
                return `<div class="space-y-4">${createOwnerCardHTML(ownerName, true)}
        ${ownerDetailsHTML ? `<div class="pt-3 border-t border-gray-700">${ownerDetailsHTML}</div>` : ''}
        <div><h4 class="font-semibold text-md mb-2">Posiadane Dziaki (${ownedPlots.length})</h4>
            <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-sm"><span class="text-gray-400">czna pow.:</span><span>${totalPlotArea.toLocaleString()} m虏</span></div>
            ${ownedPlots.length > 0 ? `<div class="space-y-2 mt-2">${ownedPlots.map(p => createPlotListItemHTML(p)).join('')}</div>` : ''}</div>
        <div class="border-t border-gray-700 pt-3"><h4 class="font-semibold text-md mb-1">Wynajmowane Lokale (${rentedLocals.length})</h4>
            ${rentedLocals.length > 0 ? `<div class="space-y-2 mt-2">${rentedLocalsHTML}</div>` : '<p class="text-gray-500 text-sm">Brak</p>'}</div></div>`;
            }

            function renderDistrictContent(districtName, plotsInDistrict) {
                const plotTypes = {};
                const occupancy = { Zajte: 0, Wolne: 0 };
                let totalArea = 0;
                plotsInDistrict.forEach(p => {
                    const type = p.type || 'Inne';
                    plotTypes[type] = (plotTypes[type] || 0) + 1;
                    const isOwned = p.owner && p.owner.trim() !== '' && p.owner.toLowerCase().trim() !== 'skarb miasta';
                    if (isOwned) { occupancy.Zajte++; } else { occupancy.Wolne++; }
                    totalArea += parseInt(p.area) || 0;
                });
                const plotListHTML = plotsInDistrict.map(p => createPlotListItemHTML(p)).join('');
                const html = `
                    <div><h3 class="text-2xl font-bold text-purple-400">${districtName}</h3></div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm border-b border-gray-700 pb-3 mb-3">
                        <span>Liczba dziaek:</span><span class="font-medium">${plotsInDistrict.length}</span>
                        <span>czna powierzchnia:</span><span class="font-medium">${totalArea.toLocaleString()} m虏</span>
                    </div>
                    <div class="space-y-2 mb-4">${plotListHTML}</div>
                    <div>
                        <h4 class="text-md font-semibold mt-4 mb-2">Statystyki</h4>
                        <div class="chart-container"><canvas id="plot-type-chart"></canvas></div>
                        <div class="chart-container"><canvas id="occupancy-chart"></canvas></div>
                    </div>`;
                setTimeout(() => {
                    destroyActiveCharts();
                    const typeLabels = Object.keys(plotTypes);
                    const typeColors = typeLabels.map(label => getColorForType(label, 1));
                    createChart('plot-type-chart', 'pie', { labels: typeLabels, data: Object.values(plotTypes), colors: typeColors }, 'Typy dziaek');
                    const occupancyLabels = Object.keys(occupancy);
                    createChart('occupancy-chart', 'doughnut', { labels: occupancyLabels, data: Object.values(occupancy), colors: ['rgba(239, 68, 68, 0.8)', 'rgba(34, 197, 94, 0.8)'] }, 'Zajto');
                }, 100);
                return html;
            }

            function renderStreetContent(streetName) {
                const street = streets.find(s => s.name === streetName);
                if (!street) return '<p>Nie znaleziono ulicy.</p>';
                const plotsOnStreet = allPlots.filter(p => p.street === streetName);
                const length = street.width > street.height ? street.width : street.height;
                return `<div><h3 class="text-2xl font-bold text-blue-400">${streetName}</h3></div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm border-b border-gray-700 pb-3 mb-3">
                        <span>Dugo:</span><span class="font-medium">${length} m</span>
                        <span>Liczba dziaek:</span><span class="font-medium">${plotsOnStreet.length}</span></div>
                    <div class="space-y-2 mb-4">${plotsOnStreet.map(p => createPlotListItemHTML(p)).join('')}</div>`;
            }

            function renderPlotTypeContent(typeName) {
                const plotsOfType = allPlots.filter(p => p.type === typeName);
                const plotNames = new Set(plotsOfType.map(p => p.name));
                const localsOnPlots = allLocals.filter(l => plotNames.has(l.plotName));
                const totalArea = plotsOfType.reduce((s, p) => s + (parseInt(p.area) || 0), 0);
                const totalLocals = localsOnPlots.length;
                const totalWorkplaces = localsOnPlots.reduce((s, l) => s + l.workplaces, 0);
                const totalBeds = localsOnPlots.reduce((s, l) => s + l.beds, 0);
                const typeColorDot = `<span class="inline-block w-3 h-3 rounded-full mr-2" style="background-color: ${getColorForType(typeName, 1)}"></span>`;

                return `<div><h3 class="text-2xl font-bold flex items-center">${typeColorDot} ${typeName}</h3></div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm border-b border-gray-700 pb-3 mb-3">
                        <span>Liczba dziaek:</span><span class="font-medium">${plotsOfType.length}</span>
                        <span>czna powierzchnia:</span><span class="font-medium">${totalArea.toLocaleString()} m虏</span>
                        <span>Liczba lokali:</span><span class="font-medium">${totalLocals}</span>
                        <span>Miejsca pracy:</span><span class="font-medium">${totalWorkplaces}</span>
                        <span>Ilo 贸偶ek:</span><span class="font-medium">${totalBeds}</span>
                    </div>
                    <div class="space-y-2 mb-4">${plotsOfType.map(p => createPlotListItemHTML(p)).join('')}</div>`;
            }

            function createChart(canvasId, type, chartData, label) {
                const ctx = document.getElementById(canvasId);
                if (!ctx) return;
                if (chartData.data.length === 0) {
                    ctx.parentElement.innerHTML = `<div class="flex items-center justify-center h-full text-gray-500">Brak danych</div>`;
                    return;
                }
                const chart = new Chart(ctx, {
                    type: type,
                    data: {
                        labels: chartData.labels,
                        datasets: [{
                            label: label,
                            data: chartData.data,
                            backgroundColor: chartData.colors || chartData.labels.map((_, i) => `hsl(${(i * 137.5) % 360}, 50%, 60%)`),
                            borderColor: '#1f2937',
                            borderWidth: 1
                        }]
                    },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: type === 'bar' ? 'top' : 'right', labels: { color: '#d1d5db' } } } }
                });
                activeCharts.push(chart);
            }

            function destroyActiveCharts() {
                activeCharts.forEach(chart => chart.destroy());
                activeCharts = [];
            }

            function hideTooltip() { tooltip.classList.add('hidden'); }
            function moveTooltip(e) {
                const PADDING = 20; let x = e.clientX + PADDING; let y = e.clientY + PADDING;
                if (x + tooltip.offsetWidth > window.innerWidth) x = e.clientX - tooltip.offsetWidth - PADDING;
                if (y + tooltip.offsetHeight > window.innerHeight) y = e.clientY - tooltip.offsetHeight - PADDING;
                tooltip.style.left = `${x}px`; tooltip.style.top = `${y}px`;
            }

            function findAndCenter(item) {
                clearHighlight();
                let targetPlots = [];
                if (item.type === 'plot') {
                    const plot = allPlots.find(p => p.name === item.value);
                    if (plot) { targetPlots.push(plot); openNewModal({ type: 'plot', data: plot }); }
                } else if (item.type === 'owner') {
                    targetPlots = allPlots.filter(p => p.owner === item.value);
                    openNewModal({ type: 'owner', data: item.value });
                } else if (item.type === 'street') {
                    targetPlots = allPlots.filter(p => p.street === item.value);
                    openNewModal({ type: 'street', data: item.value });
                } else if (item.type === 'address' || item.type === 'local_address') {
                    const [addressPart, localNum] = item.value.split('/');
                    const [street, number] = addressPart.split(' ');
                    const plot = allPlots.find(p => p.street === street && p.buildingNumber === number);
                    if (plot) {
                        targetPlots.push(plot);
                        if (item.type === 'local_address') {
                            const local = allLocals.find(l => l.plotName === plot.name && l.localNum === localNum);
                            if (local) {
                                openNewModal({ type: 'plot', data: plot });
                                navigateToModal({ type: 'local', data: local });
                            }
                        } else {
                            openNewModal({ type: 'plot', data: plot });
                        }
                    }
                }

                if (targetPlots.length > 0) {
                    const minX = Math.min(...targetPlots.map(p => p.x1)), maxX = Math.max(...targetPlots.map(p => p.x2));
                    const minZ = Math.min(...targetPlots.map(p => p.z1)), maxZ = Math.max(...targetPlots.map(p => p.z2));
                    const centerX = minX + (maxX - minX) / 2, centerZ = minZ + (maxZ - minZ) / 2;
                    const contentWidth = Math.max(300, (maxX - minX) * 1.5), newH = (contentWidth / initialViewBox.w) * initialViewBox.h;
                    setViewBox(centerX - contentWidth / 2, centerZ - newH / 2, contentWidth, newH);
                    targetPlots.forEach(plot => highlightPlot(plot.id));
                }
                searchInput.value = '';
                searchSuggestions.classList.add('hidden');
            }

            function highlightPlot(plotId) {
                const plotElement = svg.querySelector(`g[data-plot-id='${plotId}'] .plot-rect`);
                if (plotElement) plotElement.classList.add('highlighted');
            }

            function toggleLayer(layerName) {
                layerVisibility[layerName] = !layerVisibility[layerName];
                document.getElementById(`${layerName}-layer`).classList.toggle('hidden-layer', !layerVisibility[layerName]);
                document.getElementById(`toggle-${layerName}`).classList.toggle('active', layerVisibility[layerName]);
            }

            function addModalEventListeners() {
                modalContent.querySelectorAll('[data-plot-name]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    const plot = allPlots.find(p => p.name === e.currentTarget.dataset.plotName);
                    if (plot) navigateToModal({ type: 'plot', data: plot });
                }));
                modalContent.querySelectorAll('[data-local-id]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    const local = allLocals.find(l => l.id === e.currentTarget.dataset.localId);
                    if (local) navigateToModal({ type: 'local', data: local });
                }));
                modalContent.querySelectorAll('[data-owner-name]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    const ownerName = e.currentTarget.dataset.ownerName;
                    if (ownerName && ownerName.toLowerCase() !== 'skarb miasta' && ownerName.toLowerCase() !== 'brak') {
                        navigateToModal({ type: 'owner', data: ownerName });
                    }
                }));
                modalContent.querySelectorAll('[data-district-name]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    const districtName = e.currentTarget.dataset.districtName;
                    if (!districtName) return;
                    const plotsInDistrict = allPlots.filter(p => p.district === districtName);
                    if (plotsInDistrict.length > 0) navigateToModal({ type: 'district', data: { name: districtName, plots: plotsInDistrict } });
                }));
                modalContent.querySelectorAll('[data-street-name]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    navigateToModal({ type: 'street', data: e.currentTarget.dataset.streetName });
                }));
                modalContent.querySelectorAll('[data-plot-type]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    navigateToModal({ type: 'plotType', data: e.currentTarget.dataset.plotType });
                }));
            }

            searchInput.addEventListener('input', () => {
                const query = searchInput.value.trim().toLowerCase();
                searchSuggestions.innerHTML = '';
                if (!query) { searchSuggestions.classList.add('hidden'); return; }
                const suggestions = [];
                // Dziaki
                allPlots.filter(p => p.name.toLowerCase().includes(query) || p.id.includes(query)).slice(0, 3)
                    .forEach(p => suggestions.push({ type: 'plot', label: `Dziaka: ${p.name}`, value: p.name }));
                // Waciciele
                [...new Set(allPlots.map(p => p.owner))].filter(o => o && o.toLowerCase().includes(query)).slice(0, 2)
                    .forEach(o => suggestions.push({ type: 'owner', label: `Waciciel: ${o}`, value: o }));
                // Adresy Lokali
                allLocals.filter(l => l.street && l.building && l.localNum && `${l.street.toLowerCase()} ${l.building}/${l.localNum}`.includes(query)).slice(0, 3)
                    .forEach(l => suggestions.push({ type: 'local_address', label: `Lokal: ${l.street} ${l.building}/${l.localNum}`, value: `${l.street} ${l.building}/${l.localNum}` }));
                // Adresy
                allPlots.filter(p => p.street && p.buildingNumber && `${p.street.toLowerCase()} ${p.buildingNumber}`.includes(query)).slice(0, 3)
                    .forEach(p => suggestions.push({ type: 'address', label: `Adres: ${p.street} ${p.buildingNumber}`, value: `${p.street} ${p.buildingNumber}` }));

                if (suggestions.length > 0) {
                    suggestions.forEach(s => {
                        const div = document.createElement('div');
                        div.className = 'p-2 hover:bg-purple-600 cursor-pointer';
                        div.textContent = s.label;
                        div.addEventListener('click', () => findAndCenter(s));
                        searchSuggestions.appendChild(div);
                    });
                    searchSuggestions.classList.remove('hidden');
                } else {
                    searchSuggestions.classList.add('hidden');
                }
            });

            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target)) {
                    searchSuggestions.classList.add('hidden');
                }
            });

            searchButton.addEventListener('click', () => {
                const firstSuggestion = searchSuggestions.querySelector('div');
                if (firstSuggestion) firstSuggestion.click();
            });
            searchInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    const firstSuggestion = searchSuggestions.querySelector('div');
                    if (firstSuggestion) firstSuggestion.click();
                }
            });

            // Pozostae listenery
            mapContainer.addEventListener('mousedown', (e) => { if (e.button === 0) { isPanning = true; mapContainer.classList.add('grabbing'); startPoint = { x: e.x, y: e.y }; } });
            document.addEventListener('mouseup', () => { isPanning = false; mapContainer.classList.remove('grabbing'); });
            mapContainer.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const dx = (startPoint.x - e.x) * (viewBox.w / mapContainer.clientWidth);
                const dy = (startPoint.y - e.y) * (viewBox.h / mapContainer.clientHeight);
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                startPoint = { x: e.x, y: e.y };
            });
            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const w = viewBox.w; const h = viewBox.h; const mx = e.offsetX; const my = e.offsetY;
                const dw = w * -Math.sign(e.deltaY) * 0.1; const dh = h * -Math.sign(e.deltaY) * 0.1;
                const dx = dw * mx / mapContainer.clientWidth; const dy = dh * my / mapContainer.clientHeight;
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w - dw, viewBox.h - dh);
            }, { passive: false });

            closeModalBtn.addEventListener('click', closeModal);
            document.getElementById('back-modal').addEventListener('click', goBackModal);
            mapContainer.addEventListener('click', (e) => { if (e.target === mapContainer || e.target === svg || e.target.id === 'map-svg') closeModal(); });
            document.getElementById('zoom-in').addEventListener('click', () => { const dw = viewBox.w * -0.2; setViewBox(viewBox.x - dw / 2, viewBox.y - (dw / initialViewBox.w * initialViewBox.h) / 2, viewBox.w + dw, viewBox.h + (dw / initialViewBox.w * initialViewBox.h)); });
            document.getElementById('zoom-out').addEventListener('click', () => { const dw = viewBox.w * 0.2; setViewBox(viewBox.x - dw / 2, viewBox.y - (dw / initialViewBox.w * initialViewBox.h) / 2, viewBox.w + dw, viewBox.h + (dw / initialViewBox.w * initialViewBox.h)); });
            document.getElementById('reset-view').addEventListener('click', () => { setViewBox(initialViewBox.x, initialViewBox.y, initialViewBox.w, initialViewBox.h); });
            document.getElementById('toggle-plots').addEventListener('click', () => toggleLayer('plots'));
            document.getElementById('toggle-streets').addEventListener('click', () => toggleLayer('streets'));
            document.getElementById('toggle-districts').addEventListener('click', () => toggleLayer('districts'));
            document.getElementById('toggle-merged').addEventListener('click', () => toggleLayer('merged'));

            fetchAllData();
        });
    </script>
</body>

</html>