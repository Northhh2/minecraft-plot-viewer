<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>System Dzia≈Çek Minecraft</title>
    <link rel="icon" type="image/x-icon" href="Red.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        #map-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        #map-svg {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111827;
        }
        .plot-rect {
            stroke-width: 0.5;
            transition: fill 0.2s ease-in-out, fill-opacity 0.3s ease-in-out, filter 0.3s ease-in-out, stroke 0.3s, stroke-width 0.3s;
        }
        .plot-rect:hover {
            fill-opacity: 0.7;
        }
        .plot-rect.dimmed {
            fill-opacity: 0.2 !important;
            filter: grayscale(80%);
        }
        .plot-rect.highlighted {
            fill-opacity: 1 !important;
            filter: brightness(1.2);
            stroke: #facc15; /* yellow-400 */
            stroke-width: 1.5;
        }
        .street-rect {
            fill: #4b5563; /* gray-600 */
            fill-opacity: 0.9;
            stroke: transparent; /* No stroke by default */
            stroke-width: 0.25;
            transition: fill-opacity 0.2s, stroke 0.2s;
        }
        .street-rect:hover {
            fill-opacity: 0.7;
            stroke: #9ca3af; /* Add stroke on hover */
        }
        .merged-plot {
            stroke: #f59e0b;
            stroke-width: 1.5;
            stroke-dasharray: 4,2;
            fill: none;
            pointer-events: all;
            cursor: pointer;
        }
        .plot-text {
            font-size: 4px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 0.5px;
            stroke-linecap: butt;
            stroke-linejoin: miter;
        }
        .street-text {
            font-size: 3px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        .street-text.street-vertical {
            writing-mode: vertical-rl; /* Vertical text for vertical streets */
        }
        #tooltip {
            background-color: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid #4b5563;
            transition: opacity 0.2s ease-in-out;
        }
        #modal {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }
        #modal.show {
            transform: translateX(0);
        }
        .grab { cursor: grab; }
        .grabbing { cursor: grabbing; }

        .toggle-button {
            opacity: 0.5;
            border: 1px solid #4b5563;
        }
        .toggle-button.active {
            opacity: 1;
            background-color: #4338ca; /* indigo-700 */
            border-color: #6d28d9; /* purple-700 */
        }
        .hidden-layer {
            display: none;
        }
        .chart-container {
            height: 200px;
            width: 100%;
        }
        
        @media (max-width: 768px) {
            #tooltip { font-size: 12px; max-width: 90vw; max-height: 50vh; overflow-y: auto; }
            .plot-text { font-size: 3px; }
            .controls { bottom: 10px !important; right: 10px !important; }
            .control-button { width: 44px; height: 44px; }
            #modal { width: 100vw; }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Search Bar -->
    <div class="absolute top-5 left-5 z-30">
        <div class="flex bg-gray-800 rounded-lg border border-gray-600 shadow-lg">
            <input type="text" id="search-input" placeholder="Wyszukaj (np. D4/021 lub 21)" class="bg-transparent text-white px-4 py-2 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-purple-500 w-48 md:w-auto" maxlength="15">
            <button id="search-button" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-r-lg transition-colors">üîç</button>
        </div>
    </div>

    <!-- Main container for the map -->
    <div id="map-container" class="grab">
        <svg id="map-svg"></svg>
    </div>

    <!-- Simple Tooltip -->
    <div id="tooltip" class="hidden absolute p-2 rounded-lg shadow-xl text-sm z-40 pointer-events-none"></div>

    <!-- Right Side Modal -->
    <div id="modal" class="fixed top-0 right-0 w-full md:w-96 h-full bg-gray-800 border-l border-gray-600 shadow-2xl z-50 overflow-y-auto">
        <div class="p-6">
            <div class="flex justify-between items-center mb-4"><h2 id="modal-title" class="text-xl font-bold">Szczeg√≥≈Çy</h2><button id="close-modal" class="text-gray-400 hover:text-white text-2xl">&times;</button></div>
            <div id="modal-content" class="space-y-4"></div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loader" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50">
        <div class="text-center">
            <svg class="animate-spin h-8 w-8 text-white mx-auto mb-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p class="text-lg font-medium">Pobieranie danych...</p><p class="text-sm text-gray-400">Proszƒô czekaƒá</p>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls absolute flex flex-col items-end z-30" style="bottom: 20px; right: 20px;">
        <div class="flex flex-col space-y-2">
            <button id="zoom-in" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600" title="Powiƒôksz"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
            <button id="zoom-out" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600" title="Pomniejsz"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
            <button id="reset-view" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600" title="Resetuj widok"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"></path><path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path><path d="M21 22v-6h-6"></path><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path></svg></button>
        </div>
        <div id="layer-toggles" class="mt-2 flex flex-col space-y-2">
             <button id="toggle-plots" class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700" title="Poka≈º/Ukryj Dzia≈Çki"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg></button>
             <button id="toggle-streets" class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700" title="Poka≈º/Ukryj Ulice"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="20" x2="4" y2="4"></line><line x1="20" y1="20" x2="20" y2="4"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg></button>
             <button id="toggle-districts" class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700" title="Poka≈º/Ukryj Dzielnice"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg></button>
             <button id="toggle-merged" class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700" title="Poka≈º/Ukryj Po≈ÇƒÖczone Dzia≈Çki"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const SHEET_ID = '1swtElpz27sqLMNbATocFe9VHc1yZTSRxvHyikFL_R7U';
            const PLOTS_GID = '0';
            const MERGED_GID = '43897086';
            const STREETS_GID = '2101138806';

            const PLOTS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${PLOTS_GID}`;
            const MERGED_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${MERGED_GID}`;
            const STREETS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${STREETS_GID}`;

            const MAP_IMAGE_URL = 'map.png';
            const MAP_WIDTH = 4296;
            const MAP_HEIGHT = 2360;

            const svg = document.getElementById('map-svg');
            const tooltip = document.getElementById('tooltip');
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContent = document.getElementById('modal-content');
            const loader = document.getElementById('loader');
            const mapContainer = document.getElementById('map-container');
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const closeModalBtn = document.getElementById('close-modal');

            let viewBox = { x: 0, y: 0, w: 0, h: 0 };
            let mapBounds = { minX: -MAP_WIDTH / 2, maxX: MAP_WIDTH / 2, minY: -MAP_HEIGHT / 2, maxY: MAP_HEIGHT / 2 };
            let isPanning = false;
            let startPoint = { x: 0, y: 0 };
            let lastTouchDistance = 0;
            const initialViewBox = {};
            let layerVisibility = { plots: true, streets: true, districts: true, merged: true };
            let touchStartInfo = { time: 0, x: 0, y: 0 };
            let activeCharts = [];
            
            let allPlots = [];
            let mergedPlots = [];
            let streets = [];
            
            const layers = {
                streets: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                plots: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                merged: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                districts: document.createElementNS('http://www.w3.org/2000/svg', 'g')
            };

            function setViewBox(x, y, w, h) {
                const isMobile = window.innerWidth <= 768;
                const minZoom = isMobile ? 50 : 100;
                const maxZoom = Math.max(MAP_WIDTH, MAP_HEIGHT) * 2;
                
                w = Math.max(minZoom, Math.min(w, maxZoom));
                if (initialViewBox.w) {
                    h = (w / initialViewBox.w) * initialViewBox.h;
                }
                
                if (x < mapBounds.minX) x = mapBounds.minX;
                if (y < mapBounds.minY) y = mapBounds.minY;
                if (x + w > mapBounds.maxX) x = mapBounds.maxX - w;
                if (y + h > mapBounds.maxY) y = mapBounds.maxY - h;
                
                viewBox = { x, y, w, h };
                svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
            }

            function getColorForType(type) {
                const alpha = 0.8;
                switch (type) {
                    case 'Parkowa':               return `rgba(34, 197, 94, ${alpha})`;
                    case 'Rolna':                 return `rgba(130, 90, 40, ${alpha})`;
                    case 'Hotelowa':              return `rgba(6, 182, 212, ${alpha})`;
                    case 'Mieszkalna':            return `rgba(202, 138, 4, ${alpha})`;
                    case 'Sakralna':              return `rgba(168, 85, 247, ${alpha})`;
                    case 'Przemys≈Çowo-biurowa':   return `rgba(236, 72, 153, ${alpha})`;
                    case 'Mieszkalno-us≈Çugowa':   return `rgba(59, 130, 246, ${alpha})`;
                    case 'Publiczna':             return `rgba(249, 115, 22, ${alpha})`;
                    case 'Medyczna':              return `rgba(251, 44, 54, ${alpha})`;
                    default:                      return `rgba(255, 255, 255, 0.1)`;
                }
            }

            async function fetchAllData() {
                try {
                    const [plotsResponse, mergedResponse, streetsResponse] = await Promise.all([
                        fetch(PLOTS_URL), fetch(MERGED_URL), fetch(STREETS_URL)
                    ]);

                    if (!plotsResponse.ok || !mergedResponse.ok || !streetsResponse.ok) throw new Error('Network response was not ok');

                    const [plotsText, mergedText, streetsText] = await Promise.all([
                        plotsResponse.text(), mergedResponse.text(), streetsResponse.text()
                    ]);
                    
                    const plotsPromise = new Promise(resolve => Papa.parse(plotsText, { header: true, skipEmptyLines: true, complete: resolve }));
                    const mergedPromise = new Promise(resolve => Papa.parse(mergedText, { header: true, skipEmptyLines: true, complete: resolve }));
                    const streetsPromise = new Promise(resolve => Papa.parse(streetsText, { header: true, skipEmptyLines: true, complete: resolve }));

                    const [plotsResult, mergedResult, streetsResult] = await Promise.all([plotsPromise, mergedPromise, streetsPromise]);

                    allPlots = plotsResult.data.filter(p => p['Nr porzƒÖdkowy'] && p['X (lewy g√≥rny)'] && p['Z (lewy g√≥rny)'] && p['Bok X'] && p['Bok Z'])
                        .map(d => ({
                            id: d['Nr porzƒÖdkowy'], name: d['Nazwa porzƒÖdkowa dzia≈Çki'], type: d['Typ'],
                            x1: parseInt(d['X (lewy g√≥rny)'], 10), z1: parseInt(d['Z (lewy g√≥rny)'], 10),
                            x2: parseInt(d['X (prawy dolny)'], 10), z2: parseInt(d['Z (prawy dolny)'], 10),
                            width: parseInt(d['Bok X'], 10), height: parseInt(d['Bok Z'], 10), area: d['Powierzchnia'],
                            value: d['Warto≈õƒá'], prevOwner: d['Poprzedni w≈Ça≈õciciel'], owner: d['Aktualny w≈Ça≈õciciel'],
                            sector: d['Sektor'], district: d['Dzielnica'], street: d['Ulica'],
                            buildingNumber: d['Numer budynku'], apartmentCount: d['Ilo≈õƒá lokali']
                        }));
                    
                    const connections = mergedResult.data.filter(m => m['Dzia≈Çka g≈Ç√≥wna'] && m['Dzia≈Çka do≈ÇƒÖczana'])
                        .map(d => ({ plot1: d['Dzia≈Çka g≈Ç√≥wna'], plot2: d['Dzia≈Çka do≈ÇƒÖczana'] }));
                    mergedPlots = processMergedPlots(connections);

                    streets = streetsResult.data.filter(s => s['Numer porzƒÖdkowy'] && s['X (lewy g√≥rny)'] && s['Z (lewy g√≥rny)'] && s['X (prawy dolny)'] && s['Z (prawy dolny)'])
                        .map(d => ({
                            id: d['Numer porzƒÖdkowy'], name: d['Nazwa ulicy'],
                            x1: parseInt(d['X (lewy g√≥rny)'], 10), z1: parseInt(d['Z (lewy g√≥rny)'], 10),
                            x2: parseInt(d['X (prawy dolny)'], 10), z2: parseInt(d['Z (prawy dolny)'], 10),
                            width: parseInt(d['X (prawy dolny)'], 10) - parseInt(d['X (lewy g√≥rny)'], 10),
                            height: parseInt(d['Z (prawy dolny)'], 10) - parseInt(d['Z (lewy g√≥rny)'], 10)
                        }));

                    drawMap();
                    loader.style.display = 'none';

                } catch (error) {
                    console.error("B≈ÇƒÖd podczas pobierania danych:", error);
                    loader.innerHTML = `<div class="text-center"><p class="text-lg font-medium text-red-500">B≈ÇƒÖd ≈Çadowania danych</p><p class="text-sm text-gray-400">Sprawd≈∫ konsolƒô.</p></div>`;
                }
            }
            
            function processMergedPlots(connections) {
                const adj = new Map();
                const allPlotIdsInConnections = new Set();

                connections.forEach(({ plot1, plot2 }) => {
                    if (!adj.has(plot1)) adj.set(plot1, []);
                    if (!adj.has(plot2)) adj.set(plot2, []);
                    adj.get(plot1).push(plot2);
                    adj.get(plot2).push(plot1);
                    allPlotIdsInConnections.add(plot1);
                    allPlotIdsInConnections.add(plot2);
                });

                const visited = new Set();
                const groups = [];

                for (const plotId of allPlotIdsInConnections) {
                    if (!visited.has(plotId)) {
                        const group = [];
                        const stack = [plotId];
                        visited.add(plotId);
                        while (stack.length > 0) {
                            const currentId = stack.pop();
                            group.push(currentId);
                            const neighbors = adj.get(currentId) || [];
                            for (const neighbor of neighbors) {
                                if (!visited.has(neighbor)) {
                                    visited.add(neighbor);
                                    stack.push(neighbor);
                                }
                            }
                        }
                        groups.push(group);
                    }
                }
                
                return groups.map(group => {
                    const plotsInGroup = group.map(id => allPlots.find(p => p.name === id)).filter(Boolean);
                    if (plotsInGroup.length === 0) return null;

                    const minX = Math.min(...plotsInGroup.map(p => p.x1));
                    const maxX = Math.max(...plotsInGroup.map(p => p.x2));
                    const minZ = Math.min(...plotsInGroup.map(p => p.z1));
                    const maxZ = Math.max(...plotsInGroup.map(p => p.z2));
                    const originalArea = plotsInGroup.reduce((sum, p) => sum + (parseInt(p.area) || 0), 0);
                    const mergedArea = (maxX - minX) * (maxZ - minZ);

                    return {
                        plots: group, x1: minX, z1: minZ, x2: maxX, z2: maxZ,
                        width: maxX - minX, height: maxZ - minZ, originalArea, mergedArea
                    };
                }).filter(Boolean);
            }

            function drawMap() {
                if (!allPlots.length) return;
                svg.innerHTML = ''; 

                const mapImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                mapImage.setAttribute('href', MAP_IMAGE_URL);
                mapImage.setAttribute('x', -MAP_WIDTH / 2);
                mapImage.setAttribute('y', -MAP_HEIGHT / 2);
                mapImage.setAttribute('width', MAP_WIDTH);
                mapImage.setAttribute('height', MAP_HEIGHT);
                svg.appendChild(mapImage);

                Object.values(layers).forEach(layer => layer.innerHTML = '');
                
                layers.streets.id = 'streets-layer';
                layers.plots.id = 'plots-layer';
                layers.merged.id = 'merged-layer';
                layers.districts.id = 'districts-layer';

                // Correct drawing order (bottom to top)
                svg.appendChild(layers.streets);
                svg.appendChild(layers.plots);
                svg.appendChild(layers.merged);
                svg.appendChild(layers.districts);

                drawStreets();
                drawPlots();
                drawMergedPlots();
                drawDistrictBoundaries();

                const padding = 100;
                const minX = Math.min(...allPlots.map(p => p.x1));
                const maxX = Math.max(...allPlots.map(p => p.x2));
                const minZ = Math.min(...allPlots.map(p => p.z1));
                const maxZ = Math.max(...allPlots.map(p => p.z2));
                
                viewBox.w = (maxX - minX) + (padding * 2);
                viewBox.h = (maxZ - minZ) + (padding * 2);
                viewBox.x = minX - padding;
                viewBox.y = minZ - padding;
                
                Object.assign(initialViewBox, viewBox);
                setViewBox(viewBox.x, viewBox.y, viewBox.w, viewBox.h);
            }

            function drawStreets() {
                streets.forEach(street => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', street.x1); rect.setAttribute('y', street.z1);
                    rect.setAttribute('width', street.width); rect.setAttribute('height', street.height);
                    rect.setAttribute('class', 'street-rect');

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', street.x1 + street.width / 2);
                    text.setAttribute('y', street.z1 + street.height / 2);
                    text.setAttribute('class', 'street-text');
                    if(street.height > street.width) {
                        text.classList.add('street-vertical');
                    }
                    text.textContent = street.name;
                    g.appendChild(rect); g.appendChild(text);

                    g.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold">${street.name}</div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    g.addEventListener('mouseleave', hideTooltip);
                    g.addEventListener('mousemove', moveTooltip);
                    layers.streets.appendChild(g);
                });
            }

            function drawMergedPlots() {
                mergedPlots.forEach((merged) => {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', merged.x1); rect.setAttribute('y', merged.z1);
                    rect.setAttribute('width', merged.width); rect.setAttribute('height', merged.height);
                    rect.setAttribute('class', 'merged-plot');

                    rect.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold mb-1">Po≈ÇƒÖczone dzia≈Çki</div><div class="text-xs">Kliknij, by zobaczyƒá szczeg√≥≈Çy</div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    rect.addEventListener('mouseleave', hideTooltip);
                    rect.addEventListener('mousemove', moveTooltip);
                    
                    rect.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showMergedModal(merged);
                    });
                    
                    let mergedTouchStartInfo = {};
                    rect.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 1) {
                            mergedTouchStartInfo = { time: Date.now(), x: e.touches[0].clientX, y: e.touches[0].clientY };
                        }
                    }, { passive: true });

                    rect.addEventListener('touchend', (e) => {
                        if (mergedTouchStartInfo.time) {
                            const timeDiff = Date.now() - mergedTouchStartInfo.time;
                            const dist = Math.hypot(e.changedTouches[0].clientX - mergedTouchStartInfo.x, e.changedTouches[0].clientY - mergedTouchStartInfo.y);
                            if (timeDiff < 250 && dist < 10) {
                                e.preventDefault();
                                showMergedModal(merged);
                            }
                            mergedTouchStartInfo = {};
                        }
                    });

                    layers.merged.appendChild(rect);
                });
            }

            function drawPlots() {
                allPlots.forEach(plot => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.dataset.plotId = plot.id;
                    g.dataset.plotName = plot.name;
                    g.dataset.plotDistrict = plot.district || '';
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', plot.x1); rect.setAttribute('y', plot.z1);
                    rect.setAttribute('width', plot.width); rect.setAttribute('height', plot.height);
                    rect.setAttribute('class', 'plot-rect');
                    rect.style.fill = getColorForType(plot.type);
                    const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                    rect.style.stroke = isOwned ? '#ef4444' : '#22c55e';

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', plot.x1 + plot.width / 2);
                    text.setAttribute('y', plot.z1 + plot.height / 2);
                    text.setAttribute('class', 'plot-text');
                    text.textContent = plot.id.padStart(3, '0');
                    
                    g.appendChild(rect); g.appendChild(text);

                    g.addEventListener('mouseenter', (e) => {
                        showSimpleTooltip(e, plot);
                        if (plot.district) highlightDistrict(plot.district);
                    });
                    g.addEventListener('mouseleave', () => { hideTooltip(); clearHighlight(); });
                    g.addEventListener('mousemove', moveTooltip);
                    g.addEventListener('click', (e) => { e.stopPropagation(); showModal(plot); });

                    g.addEventListener('touchend', (e) => {
                        if (touchStartInfo.time) {
                            const timeDiff = Date.now() - touchStartInfo.time;
                            const dist = Math.hypot(e.changedTouches[0].clientX - touchStartInfo.x, e.changedTouches[0].clientY - touchStartInfo.y);
                            if (timeDiff < 250 && dist < 10) {
                                e.preventDefault();
                                showModal(plot);
                            }
                        }
                    });

                    layers.plots.appendChild(g);
                });
            }

            function drawDistrictBoundaries() {
                const districts = {};
                allPlots.forEach(plot => {
                    if (plot.district && plot.district.trim() !== '') {
                        const districtName = plot.district.trim();
                        if (!districts[districtName]) districts[districtName] = [];
                        districts[districtName].push(plot);
                    }
                });

                Object.entries(districts).forEach(([districtName, districtPlots]) => {
                    if (districtPlots.length === 0) return;
                    const clusters = createDistrictClusters(districtPlots, 30);
                    clusters.forEach((cluster) => {
                        const boundary = createComplexBoundary(cluster);
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', boundary);
                        path.style.cssText = "fill:none; stroke:#8b5cf6; stroke-width:2; stroke-dasharray:8,4; opacity:0.7; cursor:pointer; pointer-events:all;";
                        path.dataset.districtName = districtName;
                        
                        path.addEventListener('mouseenter', () => highlightDistrict(districtName));
                        path.addEventListener('mouseleave', () => clearHighlight());
                        
                        path.addEventListener('click', (e) => {
                            e.stopPropagation();
                            showDistrictModal(districtName, cluster);
                        });
                        
                        let districtTouchStartInfo = {};
                        path.addEventListener('touchstart', (e) => {
                            if (e.touches.length === 1) {
                                districtTouchStartInfo = { time: Date.now(), x: e.touches[0].clientX, y: e.touches[0].clientY };
                            }
                        }, { passive: true });

                        path.addEventListener('touchend', (e) => {
                            if (districtTouchStartInfo.time) {
                                const timeDiff = Date.now() - districtTouchStartInfo.time;
                                const dist = Math.hypot(e.changedTouches[0].clientX - districtTouchStartInfo.x, e.changedTouches[0].clientY - districtTouchStartInfo.y);
                                if (timeDiff < 250 && dist < 10) {
                                    e.preventDefault();
                                    showDistrictModal(districtName, cluster);
                                }
                                districtTouchStartInfo = {};
                            }
                        });

                        layers.districts.appendChild(path);

                        const minX = Math.min(...cluster.map(p => p.x1));
                        const maxX = Math.max(...cluster.map(p => p.x2));
                        const minZ = Math.min(...cluster.map(p => p.z1));
                        
                        const districtLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        districtLabel.setAttribute('x', minX + (maxX - minX) / 2);
                        districtLabel.setAttribute('y', minZ - 8);
                        districtLabel.style.cssText = "fill:#a78bfa; font-size:7px; font-weight:bold; text-anchor:middle; pointer-events:none;";
                        districtLabel.textContent = districtName;
                        layers.districts.appendChild(districtLabel);
                    });
                });
            }

            function createDistrictClusters(plots, maxDistance) {
                // This function implementation seems fine and can be kept as is.
                const clusters = [];
                let visited = new Set();
                plots.forEach(plot => {
                    if (!visited.has(plot.id)) {
                        const newCluster = [];
                        const queue = [plot];
                        visited.add(plot.id);
                        while (queue.length > 0) {
                            const currentPlot = queue.shift();
                            newCluster.push(currentPlot);
                            plots.forEach(otherPlot => {
                                if (!visited.has(otherPlot.id)) {
                                     // Simple bounding box check for adjacency
                                    const isAdjacent = (
                                        currentPlot.x1 <= otherPlot.x2 + maxDistance &&
                                        currentPlot.x2 >= otherPlot.x1 - maxDistance &&
                                        currentPlot.z1 <= otherPlot.z2 + maxDistance &&
                                        currentPlot.z2 >= otherPlot.z1 - maxDistance
                                    );
                                    if(isAdjacent) {
                                        visited.add(otherPlot.id);
                                        queue.push(otherPlot);
                                    }
                                }
                            });
                        }
                        clusters.push(newCluster);
                    }
                });
                return clusters;
            }

            function createComplexBoundary(plots) {
                // Simplified boundary creation using convex hull, but with better padding
                if (plots.length === 0) return '';
                const PADDING = 2;

                const allPoints = [];
                plots.forEach(plot => {
                    allPoints.push({ x: plot.x1, y: plot.z1 }, { x: plot.x2, y: plot.z1 }, { x: plot.x2, y: plot.z2 }, { x: plot.x1, y: plot.z2 });
                });

                const hull = convexHull(allPoints);

                if (hull.length < 3) { // Fallback for single plots or lines
                    const minX = Math.min(...plots.map(p => p.x1)) - PADDING;
                    const maxX = Math.max(...plots.map(p => p.x2)) + PADDING;
                    const minZ = Math.min(...plots.map(p => p.z1)) - PADDING;
                    const maxZ = Math.max(...plots.map(p => p.z2)) + PADDING;
                    return `M ${minX} ${minZ} L ${maxX} ${minZ} L ${maxX} ${maxZ} L ${minX} ${maxZ} Z`;
                }

                // Centroid calculation for proper padding
                const centroid = hull.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                centroid.x /= hull.length;
                centroid.y /= hull.length;

                const paddedHull = hull.map(p => {
                    const vecX = p.x - centroid.x;
                    const vecY = p.y - centroid.y;
                    const len = Math.hypot(vecX, vecY);
                    if (len === 0) return p;
                    return {
                        x: p.x + (vecX / len) * PADDING,
                        y: p.y + (vecY / len) * PADDING
                    };
                });

                return paddedHull.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ') + ' Z';
            }

            function convexHull(points) {
                points.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
                const crossProduct = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
                const lower = [];
                for (const p of points) {
                    while (lower.length >= 2 && crossProduct(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();
                    lower.push(p);
                }
                const upper = [];
                for (let i = points.length - 1; i >= 0; i--) {
                    const p = points[i];
                    while (upper.length >= 2 && crossProduct(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();
                    upper.push(p);
                }
                return lower.slice(0, -1).concat(upper.slice(0, -1));
            }

            function highlightDistrict(districtName) {
                svg.querySelectorAll('.plot-rect').forEach(rect => {
                    const parent = rect.parentElement;
                    if (parent.dataset.plotDistrict !== districtName) {
                        rect.classList.add('dimmed');
                    }
                });
            }

            function clearHighlight() {
                svg.querySelectorAll('.plot-rect.dimmed').forEach(rect => rect.classList.remove('dimmed'));
                svg.querySelectorAll('.plot-rect.highlighted').forEach(rect => rect.classList.remove('highlighted'));
            }

            function showSimpleTooltip(e, plot) {
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                tooltip.innerHTML = `<div class="font-bold">${plot.name || `Dzia≈Çka ${plot.id}`}</div><div class="text-xs ${isOwned ? 'text-red-400' : 'text-green-400'}">${isOwned ? 'Zajƒôta' : 'Wolna'}</div>`;
                tooltip.classList.remove('hidden');
                moveTooltip(e);
            }

            function showModal(plot) {
                destroyActiveCharts();
                modalTitle.textContent = 'Szczeg√≥≈Çy dzia≈Çki';
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                const ownerInfo = isOwned ? plot.owner : 'Skarb Miasta';
                modalContent.innerHTML = `
                    <div><h3 class="text-2xl font-bold ${isOwned ? 'text-red-400' : 'text-green-400'}">${plot.name || `Dzia≈Çka ${plot.id}`}</h3><p class="text-gray-400">${plot.district || 'Brak dzielnicy'}</p></div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                        <span class="text-gray-400">W≈Ça≈õciciel:</span><span class="font-medium">${ownerInfo}</span>
                        <span class="text-gray-400">Typ:</span><span class="font-medium">${plot.type || 'Brak'}</span>
                        <span class="text-gray-400">Sektor:</span><span class="font-medium">${plot.sector || 'Brak'}</span>
                        <span class="text-gray-400">Adres:</span><span class="font-medium">${plot.street || 'Brak'}, ${plot.buildingNumber || 'Brak'}</span>
                        <span class="text-gray-400">Powierzchnia:</span><span class="font-medium">${plot.area || 'Brak'} m¬≤</span>
                        <span class="text-gray-400">Wymiary:</span><span class="font-medium">${plot.width}x${plot.height}</span>
                        <span class="text-gray-400">Warto≈õƒá:</span><span class="font-medium flex items-center">${plot.value || '0'} <img src="minecoin.png" class="inline w-4 h-4 ml-1" alt="MC"></span>
                        <span class="text-gray-400">Ilo≈õƒá lokali:</span><span class="font-medium">${plot.apartmentCount || '0'}</span>
                        <span class="text-gray-400">Koordynaty:</span><span class="font-medium">(${plot.x1}, ${plot.z1})</span>
                    </div>`;
                modal.classList.add('show');
            }
            
            function showMergedModal(mergedPlot) {
                destroyActiveCharts();
                modalTitle.textContent = 'Szczeg√≥≈Çy po≈ÇƒÖczenia';
                const constituentPlotsDetails = mergedPlot.plots.map(plotName => {
                    const plotData = allPlots.find(p => p.name === plotName);
                    return `<div class="pl-2">- <strong>${plotName}</strong> (${plotData ? plotData.area + ' m¬≤' : 'Brak danych'})</div>`;
                }).join('');

                modalContent.innerHTML = `
                    <div><h3 class="text-2xl font-bold text-amber-400">Po≈ÇƒÖczone Dzia≈Çki</h3><p class="text-gray-400">Grupa ${mergedPlot.plots.length} dzia≈Çek</p></div>
                    <div class="space-y-3 text-sm">
                        <div>
                            <span class="text-gray-400 block">Dzia≈Çki wchodzƒÖce w sk≈Çad:</span>
                            <div class="font-medium space-y-1 mt-1">${constituentPlotsDetails}</div>
                        </div>
                        <div class="grid grid-cols-2 gap-x-4 gap-y-2 pt-2 border-t border-gray-700">
                            <span class="text-gray-400">Pow. oryginalna:</span><span class="font-medium">${mergedPlot.originalArea} m¬≤</span>
                            <span class="text-gray-400">Pow. po≈ÇƒÖczona:</span><span class="font-medium">${mergedPlot.mergedArea} m¬≤</span>
                            <span class="text-gray-400">R√≥≈ºnica:</span><span class="font-medium">${mergedPlot.mergedArea - mergedPlot.originalArea} m¬≤</span>
                            <span class="text-gray-400">Wymiary:</span><span class="font-medium">${mergedPlot.width}x${mergedPlot.height}</span>
                            <span class="text-gray-400">Koordynaty:</span><span class="font-medium">(${mergedPlot.x1}, ${mergedPlot.z1})</span>
                        </div>
                    </div>`;
                modal.classList.add('show');
            }

            function showDistrictModal(districtName, plotsInDistrict) {
                destroyActiveCharts();
                modalTitle.textContent = `Dzielnica: ${districtName}`;

                // Calculate stats
                const plotTypes = {};
                const occupancy = { Zajƒôte: 0, Wolne: 0 };
                const owners = {};
                let totalArea = 0;
                let totalValue = 0;

                plotsInDistrict.forEach(p => {
                    const type = p.type || 'Inne';
                    plotTypes[type] = (plotTypes[type] || 0) + 1;

                    const isOwned = p.owner && p.owner.trim() !== '' && p.owner.toLowerCase().trim() !== 'skarb miasta';
                    if (isOwned) {
                        occupancy.Zajƒôte++;
                        const owner = p.owner.trim();
                        owners[owner] = (owners[owner] || 0) + 1;
                    } else {
                        occupancy.Wolne++;
                    }

                    totalArea += parseInt(p.area) || 0;
                    totalValue += parseInt(p.value) || 0;
                });

                const plotLinks = plotsInDistrict.map(p => 
                    `<a href="#" class="text-purple-400 hover:underline" data-plot-name="${p.name}">${p.name}</a>`
                ).join(', ');

                modalContent.innerHTML = `
                    <div><h3 class="text-2xl font-bold text-purple-400">${districtName}</h3></div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm border-b border-gray-700 pb-3">
                        <span class="text-gray-400">Liczba dzia≈Çek:</span><span class="font-medium">${plotsInDistrict.length}</span>
                        <span class="text-gray-400">≈ÅƒÖczna powierzchnia:</span><span class="font-medium">${totalArea.toLocaleString()} m¬≤</span>
                        <span class="text-gray-400">≈ÅƒÖczna warto≈õƒá:</span><span class="font-medium flex items-center">${totalValue.toLocaleString()} <img src="minecoin.png" class="inline w-4 h-4 ml-1" alt="MC"></span>
                    </div>
                    <div class="text-sm"><span class="text-gray-400">Dzia≈Çki:</span> ${plotLinks}</div>
                    <div>
                        <h4 class="text-md font-semibold mt-4 mb-2">Struktura dzia≈Çek</h4>
                        <div class="chart-container"><canvas id="plot-type-chart"></canvas></div>
                        <h4 class="text-md font-semibold mt-4 mb-2">Zajƒôto≈õƒá</h4>
                        <div class="chart-container"><canvas id="occupancy-chart"></canvas></div>
                        <h4 class="text-md font-semibold mt-4 mb-2">W≈Ça≈õciciele</h4>
                        <div class="chart-container"><canvas id="owners-chart"></canvas></div>
                    </div>`;

                // Render charts
                createChart('plot-type-chart', 'pie', plotTypes, 'Typy dzia≈Çek');
                createChart('occupancy-chart', 'doughnut', occupancy, 'Zajƒôto≈õƒá');
                createChart('owners-chart', 'bar', owners, 'W≈Ça≈õciciele dzia≈Çek');
                
                modalContent.querySelectorAll('a[data-plot-name]').forEach(a => {
                    a.addEventListener('click', e => {
                        e.preventDefault();
                        findPlotAndCenter(e.target.dataset.plotName);
                    });
                });

                modal.classList.add('show');
            }
            
            function createChart(canvasId, type, data, label) {
                const ctx = document.getElementById(canvasId);
                if (!ctx) return;

                const chartLabels = Object.keys(data);
                const chartData = Object.values(data);
                
                if (chartData.length === 0) {
                     ctx.parentElement.innerHTML = `<div class="flex items-center justify-center h-full text-gray-500">Brak danych do wy≈õwietlenia</div>`;
                     return;
                }

                // Color generation for charts
                const colors = chartLabels.map((_, i) => `hsl(${(i * 360) / chartLabels.length}, 70%, 60%)`);

                const chart = new Chart(ctx, {
                    type: type,
                    data: {
                        labels: chartLabels,
                        datasets: [{
                            label: label,
                            data: chartData,
                            backgroundColor: colors,
                            borderColor: '#1f2937',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: type === 'bar' ? 'top' : 'right',
                                labels: { color: '#d1d5db' }
                            }
                        },
                        scales: type === 'bar' ? {
                            y: {
                                beginAtZero: true,
                                ticks: { color: '#9ca3af', stepSize: 1 }
                            },
                             x: { ticks: { color: '#9ca3af' } }
                        } : {}
                    }
                });
                activeCharts.push(chart);
            }

            function destroyActiveCharts() {
                activeCharts.forEach(chart => chart.destroy());
                activeCharts = [];
            }

            function hideTooltip() { tooltip.classList.add('hidden'); }
            function moveTooltip(e) {
                const PADDING = 20; let x = e.clientX + PADDING; let y = e.clientY + PADDING;
                if (x + tooltip.offsetWidth > window.innerWidth) x = e.clientX - tooltip.offsetWidth - PADDING;
                if (y + tooltip.offsetHeight > window.innerHeight) y = e.clientY - tooltip.offsetHeight - PADDING;
                tooltip.style.left = `${x}px`; tooltip.style.top = `${y}px`;
            }

            function findPlotAndCenter(query) {
                if (!query) return;
                const searchTerm = query.trim().toLowerCase();
                const searchNumber = parseInt(searchTerm.replace(/.*\//, ''), 10);

                const foundPlot = allPlots.find(p => {
                    const plotName = p.name ? p.name.toLowerCase() : '';
                    const plotId = parseInt(p.id, 10);
                    return plotName === searchTerm || plotId === searchNumber;
                });

                if (foundPlot) {
                    const newW = 300;
                    const newH = (newW / initialViewBox.w) * initialViewBox.h;
                    const newX = foundPlot.x1 + foundPlot.width / 2 - newW / 2;
                    const newY = foundPlot.z1 + foundPlot.height / 2 - newH / 2;
                    setViewBox(newX, newY, newW, newH);
                    highlightPlot(foundPlot.id);
                    showModal(foundPlot);
                    searchInput.value = '';
                } else {
                    searchInput.classList.add('ring-red-500');
                    setTimeout(() => searchInput.classList.remove('ring-red-500'), 2000);
                }
            }
            function highlightPlot(plotId) {
                clearHighlight();
                const plotElement = svg.querySelector(`g[data-plot-id='${plotId}'] .plot-rect`);
                if (plotElement) plotElement.classList.add('highlighted');
            }

            function toggleLayer(layerName) {
                layerVisibility[layerName] = !layerVisibility[layerName];
                document.getElementById(`${layerName}-layer`).classList.toggle('hidden-layer', !layerVisibility[layerName]);
                document.getElementById(`toggle-${layerName}`).classList.toggle('active', layerVisibility[layerName]);
            }

            // --- Event Listeners ---
            closeModalBtn.addEventListener('click', () => {
                 modal.classList.remove('show');
                 destroyActiveCharts();
            });
            mapContainer.addEventListener('click', (e) => { 
                if (e.target === mapContainer || e.target === svg || e.target.id === 'map-svg') {
                    modal.classList.remove('show'); 
                    destroyActiveCharts();
                }
            });
            searchButton.addEventListener('click', () => findPlotAndCenter(searchInput.value));
            searchInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') findPlotAndCenter(searchInput.value); });

            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const w = viewBox.w; const h = viewBox.h; const mx = e.offsetX; const my = e.offsetY;
                const dw = w * Math.sign(e.deltaY) * 0.1; const dh = h * Math.sign(e.deltaY) * 0.1;
                const dx = dw * mx / mapContainer.clientWidth; const dy = dh * my / mapContainer.clientHeight;
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w - dw, viewBox.h - dh);
            }, { passive: false });

            mapContainer.addEventListener('mousedown', (e) => { if (e.button === 0) { isPanning = true; mapContainer.classList.add('grabbing'); startPoint = { x: e.x, y: e.y }; }});
            mapContainer.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const endPoint = { x: e.x, y: e.y };
                const dx = (startPoint.x - endPoint.x) * (viewBox.w / mapContainer.clientWidth);
                const dy = (startPoint.y - endPoint.y) * (viewBox.h / mapContainer.clientHeight);
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                startPoint = { x: e.x, y: e.y };
            });
            document.addEventListener('mouseup', () => { isPanning = false; mapContainer.classList.remove('grabbing'); });
            
            let touchPanning = false; let pinchZooming = false;
            mapContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchPanning = true;
                    touchStartInfo = { time: Date.now(), x: e.touches[0].clientX, y: e.touches[0].clientY };
                    startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length >= 2) {
                    pinchZooming = true;
                    touchPanning = false;
                    lastTouchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                }
            }, { passive: true });

            mapContainer.addEventListener('touchmove', (e) => {
                if (touchPanning && e.touches.length === 1) {
                    const endPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    const dx = (startPoint.x - endPoint.x) * (viewBox.w / mapContainer.clientWidth);
                    const dy = (startPoint.y - endPoint.y) * (viewBox.h / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                    startPoint = endPoint;
                } else if (pinchZooming && e.touches.length >= 2) {
                    const newDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const scale = lastTouchDistance / newDist;
                    const w = viewBox.w * scale; const h = viewBox.h * scale;
                    const clientX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const clientY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    const { left, top } = mapContainer.getBoundingClientRect();
                    const mx = clientX - left; const my = clientY - top;
                    const dx = (viewBox.w - w) * (mx / mapContainer.clientWidth);
                    const dy = (viewBox.h - h) * (my / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, w, h);
                    lastTouchDistance = newDist;
                }
            }, { passive: true });

            mapContainer.addEventListener('touchend', (e) => { 
                touchPanning = false; 
                pinchZooming = false; 
                if (e.touches.length === 0) {
                     // The last finger has been lifted, reset touch info to prevent false tap detections
                     touchStartInfo = { time: 0, x: 0, y: 0 };
                }
            });
            
            document.getElementById('zoom-in').addEventListener('click', () => { const dw = viewBox.w * -0.2; const dh = viewBox.h * -0.2; setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh); });
            document.getElementById('zoom-out').addEventListener('click', () => { const dw = viewBox.w * 0.2; const dh = viewBox.h * 0.2; setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh); });
            document.getElementById('reset-view').addEventListener('click', () => { setViewBox(initialViewBox.x, initialViewBox.y, initialViewBox.w, initialViewBox.h); });

            document.getElementById('toggle-plots').addEventListener('click', () => toggleLayer('plots'));
            document.getElementById('toggle-streets').addEventListener('click', () => toggleLayer('streets'));
            document.getElementById('toggle-districts').addEventListener('click', () => toggleLayer('districts'));
            document.getElementById('toggle-merged').addEventListener('click', () => toggleLayer('merged'));

            fetchAllData();
        });
    </script>
</body>
</html>

