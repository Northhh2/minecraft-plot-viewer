<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Portal AmoGeus</title>
    <link rel="icon" type="image/x-icon" href="Red.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        #map-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        #map-svg {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111827;
        }

        .plot-rect {
            stroke-width: 0.5;
            transition: fill 0.2s ease-in-out, fill-opacity 0.3s ease-in-out, filter 0.3s ease-in-out, stroke 0.3s, stroke-width 0.3s;
        }

        .plot-rect:hover {
            fill-opacity: 0.7;
        }

        .plot-rect.dimmed {
            fill-opacity: 0.2 !important;
            filter: grayscale(80%);
        }

        .plot-rect.highlighted {
            fill-opacity: 1 !important;
            filter: brightness(1.2);
            stroke: #facc15;
            stroke-width: 1.5;
        }

        .street-rect {
            fill: #4b5563;
            fill-opacity: 1;
            stroke: transparent;
            stroke-width: 0.25;
            transition: fill-opacity 0.2s, stroke 0.2s;
            cursor: pointer;
        }

        .street-rect:hover {
            fill-opacity: 0.7;
            stroke: #9ca3af;
        }

        .merged-plot {
            stroke: #f59e0b;
            stroke-width: 1.5;
            stroke-dasharray: 4, 2;
            fill: none;
            pointer-events: all;
            cursor: pointer;
        }

        .plot-text {
            font-size: 4px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 0.5px;
            stroke-linecap: butt;
            stroke-linejoin: miter;
        }

        .street-text {
            font-size: 3px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .street-text.street-vertical {
            writing-mode: vertical-rl;
        }

        #tooltip {
            background-color: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid #4b5563;
            transition: opacity 0.2s ease-in-out;
        }

        #modal {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }

        #modal.show {
            transform: translateX(0);
        }

        #modal-content {
            transition: opacity 0.15s ease-out;
        }

        #modal-content.fade-out {
            opacity: 0;
        }

        .grab {
            cursor: grab;
        }

        .grabbing {
            cursor: grabbing;
        }

        .toggle-button {
            opacity: 0.5;
            border: 1px solid #4b5563;
        }

        .toggle-button.active {
            opacity: 1;
            background-color: #4338ca;
            border-color: #6d28d9;
        }

        .hidden-layer {
            display: none;
        }

        .chart-container {
            height: 200px;
            width: 100%;
        }

        .clickable {
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .clickable:hover {
            color: #a78bfa;
        }

        #search-suggestions {
            max-height: 300px;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            #tooltip {
                font-size: 12px;
                max-width: 90vw;
                max-height: 50vh;
                overflow-y: auto;
            }

            .plot-text {
                font-size: 3px;
            }

            .controls {
                bottom: 10px !important;
                right: 10px !important;
            }

            .control-button {
                width: 44px;
                height: 44px;
            }

            #modal {
                width: 100vw;
            }
        }
    </style>
</head>

<body class="bg-gray-900 text-white">

    <!-- Search Bar -->
    <div class="absolute top-5 left-5 z-30">
        <div class="relative">
            <div class="flex bg-gray-800 rounded-lg border border-gray-600 shadow-lg">
                <input type="text" id="search-input" placeholder="Wyszukaj (dzia≈Çka, w≈Ça≈õciciel, adres...)"
                    class="bg-transparent text-white px-4 py-2 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-purple-500 w-48 md:w-64"
                    maxlength="30" autocomplete="off">
                <button id="search-button"
                    class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-r-lg transition-colors">üîç</button>
            </div>
            <div id="search-suggestions"
                class="absolute left-0 mt-2 w-full bg-gray-800 border border-gray-600 rounded-lg shadow-lg z-10 hidden">
                <!-- Suggestions will be populated here by JS -->
            </div>
        </div>
    </div>

    <!-- Main container for the map -->
    <div id="map-container" class="grab">
        <svg id="map-svg"></svg>
    </div>

    <button id="lottery-button"
        class="hidden absolute bottom-5 left-24 z-30 bg-yellow-500 text-black font-bold px-4 py-2 rounded-lg shadow-lg hover:bg-yellow-400 transition-colors">Loteria</button>

    <!-- Simple Tooltip -->
    <div id="tooltip" class="hidden absolute p-2 rounded-lg shadow-xl text-sm z-40 pointer-events-none"></div>

    <!-- Coordinates Display -->
    <div id="coords-display"
        class="absolute bottom-5 left-5 z-30 bg-gray-800 bg-opacity-75 text-white text-xs px-2 py-1 rounded-md pointer-events-none">
        X: 0, Z: 0
    </div>

    <!-- Right Side Modal -->
    <div id="modal"
        class="fixed top-0 right-0 w-full md:w-96 h-full bg-gray-800 border-l border-gray-600 shadow-2xl z-50 overflow-y-auto">
        <div class="p-6">
            <div class="flex justify-between items-center mb-4">
                <div class="flex items-center space-x-3">
                    <button id="back-modal"
                        class="hidden text-gray-400 hover:text-white text-2xl font-bold transition-opacity"
                        title="Wr√≥ƒá">&larr;</button>
                    <h2 id="modal-title" class="text-xl font-bold">Szczeg√≥≈Çy</h2>
                </div>
                <button id="close-modal" class="text-gray-400 hover:text-white text-2xl"
                    title="Zamknij">&times;</button>
            </div>
            <div id="modal-content" class="space-y-4"></div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loader" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50">
        <div class="text-center">
            <svg class="animate-spin h-8 w-8 text-white mx-auto mb-3" xmlns="http://www.w3.org/2000/svg" fill="none"
                viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            <p class="text-lg font-medium">Pobieranie danych...</p>
            <p class="text-sm text-gray-400">Proszƒô czekaƒá</p>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls absolute flex flex-col items-end z-30" style="bottom: 20px; right: 20px;">
        <div class="flex flex-col space-y-2">
            <button id="zoom-in"
                class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600"
                title="Powiƒôksz"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg></button>
            <button id="zoom-out"
                class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600"
                title="Pomniejsz"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg></button>
            <button id="reset-view"
                class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600"
                title="Resetuj widok"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 2v6h6"></path>
                    <path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path>
                    <path d="M21 22v-6h-6"></path>
                    <path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path>
                </svg></button>
        </div>
        <div id="layer-toggles" class="mt-2 flex flex-col space-y-2">
            <button id="toggle-plots"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka≈º/Ukryj Dzia≈Çki"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                </svg></button>
            <button id="toggle-streets"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka≈º/Ukryj Ulice"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <line x1="4" y1="20" x2="4" y2="4"></line>
                    <line x1="20" y1="20" x2="20" y2="4"></line>
                    <line x1="12" y1="4" x2="12" y2="20"></line>
                </svg></button>
            <button id="toggle-districts"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka≈º/Ukryj Dzielnice"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg></button>
            <button id="toggle-merged"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka≈º/Ukryj Po≈ÇƒÖczone Dzia≈Çki"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                </svg></button>
        </div>
    </div>

    <div class="absolute top-5 right-5 z-30">
        <div id="user-auth-container">
            <!-- Przycisk Zaloguj (domy≈õlnie widoczny) -->
            <button id="login-button"
                class="bg-gray-800 text-white px-4 py-2 rounded-lg border border-gray-600 hover:bg-gray-700 transition-colors">
                Zaloguj siƒô
            </button>
            <!-- Przycisk profilu (domy≈õlnie ukryty) -->
            <button id="profile-button"
                class="hidden w-10 h-10 rounded-full border-2 border-purple-500 hover:border-purple-400 transition-colors focus:outline-none focus:ring-2 focus:ring-purple-500">
                <img id="profile-pic" src="placeholder.webp" onerror="this.onerror=null;this.src='placeholder.webp';"
                    class="w-full h-full rounded-full object-cover">
            </button>
        </div>
    </div>

    <div id="login-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl border border-gray-600 w-full max-w-sm">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Logowanie</h2>
                <button id="close-login-modal" class="text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>
            <form id="login-form">
                <div class="space-y-4">
                    <div>
                        <label for="loginIdentifier" class="block text-sm font-medium text-gray-300">Nazwa gracza lub
                            NIO</label>
                        <input type="text" id="loginIdentifier" name="loginIdentifier" required
                            class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                    </div>
                    <div>
                        <label for="pin" class="block text-sm font-medium text-gray-300">PIN</label>
                        <input type="password" id="pin" name="pin" required maxlength="4"
                            class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                    </div>
                </div>
                <p id="login-error" class="hidden text-red-400 text-sm mt-4"></p>
                <div class="mt-6">
                    <button type="submit"
                        class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        Zaloguj siƒô
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- 2. OVERLAY LOTERII (umie≈õƒá gdziekolwiek w <body>, np. przed tagiem <script>) -->
    <div id="lottery-overlay" class="hidden fixed inset-0 z-50">
        <div class="absolute top-5 right-5">
            <button id="close-lottery-button" class="text-gray-400 hover:text-white text-4xl font-bold">&times;</button>
        </div>
        <div class="relative flex flex-col items-center justify-center">
            <div class="absolute top-0 -mt-8 text-white text-2xl font-bold" style="text-shadow: 2px 2px 4px #000;">‚ñ≤
            </div>
            <canvas id="wheelCanvas" width="500" height="500"></canvas>
            <button id="spin-button"
                class="mt-8 bg-green-600 text-white font-bold py-4 px-8 rounded-full text-2xl shadow-lg hover:bg-green-500 transition-transform transform hover:scale-105 disabled:bg-gray-500 disabled:cursor-not-allowed">Zakrƒôƒá!</button>
        </div>
        <div id="lottery-result"
            class="hidden absolute inset-0 bg-gray-900 bg-opacity-90 flex items-center justify-center text-center p-8">
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const SHEET_ID = '1swtElpz27sqLMNbATocFe9VHc1yZTSRxvHyikFL_R7U';
            const PLOTS_GID = '0';
            const MERGED_GID = '43897086';
            const STREETS_GID = '2101138806';
            const LOCALS_GID = '875214507';
            const OWNERS_GID = '92681717';
            const TRANSACTIONS_GID = '231383988';
            const SETTINGS_GID = '464636229';
            const LOTTERY_GID = '1580637376';

            const urls = {
                plots: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${PLOTS_GID}`,
                merged: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${MERGED_GID}`,
                streets: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${STREETS_GID}`,
                locals: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${LOCALS_GID}`,
                owners: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${OWNERS_GID}`,
                transactions: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${TRANSACTIONS_GID}`,
                settings: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${SETTINGS_GID}`,
                lottery: `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${LOTTERY_GID}`
            };

            const MAP_IMAGE_URL = 'map.webp';
            const MAP_WIDTH = 4296;
            const MAP_HEIGHT = 2360;

            const coordsDisplay = document.getElementById('coords-display');
            const svg = document.getElementById('map-svg');
            const tooltip = document.getElementById('tooltip');
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContent = document.getElementById('modal-content');
            const loader = document.getElementById('loader');
            const mapContainer = document.getElementById('map-container');
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const searchSuggestions = document.getElementById('search-suggestions');
            const closeModalBtn = document.getElementById('close-modal');

            let lotterySettings = {};
            let lotteryHistory = [];
            let eligibleForLottery = [];
            let physicalPersons = [];
            let nextWinnerIndex = 0;

            let viewBox = { x: 0, y: 0, w: 0, h: 0 };
            let isPanning = false;
            let startPoint = { x: 0, y: 0 };
            const initialViewBox = {};
            let layerVisibility = { plots: true, streets: true, districts: true, merged: true };
            let touchStartInfo = { time: 0, x: 0, y: 0 };
            let activeCharts = [];
            let maxViewboxWidth = MAP_WIDTH;
            let isAnimatingModal = false;
            let isDragging = false;
            let currentUser = null;

            let allPlots = [];
            let allLocals = [];
            let allOwners = [];
            let allTransactions = [];
            let mergedPlots = [];
            let streets = [];

            let modalHistory = [];

            const layers = {
                districts: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                merged: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                streets: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                plots: document.createElementNS('http://www.w3.org/2000/svg', 'g')
            };

            function setViewBox(x, y, w, h) {
                const isMobile = window.innerWidth <= 768;
                const minZoom = isMobile ? 50 : 100;
                w = Math.max(minZoom, w);
                w = Math.min(w, maxViewboxWidth);
                if (initialViewBox.w) { h = (w / initialViewBox.w) * initialViewBox.h; }
                const minX_bound = -MAP_WIDTH / 2, minY_bound = -MAP_HEIGHT / 2;
                const maxX_bound = MAP_WIDTH / 2, maxY_bound = MAP_HEIGHT / 2;
                if (x < minX_bound) x = minX_bound;
                if (y < minY_bound) y = minY_bound;
                if (x + w > maxX_bound) x = maxX_bound - w;
                if (y + h > maxY_bound) y = maxY_bound - h;
                viewBox = { x, y, w, h };
                svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);

                // Zawsze aktualizuj koordynaty ≈õrodka (dla mobile)
                const centerX = Math.round(viewBox.x + viewBox.w / 2);
                const centerZ = Math.round(viewBox.y + viewBox.h / 2);
                // Sprawd≈∫, czy urzƒÖdzenie jest dotykowe, aby zdecydowaƒá, co wy≈õwietliƒá
                if ('ontouchstart' in window) {
                    coordsDisplay.textContent = `X: ${centerX}, Z: ${centerZ}`;
                }
            }

            function getColorForType(type, alpha = 0.8) {
                switch (type) {
                    case 'Parkowa': return `rgba(0, 170, 0, ${alpha})`;
                    case 'Rolna': return `rgba(180, 104, 77, ${alpha})`;
                    case 'Hotelowa': return `rgba(44, 186, 168, ${alpha})`;
                    case 'Mieszkalna': return `rgba(222, 177, 45, ${alpha})`;
                    case 'Sakralna': return `rgba(154, 92, 198, ${alpha})`;
                    case 'Przemys≈Çowo-biurowa': return `rgba(255, 85, 255, ${alpha})`;
                    case 'Mieszkalno-us≈Çugowa': return `rgba(33, 73, 123, ${alpha})`;
                    case 'Publiczna': return `rgba(255, 170, 0, ${alpha})`;
                    case 'Medyczna': return `rgba(170, 0, 0, ${alpha})`;
                    case 'Us≈Çugowa': return `rgba(17, 160, 54, ${alpha})`;
                    default: return `rgba(255, 255, 255, 0.1)`;
                }
            }

            function openNewModal(state) {
                modalHistory = [];
                navigateToModal(state);
            }

            function navigateToModal(state) {
                modalHistory.push(state);
                renderCurrentModal();
            }

            function goBackModal() {
                if (modalHistory.length > 1) {
                    modalHistory.pop();
                    renderCurrentModal(true);
                }
            }

            function closeModal() {
                destroyActiveCharts();
                modalHistory = [];
                modal.classList.remove('show');
                dimOtherPlots();
                clearHighlight();
            }

            async function fetchAllData() {
                try {
                    const responses = await Promise.all(Object.values(urls).map(url => fetch(url)));
                    const texts = await Promise.all(responses.map(res => res.text()));
                    const results = await Promise.all(texts.map(text => new Promise(resolve => Papa.parse(text, { header: true, skipEmptyLines: true, complete: resolve }))));

                    const [plotsData, mergedData, streetsData, localsData, ownersData, transactionsData, settingsData, lotteryData] = results;

                    allPlots = plotsData.data.map(d => ({
                        id: d['Nr porzƒÖdkowy'], name: d['Nazwa porzƒÖdkowa dzia≈Çki'], type: d['Typ'],
                        x1: parseInt(d['X (lewy g√≥rny)'], 10), z1: parseInt(d['Z (lewy g√≥rny)'], 10),
                        x2: parseInt(d['X (prawy dolny)'], 10), z2: parseInt(d['Z (prawy dolny)'], 10),
                        width: Math.abs(parseInt(d['Bok X'], 10)), height: Math.abs(parseInt(d['Bok Z'], 10)),
                        area: d['Powierzchnia'], value: d['Warto≈õƒá'], owner: 'Skarb Miasta', status: 'owned',
                        district: d['Dzielnica'], street: d['Ulica'], buildingNumber: d['Numer budynku'], history: []
                    }));

                    allLocals = localsData.data.map(l => {
                        const parentPlot = allPlots.find(p => p.name === l['Numer dzia≈Çki']);
                        return {
                            id: l['Numer porzƒÖdkowy'], plotName: l['Numer dzia≈Çki'],
                            street: parentPlot ? parentPlot.street : '', building: parentPlot ? parentPlot.buildingNumber : '',
                            klatka: l['Klatka'], localNum: l['Numer lokalu'], floor: l['Piƒôtro'],
                            area: parseInt(l['Powierzchnia']) || 0, beds: parseInt(l['Ilo≈õƒá ≈Ç√≥≈ºek']) || 0,
                            workplaces: parseInt(l['Ilo≈õƒá miejsc pracy']) || 0, tenant: l['Najemca']
                        };
                    });

                    allOwners = ownersData.data.map(o => ({
                        name: o['Nazwa'], type: o['Typ'], photo: o['Zdjƒôcie'],
                        nio: o['NIO'], age: o['Wiek'], profession: o['Zaw√≥d'],
                        legalForm: o['Forma prawna'], pin: o['PIN'], staff: o['Obs≈Çuga'] === 'Tak'
                    }));

                    allTransactions = transactionsData.data.map(t => ({
                        plotName: t['Numer dzia≈Çki'], newOwner: t['Nowy w≈Ça≈õciciel'],
                        transactionValue: t['Warto≈õƒá transakcji'], date: t['Dzie≈Ñ transakcji'],
                        type: t['Typ transakcji'], checkNumber: t['Numer czeku'],
                        paid: t['Op≈Çacone?'] === 'TRUE'
                    }));

                    settingsData.data.forEach(s => { lotterySettings[s['Ustawienie']] = s['W≈ÇƒÖczone?'] === 'TRUE'; });
                    lotteryHistory = lotteryData.data.map(l => ({
                        plotName: l['Dzia≈Çka'], winner: l['Zwyciƒôzca'], amount: l['Kwota'],
                        checkNumber: l['Numer czeku'], paid: l['Op≈Çacone?'] === 'TRUE'
                    }));

                    updatePlotOwners();
                    mergedPlots = processMergedPlots(mergedData.data.filter(m => m['Dzia≈Çka g≈Ç√≥wna'] && m['Dzia≈Çka do≈ÇƒÖczana']).map(d => ({ plot1: d['Dzia≈Çka g≈Ç√≥wna'], plot2: d['Dzia≈Çka do≈ÇƒÖczana'] })));
                    streets = streetsData.data.map(d => ({
                        name: d['Nazwa ulicy'], x1: parseInt(d['X (lewy g√≥rny)'], 10), z1: parseInt(d['Z (lewy g√≥rny)'], 10),
                        width: Math.abs(parseInt(d['X (prawy dolny)'], 10) - parseInt(d['X (lewy g√≥rny)'], 10)) + 1,
                        height: Math.abs(parseInt(d['Z (prawy dolny)'], 10) - parseInt(d['Z (lewy g√≥rny)'], 10)) + 1
                    }));

                    drawMap();
                    setupLottery();
                    attemptAutoLogin();
                    loader.style.display = 'none';
                } catch (error) {
                    console.error("B≈ÇƒÖd podczas pobierania danych:", error);
                }
            }

            function updatePlotOwners() {
                const transactionsByPlot = {};
                allTransactions.forEach(t => {
                    if (!transactionsByPlot[t.plotName]) transactionsByPlot[t.plotName] = [];
                    transactionsByPlot[t.plotName].push(t);
                });

                for (const plotName in transactionsByPlot) {
                    transactionsByPlot[plotName].sort((a, b) => {
                        const dateA = a.date.split('.').reverse().join('');
                        const dateB = b.date.split('.').reverse().join('');
                        return dateA.localeCompare(dateB);
                    });
                }

                allPlots.forEach(plot => {
                    const plotTransactions = transactionsByPlot[plot.name];
                    if (plotTransactions && plotTransactions.length > 0) {
                        plot.history = plotTransactions;

                        const lastTransaction = plotTransactions[plotTransactions.length - 1];
                        const lastPaidTransaction = [...plotTransactions].reverse().find(t => t.paid);

                        if (lastPaidTransaction) {
                            plot.owner = lastPaidTransaction.newOwner;
                        } else {
                            plot.owner = 'Skarb Miasta';
                        }

                        if (lastTransaction && !lastTransaction.paid) {
                            plot.status = 'pending';
                        } else {
                            plot.status = 'owned';
                        }
                    }
                });
            }

            function processMergedPlots(connections) {
                const adj = new Map();
                const allPlotIdsInConnections = new Set();
                connections.forEach(({ plot1, plot2 }) => {
                    if (!adj.has(plot1)) adj.set(plot1, []);
                    if (!adj.has(plot2)) adj.set(plot2, []);
                    adj.get(plot1).push(plot2);
                    adj.get(plot2).push(plot1);
                    allPlotIdsInConnections.add(plot1);
                    allPlotIdsInConnections.add(plot2);
                });
                const visited = new Set();
                const groups = [];
                for (const plotId of allPlotIdsInConnections) {
                    if (!visited.has(plotId)) {
                        const group = [];
                        const stack = [plotId];
                        visited.add(plotId);
                        while (stack.length > 0) {
                            const currentId = stack.pop();
                            group.push(currentId);
                            const neighbors = adj.get(currentId) || [];
                            for (const neighbor of neighbors) {
                                if (!visited.has(neighbor)) {
                                    visited.add(neighbor);
                                    stack.push(neighbor);
                                }
                            }
                        }
                        groups.push(group);
                    }
                }
                return groups.map(group => {
                    const plotsInGroup = group.map(id => allPlots.find(p => p.name === id)).filter(Boolean);
                    if (plotsInGroup.length === 0) return null;
                    const minX = Math.min(...plotsInGroup.map(p => p.x1));
                    const maxX = Math.max(...plotsInGroup.map(p => p.x2));
                    const minZ = Math.min(...plotsInGroup.map(p => p.z1));
                    const maxZ = Math.max(...plotsInGroup.map(p => p.z2));
                    const originalArea = plotsInGroup.reduce((sum, p) => sum + (parseInt(p.area) || 0), 0);
                    return {
                        plots: group, x1: minX, z1: minZ, x2: maxX, z2: maxZ,
                        width: maxX - minX, height: maxZ - minZ, originalArea, mergedArea: (maxX - minX) * (maxZ - minZ)
                    };
                }).filter(Boolean);
            }

            function drawMap() {
                if (!allPlots.length) return;
                svg.innerHTML = '';
                const mapImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                mapImage.setAttribute('href', MAP_IMAGE_URL);
                mapImage.setAttribute('x', -MAP_WIDTH / 2);
                mapImage.setAttribute('y', -MAP_HEIGHT / 2);
                mapImage.setAttribute('width', MAP_WIDTH);
                mapImage.setAttribute('height', MAP_HEIGHT);
                svg.appendChild(mapImage);
                Object.values(layers).forEach(layer => layer.innerHTML = '');
                layers.districts.id = 'districts-layer';
                layers.merged.id = 'merged-layer';
                layers.streets.id = 'streets-layer';
                layers.plots.id = 'plots-layer';
                svg.appendChild(layers.districts);
                svg.appendChild(layers.merged);
                svg.appendChild(layers.streets);
                svg.appendChild(layers.plots);
                drawStreets();
                drawPlots();
                drawMergedPlots();
                drawDistrictBoundaries();
                const padding = 100;
                const minX = Math.min(...allPlots.map(p => p.x1));
                const maxX = Math.max(...allPlots.map(p => p.x2));
                const minZ = Math.min(...allPlots.map(p => p.z1));
                const maxZ = Math.max(...allPlots.map(p => p.z2));
                const mapContentWidth = maxX - minX + 2 * padding;
                const mapContentHeight = maxZ - minZ + 2 * padding;
                const clientRatio = mapContainer.clientWidth / mapContainer.clientHeight;
                const contentRatio = mapContentWidth / mapContentHeight;
                let w, h;
                if (clientRatio > contentRatio) {
                    h = mapContentHeight;
                    w = h * clientRatio;
                } else {
                    w = mapContentWidth;
                    h = w / clientRatio;
                }
                initialViewBox.x = minX - (w - mapContentWidth + 2 * padding) / 2;
                initialViewBox.y = minZ - (h - mapContentHeight + 2 * padding) / 2;
                initialViewBox.w = w;
                initialViewBox.h = h;
                const mapRatio = MAP_WIDTH / MAP_HEIGHT;
                if (clientRatio > mapRatio) {
                    maxViewboxWidth = MAP_HEIGHT * clientRatio;
                } else {
                    maxViewboxWidth = MAP_WIDTH;
                }
                setViewBox(initialViewBox.x, initialViewBox.y, initialViewBox.w, initialViewBox.h);
            }

            function drawStreets() {
                const streetsByName = new Map();
                streets.forEach(segment => {
                    if (!segment.name || segment.name.trim() === '') return;
                    if (!streetsByName.has(segment.name)) {
                        streetsByName.set(segment.name, []);
                    }
                    streetsByName.get(segment.name).push(segment);
                });

                streetsByName.forEach((segments, streetName) => {
                    const streetGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    streetGroup.dataset.streetName = streetName;

                    segments.forEach(segment => {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', segment.x1);
                        rect.setAttribute('y', segment.z1);
                        rect.setAttribute('width', segment.width);
                        rect.setAttribute('height', segment.height);
                        rect.setAttribute('class', 'street-rect');
                        streetGroup.appendChild(rect);
                    });

                    const longestSegment = segments.reduce((longest, current) => {
                        const currentLength = Math.max(current.width, current.height);
                        const longestLength = Math.max(longest.width, longest.height);
                        return currentLength > longestLength ? current : longest;
                    }, segments[0]);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', longestSegment.x1 + longestSegment.width / 2);
                    text.setAttribute('y', longestSegment.z1 + longestSegment.height / 2);
                    text.setAttribute('class', `street-text ${longestSegment.height > longestSegment.width ? 'street-vertical' : ''}`);
                    text.textContent = streetName;
                    streetGroup.appendChild(text);

                    streetGroup.addEventListener('click', (e) => {
                        if (isDragging) return;
                        e.stopPropagation();
                        openNewModal({ type: 'street', data: streetName });
                    });

                    streetGroup.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold">${streetName}</div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                        streetGroup.querySelectorAll('.street-rect').forEach(r => {
                            r.style.fillOpacity = '0.7';
                            r.style.stroke = '#9ca3af';
                        });
                    });

                    streetGroup.addEventListener('mouseleave', () => {
                        hideTooltip();
                        streetGroup.querySelectorAll('.street-rect').forEach(r => {
                            r.style.fillOpacity = '';
                            r.style.stroke = '';
                        });
                    });

                    streetGroup.addEventListener('mousemove', moveTooltip);

                    layers.streets.appendChild(streetGroup);
                });
            }

            function drawMergedPlots() {
                mergedPlots.forEach((merged) => {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', merged.x1); rect.setAttribute('y', merged.z1);
                    rect.setAttribute('width', merged.width); rect.setAttribute('height', merged.height);
                    rect.setAttribute('class', 'merged-plot');
                    rect.addEventListener('click', (e) => {
                        if (isDragging) return; // Zapobiegaj klikniƒôciu po przeciƒÖgniƒôciu
                        e.stopPropagation();
                        openNewModal({ type: 'merged', data: merged });
                    });
                    layers.merged.appendChild(rect);
                });
            }

            function drawPlots() {
                allPlots.forEach(plot => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.dataset.plotId = plot.id;
                    g.dataset.plotName = plot.name;
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', plot.x1); rect.setAttribute('y', plot.z1);
                    rect.setAttribute('width', plot.width); rect.setAttribute('height', plot.height);
                    rect.setAttribute('class', 'plot-rect');

                    const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                    rect.style.fill = getColorForType(plot.type);

                    if (plot.status === 'pending') {
                        rect.style.stroke = '#facc15'; // ≈ª√≥≈Çty dla "w trakcie zmiany"
                    } else {
                        rect.style.stroke = isOwned ? '#ef4444' : '#22c55e'; // Czerwony/Zielony
                    }

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', plot.x1 + plot.width / 2);
                    text.setAttribute('y', plot.z1 + plot.height / 2);
                    text.setAttribute('class', 'plot-text');
                    text.textContent = plot.id.padStart(3, '0');
                    g.appendChild(rect); g.appendChild(text);

                    g.addEventListener('mouseenter', (e) => {
                        showSimpleTooltip(e, plot);
                        if (modalHistory.length === 0 && plot.district) highlightDistrict(plot.district);
                    });
                    g.addEventListener('mouseleave', () => {
                        hideTooltip();
                        if (modalHistory.length === 0) clearHighlight();
                    });

                    g.addEventListener('mousemove', moveTooltip);
                    g.addEventListener('click', (e) => {
                        if (isDragging) return;
                        e.stopPropagation();
                        openNewModal({ type: 'plot', data: plot });
                    });
                    layers.plots.appendChild(g);
                });
            }

            function drawDistrictBoundaries() {
                const districts = {};
                allPlots.forEach(plot => {
                    if (plot.district) {
                        if (!districts[plot.district]) districts[plot.district] = [];
                        districts[plot.district].push(plot);
                    }
                });
                Object.entries(districts).forEach(([districtName, districtPlots]) => {
                    createDistrictClusters(districtPlots, 50).forEach((cluster) => {
                        const boundary = createDistrictOutline(cluster);
                        if (!boundary) return;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', boundary);
                        path.style.cssText = "fill:none; stroke:#8b5cf6; stroke-width:2; stroke-dasharray:8,4; opacity:0.7; cursor:pointer; pointer-events:all;";
                        path.addEventListener('click', (e) => {
                            if (isDragging) return; // Zapobiegaj klikniƒôciu po przeciƒÖgniƒôciu
                            e.stopPropagation();
                            openNewModal({ type: 'district', data: { name: districtName, plots: cluster } });
                        });
                        layers.districts.appendChild(path);
                    });
                });
            }

            function createDistrictClusters(plots, maxDistance) {
                const clusters = []; let visited = new Set();
                plots.forEach(plot => {
                    if (!visited.has(plot.id)) {
                        const newCluster = []; const queue = [plot];
                        visited.add(plot.id);
                        while (queue.length > 0) {
                            const currentPlot = queue.shift();
                            newCluster.push(currentPlot);
                            plots.forEach(otherPlot => {
                                if (!visited.has(otherPlot.id)) {
                                    if (currentPlot.x1 <= otherPlot.x2 + maxDistance && currentPlot.x2 >= otherPlot.x1 - maxDistance &&
                                        currentPlot.z1 <= otherPlot.z2 + maxDistance && currentPlot.z2 >= otherPlot.z1 - maxDistance) {
                                        visited.add(otherPlot.id);
                                        queue.push(otherPlot);
                                    }
                                }
                            });
                        }
                        clusters.push(newCluster);
                    }
                });
                return clusters;
            }

            function createDistrictOutline(plots) {
                if (plots.length === 0) return '';

                // Znajd≈∫ skrajne koordynaty dla wszystkich dzia≈Çek w klastrze
                const minX = Math.min(...plots.map(p => p.x1));
                const maxX = Math.max(...plots.map(p => p.x2));
                const minZ = Math.min(...plots.map(p => p.z1));
                const maxZ = Math.max(...plots.map(p => p.z2));

                // Zwr√≥ƒá prostƒÖ ≈õcie≈ºkƒô prostokƒÖta otaczajƒÖcego
                return `M ${minX} ${minZ} L ${maxX} ${minZ} L ${maxX} ${maxZ} L ${minX} ${maxZ} Z`;
            }


            function highlightDistrict(districtName) {
                svg.querySelectorAll('.plot-rect').forEach(rect => {
                    if (rect.parentElement.dataset.plotDistrict !== districtName) {
                        rect.classList.add('dimmed');
                    }
                });
            }

            function clearHighlight() {
                svg.querySelectorAll('.plot-rect.dimmed').forEach(rect => rect.classList.remove('dimmed'));
                svg.querySelectorAll('.plot-rect.highlighted').forEach(rect => rect.classList.remove('highlighted'));
            }

            function showSimpleTooltip(e, plot) {
                let statusText = '';
                let statusColor = '';

                if (plot.status === 'pending') {
                    statusText = 'W trakcie zmiany w≈Çasno≈õci';
                    statusColor = 'text-yellow-400';
                } else {
                    const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                    if (isOwned) {
                        statusText = 'Zajƒôta';
                        statusColor = 'text-red-400';
                    } else {
                        statusText = 'Wolna';
                        statusColor = 'text-green-400';
                    }
                }

                tooltip.innerHTML = `<div class="font-bold">${plot.name || `Dzia≈Çka ${plot.id}`}</div><div class="text-xs ${statusColor}">${statusText}</div>`;
                tooltip.classList.remove('hidden');
                moveTooltip(e);
            }

            function renderCurrentModal() {
                if (modalHistory.length === 0 || isAnimatingModal) return;
                isAnimatingModal = true;
                const currentState = modalHistory[modalHistory.length - 1];
                modalContent.classList.add('fade-out');

                setTimeout(() => {
                    destroyActiveCharts();
                    const { type, data } = currentState;
                    let contentHTML = '', title = '';
                    let plotsToHighlight = [];

                    switch (type) {
                        case 'plot': title = `Dzia≈Çka: ${data.name}`; contentHTML = renderPlotContent(data); plotsToHighlight = [data]; break;
                        case 'merged': title = 'Po≈ÇƒÖczone dzia≈Çki'; contentHTML = renderMergedContent(data); plotsToHighlight = data.plots.map(name => allPlots.find(p => p.name === name)).filter(Boolean); break;
                        case 'local': title = `Lokal #${data.klatka ? data.klatka + '/' : ''}${data.localNum}`; contentHTML = renderLocalContent(data); const parentPlot = allPlots.find(p => p.name === data.plotName); if (parentPlot) plotsToHighlight = [parentPlot]; break;
                        case 'owner': title = `Aktywa: ${data}`; contentHTML = renderOwnerContent(data); plotsToHighlight = allPlots.filter(p => p.owner === data); break;
                        case 'district': title = `Dzielnica: ${data.name}`; contentHTML = renderDistrictContent(data.name, data.plots); plotsToHighlight = data.plots; break;
                        case 'street': title = `Ulica: ${data}`; contentHTML = renderStreetContent(data); plotsToHighlight = allPlots.filter(p => p.street === data); break;
                        case 'plotType': title = `Typ: ${data}`; contentHTML = renderPlotTypeContent(data); plotsToHighlight = allPlots.filter(p => p.type === data); break;
                    }

                    modalTitle.textContent = title;
                    modalContent.innerHTML = contentHTML;
                    addModalEventListeners();
                    dimOtherPlots(plotsToHighlight);

                    document.getElementById('back-modal').classList.toggle('hidden', modalHistory.length <= 1);
                    modal.classList.add('show');
                    modalContent.classList.remove('fade-out');
                    isAnimatingModal = false;
                }, 150);
            }

            function createPlotListItemHTML(plot) {
                let statusText = '';
                let statusColor = '';

                if (plot.status === 'pending') {
                    statusText = 'W trakcie zmiany w≈Çasno≈õci';
                    statusColor = 'text-yellow-400';
                } else {
                    const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                    statusText = isOwned ? 'Zajƒôta' : 'Wolna';
                    statusColor = isOwned ? 'text-red-400' : 'text-green-400';
                }

                return `<div data-plot-name="${plot.name}" class="bg-gray-700 p-2 rounded-md hover:bg-gray-600 cursor-pointer transition-colors">
        <div class="font-semibold text-purple-400">${plot.name} (${plot.area} m¬≤)</div>
        <div class="text-xs text-gray-400">W≈Ça≈õciciel: <span class="font-medium text-gray-200">${plot.owner || 'Brak'}</span></div>
        <div class="text-xs ${statusColor}">${statusText}</div></div>`;
            }

            function createOwnerCardHTML(ownerName, isSelf = false) {
                if (!ownerName) return '';
                const owner = allOwners.find(o => o.name === ownerName);
                const isClickable = !isSelf && ownerName.toLowerCase() !== 'skarb miasta';
                const photo = owner?.photo || 'placeholder.webp';
                const type = owner?.type ? (owner.type.charAt(0).toUpperCase() + owner.type.slice(1)) : '';
                return `<div class="flex items-center bg-gray-700 p-2 rounded-md transition-colors ${isClickable ? 'clickable hover:bg-gray-600' : ''}" ${isClickable ? `data-owner-name="${ownerName}"` : ''}>
        <img src="${photo}" onerror="this.onerror=null;this.src='placeholder.webp';" class="w-10 h-10 rounded-full mr-3 object-cover">
        <div><div class="font-semibold text-white">${ownerName}</div><div class="text-xs text-gray-400">${type}</div></div></div>`;
            }

            function renderPlotContent(plot) {
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                const ownerInfo = plot.owner || 'Skarb Miasta';

                const localsOnPlot = allLocals.filter(l => l.plotName === plot.name);
                let localsHTML = '';

                if (localsOnPlot.length === 1) {
                    const singleLocal = localsOnPlot[0];
                    const localTitle = `Lokal #${singleLocal.klatka ? singleLocal.klatka + '/' : ''}${singleLocal.localNum}`;
                    localsHTML = `<div class="border-t border-gray-700 pt-3 mt-3">
            <h4 class="text-md font-semibold">${localTitle}</h4>
            <div class="space-y-3 mt-2">
               <div><span class="text-gray-400 text-sm">Najemca:</span>${createOwnerCardHTML(singleLocal.tenant || 'Brak')}</div>
               <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm pt-3 border-t border-gray-700">
                   <span class="text-gray-400">Powierzchnia:</span><span class="font-medium">${singleLocal.area} m¬≤</span>
                   <span class="text-gray-400">Piƒôtro:</span><span class="font-medium">${singleLocal.floor}</span>
                   <span class="text-gray-400">Miejsca pracy:</span><span class="font-medium">${singleLocal.workplaces}</span>
                   <span class="text-gray-400">Ilo≈õƒá ≈Ç√≥≈ºek:</span><span class="font-medium">${singleLocal.beds}</span>
               </div>
            </div>
        </div>`;
                } else if (localsOnPlot.length > 1) {
                    const localDetailsList = localsOnPlot.map(l => {
                        const localTitle = `Lokal #${l.klatka ? l.klatka + '/' : ''}${l.localNum}`;
                        return `<div data-local-id="${l.id}" class="bg-gray-700 p-2 rounded-md hover:bg-gray-600 cursor-pointer transition-colors">
                <div class="font-semibold text-purple-400">${localTitle} (${l.area} m¬≤)</div>
                <div class="text-xs text-gray-400">Najemca: <span class="font-medium text-gray-200">${l.tenant || 'Brak'}</span></div></div>`
                    }).join('');
                    localsHTML = `<div class="border-t border-gray-700 pt-3 mt-3"><h4 class="text-md font-semibold mb-3">Lokale w budynku (${localsOnPlot.length})</h4><div class="space-y-2">${localDetailsList}</div></div>`;
                }

                let address = '';
                if (plot.street && plot.buildingNumber) {
                    address += `<span data-street-name="${plot.street}" class="clickable">${plot.street}</span> ${plot.buildingNumber}, `;
                }
                if (plot.district) {
                    address += `<span data-district-name="${plot.district}" class="clickable">${plot.district}</span>`;
                }

                const typeColorDot = `<span class="inline-block w-2.5 h-2.5 rounded-full mr-2" style="background-color: ${getColorForType(plot.type, 1)}"></span>`;

                let historyHTML = '';
                if (plot.history && plot.history.length > 0) {
                    const reversedHistory = [...plot.history].reverse();
                    const historyList = reversedHistory.map((t, index) => {
                        let durationText = '';
                        const nextTransaction = reversedHistory[index - 1];
                        if (nextTransaction) {
                            const duration = parseInt(nextTransaction.date, 10) - parseInt(t.date, 10);
                            durationText = `${duration} dni`;
                        } else {
                            durationText = 'Obecnie';
                        }

                        let confidentialInfo = '';
                        if (currentUser && (t.newOwner === currentUser.name || (index > 0 && reversedHistory[index - 1].newOwner === currentUser.name))) {
                            confidentialInfo = `
                    <div class="text-xs text-gray-400 mt-1">Warto≈õƒá: ${t.transactionValue || 'Brak'} | Czek: #${t.checkNumber || 'Brak'}</div>
                 `;
                        }

                        return `
            <div class="bg-gray-700 p-2 rounded-md">
                <div class="flex justify-between items-center">
                    <div class="text-xs text-gray-400">${t.type}</div>
                    <div class="text-xs text-gray-300">${durationText}</div>
                </div>
                ${createOwnerCardHTML(t.newOwner)}
                ${confidentialInfo}
            </div>`;
                    }).join('');

                    historyHTML = `<div class="border-t border-gray-700 pt-3 mt-3">
            <h4 class="text-md font-semibold mb-3">Historia w≈Çasno≈õci</h4>
            <div class="space-y-2">${historyList}</div>
        </div>`;
                }

                const lotteryWin = lotteryHistory.find(l => l.plotName === plot.name && l.paid);
                let lotteryBadgeHTML = '';
                if (lotteryWin) {
                    lotteryBadgeHTML = `<div class="mt-2"><span class="lottery-badge">Zdobyte w Loterii Dzia≈Çkowej</span></div>`;
                }

                return `<div><h3 class="text-2xl font-bold ${isOwned ? 'text-red-400' : 'text-green-400'}">${plot.name}</h3><p class="text-gray-400 text-sm">${address}</p></div>
        <div class="space-y-3">
            ${createOwnerCardHTML(ownerInfo)}
            ${lotteryBadgeHTML}
            <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm pt-3 border-t border-gray-700">
                <span class="text-gray-400">Typ:</span><span class="font-medium flex items-center clickable" data-plot-type="${plot.type}">${typeColorDot} ${plot.type || 'Brak'}</span>
                <span class="text-gray-400">Warto≈õƒá:</span><span class="font-medium flex items-center">${plot.value || '0'} <img src="minecoin.webp" class="inline w-4 h-4 ml-1" alt="MC"></span>
                <span class="text-gray-400">Powierzchnia:</span><span class="font-medium">${plot.area || 'Brak'} m¬≤</span>
                <span class="text-gray-400">Rozmiar:</span><span class="font-medium">${plot.width}x${plot.height} m</span>
            </div></div>
        ${historyHTML}
        ${localsHTML}`;
            }

            function renderMergedContent(mergedPlot) {
                const plotsDetails = mergedPlot.plots.map(name => allPlots.find(p => p.name === name)).filter(Boolean).map(p => createPlotListItemHTML(p)).join('');
                return `<div><h3 class="text-2xl font-bold text-amber-400">Po≈ÇƒÖczone Dzia≈Çki</h3><p class="text-gray-400">Grupa ${mergedPlot.plots.length} dzia≈Çek</p></div>
        <div class="space-y-3"><div><span class="text-gray-400 block mb-2">Dzia≈Çki wchodzƒÖce w sk≈Çad:</span><div class="font-medium space-y-2">${plotsDetails}</div></div>
            <div class="grid grid-cols-2 gap-x-4 gap-y-2 pt-3 border-t border-gray-700 text-sm">
                <span class="text-gray-400">Pow. oryginalna:</span><span class="font-medium">${mergedPlot.originalArea} m¬≤</span>
                <span class="text-gray-400">Pow. po≈ÇƒÖczona:</span><span class="font-medium">${mergedPlot.mergedArea} m¬≤</span>
            </div></div>`;
            }

            function renderLocalContent(local) {
                const plot = allPlots.find(p => p.name === local.plotName);
                let address = '';
                if (local.street && local.building) {
                    const buildingPart = local.building + (local.klatka || '');
                    address += `<span data-street-name="${local.street}" class="clickable">${local.street}</span> ${buildingPart}/${local.localNum}, `;
                }
                if (plot?.district) {
                    address += `<span data-district-name="${plot.district}" class="clickable">${plot.district}</span>`;
                }

                const localTitle = `Lokal #${local.klatka ? local.klatka + '/' : ''}${local.localNum}`;
                return `<div><h3 class="text-2xl font-bold text-cyan-400">${localTitle}</h3><p class="text-gray-400 text-sm">${address}</p></div>
         <div class="space-y-3">
            <div><span class="text-gray-400 text-sm">Najemca:</span>${createOwnerCardHTML(local.tenant || 'Brak')}</div>
            <div><span class="text-gray-400 text-sm">W≈Ça≈õciciel budynku:</span>${createOwnerCardHTML(plot?.owner)}</div>
            <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm pt-3 border-t border-gray-700">
                <span class="text-gray-400">Powierzchnia:</span><span class="font-medium">${local.area} m¬≤</span>
                <span class="text-gray-400">Piƒôtro:</span><span class="font-medium">${local.floor}</span>
                <span class="text-gray-400">Miejsca pracy:</span><span class="font-medium">${local.workplaces}</span>
                <span class="text-gray-400">Ilo≈õƒá ≈Ç√≥≈ºek:</span><span class="font-medium">${local.beds}</span>
            </div></div>`;
            }

            function renderOwnerContent(ownerName) {
                const owner = allOwners.find(o => o.name === ownerName);
                const ownedPlots = allPlots.filter(p => p.owner === ownerName);
                const rentedLocals = allLocals.filter(l => l.tenant === ownerName);
                const totalPlotArea = ownedPlots.reduce((sum, p) => sum + (parseInt(p.area) || 0), 0);
                let ownerDetailsHTML = '';
                if (owner) {
                    ownerDetailsHTML += `<div class="grid grid-cols-2 gap-x-4 gap-y-1 text-sm"><span class="text-gray-400">NIO:</span><span>${owner.nio || 'Brak'}</span>`;
                    if (owner.type === 'fizyczna') ownerDetailsHTML += `<span class="text-gray-400">Wiek:</span><span>${owner.age || 'Brak'}</span><span class="text-gray-400">Zaw√≥d:</span><span>${owner.profession || 'Brak'}</span>`;
                    else if (owner.type === 'prawna') ownerDetailsHTML += `<span class="text-gray-400">Forma Prawna:</span><span>${owner.legalForm || 'Brak'}</span>`;
                    ownerDetailsHTML += '</div>';
                }
                const rentedLocalsHTML = rentedLocals.map(l => `<div class="bg-gray-700 p-2 rounded-md"><div data-local-id="${l.id}" class="cursor-pointer">
        <div class="font-semibold text-purple-400">Lokal #${l.klatka ? l.klatka + '/' : ''}${l.localNum} w ${l.plotName}</div><div class="text-xs text-gray-400">Powierzchnia: ${l.area} m¬≤</div></div>
        <div class="mt-2 text-xs text-gray-400">Wynajmowane od:</div>${createOwnerCardHTML(allPlots.find(p => p.name === l.plotName)?.owner)}</div>`).join('');

                const logoutButtonHTML = (currentUser && currentUser.name === ownerName) ?
                    `<button id="modal-logout-button" class="w-full mt-4 bg-red-800 text-white px-4 py-2 rounded-lg border border-red-600 hover:bg-red-700 transition-colors">Wyloguj siƒô</button>` : '';

                return `<div class="space-y-4">${createOwnerCardHTML(ownerName, true)}
        ${ownerDetailsHTML ? `<div class="pt-3 border-t border-gray-700">${ownerDetailsHTML}</div>` : ''}
        <div><h4 class="font-semibold text-md mb-2">Posiadane Dzia≈Çki (${ownedPlots.length})</h4>
            <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-sm"><span class="text-gray-400">≈ÅƒÖczna pow.:</span><span>${totalPlotArea.toLocaleString()} m¬≤</span></div>
            ${ownedPlots.length > 0 ? `<div class="space-y-2 mt-2">${ownedPlots.map(p => createPlotListItemHTML(p)).join('')}</div>` : ''}</div>
        <div class="border-t border-gray-700 pt-3"><h4 class="font-semibold text-md mb-1">Wynajmowane Lokale (${rentedLocals.length})</h4>
            ${rentedLocals.length > 0 ? `<div class="space-y-2 mt-2">${rentedLocalsHTML}</div>` : '<p class="text-gray-500 text-sm">Brak</p>'}</div>
        ${logoutButtonHTML}
        </div>`;
            }

            function renderDistrictContent(districtName, plotsInDistrict) {
                const totalArea = plotsInDistrict.reduce((sum, p) => sum + (parseInt(p.area) || 0), 0);
                return `<div><h3 class="text-2xl font-bold text-purple-400">${districtName}</h3></div>
        <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm border-b border-gray-700 pb-3 mb-3">
            <span>Liczba dzia≈Çek:</span><span class="font-medium">${plotsInDistrict.length}</span>
            <span>≈ÅƒÖczna powierzchnia:</span><span class="font-medium">${totalArea.toLocaleString()} m¬≤</span></div>
        <div class="space-y-2 mb-4">${plotsInDistrict.map(p => createPlotListItemHTML(p)).join('')}</div>`;
            }

            function renderStreetContent(streetName) {
                const street = streets.find(s => s.name === streetName);
                if (!street) return '<p>Nie znaleziono ulicy.</p>';
                const plotsOnStreet = allPlots.filter(p => p.street === streetName);
                const length = street.width > street.height ? street.width : street.height;
                return `<div><h3 class="text-2xl font-bold text-blue-400">${streetName}</h3></div>
        <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm border-b border-gray-700 pb-3 mb-3">
            <span>D≈Çugo≈õƒá:</span><span class="font-medium">${length} m</span>
            <span>Liczba dzia≈Çek:</span><span class="font-medium">${plotsOnStreet.length}</span></div>
        <div class="space-y-2 mb-4">${plotsOnStreet.map(p => createPlotListItemHTML(p)).join('')}</div>`;
            }

            function renderPlotTypeContent(typeName) {
                const plotsOfType = allPlots.filter(p => p.type === typeName);
                const plotNames = new Set(plotsOfType.map(p => p.name));
                const localsOnPlots = allLocals.filter(l => plotNames.has(l.plotName));
                const totalArea = plotsOfType.reduce((s, p) => s + (parseInt(p.area) || 0), 0);
                const totalLocals = localsOnPlots.length;
                const totalWorkplaces = localsOnPlots.reduce((s, l) => s + l.workplaces, 0);
                const totalBeds = localsOnPlots.reduce((s, l) => s + l.beds, 0);
                const typeColorDot = `<span class="inline-block w-3 h-3 rounded-full mr-2" style="background-color: ${getColorForType(typeName, 1)}"></span>`;

                return `<div><h3 class="text-2xl font-bold flex items-center">${typeColorDot} ${typeName}</h3></div>
        <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm border-b border-gray-700 pb-3 mb-3">
            <span>Liczba dzia≈Çek:</span><span class="font-medium">${plotsOfType.length}</span>
            <span>≈ÅƒÖczna powierzchnia:</span><span class="font-medium">${totalArea.toLocaleString()} m¬≤</span>
            <span>Liczba lokali:</span><span class="font-medium">${totalLocals}</span>
            <span>Miejsca pracy:</span><span class="font-medium">${totalWorkplaces}</span>
            <span>Ilo≈õƒá ≈Ç√≥≈ºek:</span><span class="font-medium">${totalBeds}</span>
        </div>
        <div class="space-y-2 mb-4">${plotsOfType.map(p => createPlotListItemHTML(p)).join('')}</div>`;
            }

            function dimOtherPlots(plotsToShow = []) {
                // Najpierw usu≈Ñ istniejƒÖce przyciemnienie, ale zostaw pod≈õwietlenie wyszukiwania
                svg.querySelectorAll('.plot-rect.dimmed').forEach(rect => rect.classList.remove('dimmed'));

                // Je≈õli lista jest pusta, po prostu czy≈õcimy i ko≈Ñczymy
                if (plotsToShow.length === 0) return;

                const plotNamesToShow = new Set(plotsToShow.map(p => p.name));

                svg.querySelectorAll('.plot-rect').forEach(rect => {
                    const g = rect.parentElement;
                    // Sprawd≈∫, czy dzia≈Çka NIE jest na li≈õcie do pokazania
                    if (!plotNamesToShow.has(g.dataset.plotName)) {
                        rect.classList.add('dimmed');
                    }
                });
            }

            function createChart(canvasId, type, chartData, label) {
                const ctx = document.getElementById(canvasId);
                if (!ctx) return;
                if (chartData.data.length === 0) {
                    ctx.parentElement.innerHTML = `<div class="flex items-center justify-center h-full text-gray-500">Brak danych</div>`;
                    return;
                }
                const chart = new Chart(ctx, {
                    type: type,
                    data: {
                        labels: chartData.labels,
                        datasets: [{
                            label: label,
                            data: chartData.data,
                            backgroundColor: chartData.colors || chartData.labels.map((_, i) => `hsl(${(i * 137.5) % 360}, 50%, 60%)`),
                            borderColor: '#1f2937',
                            borderWidth: 1
                        }]
                    },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: type === 'bar' ? 'top' : 'right', labels: { color: '#d1d5db' } } } }
                });
                activeCharts.push(chart);
            }

            function destroyActiveCharts() {
                activeCharts.forEach(chart => chart.destroy());
                activeCharts = [];
            }

            function hideTooltip() { tooltip.classList.add('hidden'); }
            function moveTooltip(e) {
                const PADDING = 20; let x = e.clientX + PADDING; let y = e.clientY + PADDING;
                if (x + tooltip.offsetWidth > window.innerWidth) x = e.clientX - tooltip.offsetWidth - PADDING;
                if (y + tooltip.offsetHeight > window.innerHeight) y = e.clientY - tooltip.offsetHeight - PADDING;
                tooltip.style.left = `${x}px`; tooltip.style.top = `${y}px`;
            }

            function findAndCenter(item) {
                clearHighlight();
                let targetPlots = [];
                if (item.type === 'plot') {
                    const plot = allPlots.find(p => p.name === item.value);
                    if (plot) { targetPlots.push(plot); openNewModal({ type: 'plot', data: plot }); }
                } else if (item.type === 'owner') {
                    targetPlots = allPlots.filter(p => p.owner === item.value);
                    openNewModal({ type: 'owner', data: item.value });
                } else if (item.type === 'street') {
                    targetPlots = allPlots.filter(p => p.street === item.value);
                    openNewModal({ type: 'street', data: item.value });
                } else if (item.type === 'address' || item.type === 'local_address') {
                    const [addressPart, localNum] = item.value.split('/');

                    // Znajd≈∫ ostatniƒÖ spacjƒô, aby oddzieliƒá nazwƒô ulicy od numeru budynku/klatki
                    const lastSpaceIndex = addressPart.lastIndexOf(' ');
                    const street = addressPart.substring(0, lastSpaceIndex);
                    const buildingAndStaircase = addressPart.substring(lastSpaceIndex + 1);

                    if (item.type === 'local_address') {
                        const local = allLocals.find(l => l.street === street && (l.building + (l.klatka || '')) === buildingAndStaircase && l.localNum === localNum);
                        if (local) {
                            const plot = allPlots.find(p => p.name === local.plotName);
                            if (plot) {
                                targetPlots.push(plot);
                                openNewModal({ type: 'plot', data: plot });
                                navigateToModal({ type: 'local', data: local });
                            }
                        }
                    } else { // address
                        const plot = allPlots.find(p => p.street === street && p.buildingNumber === buildingAndStaircase);
                        if (plot) {
                            targetPlots.push(plot);
                            openNewModal({ type: 'plot', data: plot });
                        }
                    }
                }

                if (targetPlots.length > 0) {
                    const minX = Math.min(...targetPlots.map(p => p.x1)), maxX = Math.max(...targetPlots.map(p => p.x2));
                    const minZ = Math.min(...targetPlots.map(p => p.z1)), maxZ = Math.max(...targetPlots.map(p => p.z2));
                    const centerX = minX + (maxX - minX) / 2, centerZ = minZ + (maxZ - minZ) / 2;
                    const contentWidth = Math.max(300, (maxX - minX) * 1.5), newH = (contentWidth / initialViewBox.w) * initialViewBox.h;
                    setViewBox(centerX - contentWidth / 2, centerZ - newH / 2, contentWidth, newH);
                    targetPlots.forEach(plot => highlightPlot(plot.id));
                }
                searchInput.value = '';
                searchSuggestions.classList.add('hidden');
            }

            function highlightPlot(plotId) {
                const plotElement = svg.querySelector(`g[data-plot-id='${plotId}'] .plot-rect`);
                if (plotElement) plotElement.classList.add('highlighted');
            }

            function toggleLayer(layerName) {
                layerVisibility[layerName] = !layerVisibility[layerName];
                document.getElementById(`${layerName}-layer`).classList.toggle('hidden-layer', !layerVisibility[layerName]);
                document.getElementById(`toggle-${layerName}`).classList.toggle('active', layerVisibility[layerName]);
            }

            function addModalEventListeners() {
                modalContent.querySelectorAll('[data-plot-name]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    const plot = allPlots.find(p => p.name === e.currentTarget.dataset.plotName);
                    if (plot) navigateToModal({ type: 'plot', data: plot });
                }));
                modalContent.querySelectorAll('[data-local-id]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    const local = allLocals.find(l => l.id === e.currentTarget.dataset.localId);
                    if (local) navigateToModal({ type: 'local', data: local });
                }));
                modalContent.querySelectorAll('[data-owner-name]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    const ownerName = e.currentTarget.dataset.ownerName;
                    if (ownerName && ownerName.toLowerCase() !== 'skarb miasta' && ownerName.toLowerCase() !== 'brak') {
                        navigateToModal({ type: 'owner', data: ownerName });
                    }
                }));
                modalContent.querySelectorAll('[data-district-name]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    const districtName = e.currentTarget.dataset.districtName;
                    if (!districtName) return;
                    const plotsInDistrict = allPlots.filter(p => p.district === districtName);
                    if (plotsInDistrict.length > 0) navigateToModal({ type: 'district', data: { name: districtName, plots: plotsInDistrict } });
                }));
                modalContent.querySelectorAll('[data-street-name]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    navigateToModal({ type: 'street', data: e.currentTarget.dataset.streetName });
                }));
                modalContent.querySelectorAll('[data-plot-type]').forEach(el => el.addEventListener('click', e => {
                    e.preventDefault();
                    navigateToModal({ type: 'plotType', data: e.currentTarget.dataset.plotType });
                }));

                // Listener dla przycisku wylogowania w modalu
                const modalLogoutButton = document.getElementById('modal-logout-button');
                if (modalLogoutButton) {
                    modalLogoutButton.addEventListener('click', () => {
                        closeModal();
                        logoutUser();
                    });
                }
            }

            searchInput.addEventListener('input', () => {
                const query = searchInput.value.trim().toLowerCase();
                searchSuggestions.innerHTML = '';
                if (!query) { searchSuggestions.classList.add('hidden'); return; }
                const suggestions = [];

                // Dzia≈Çki
                allPlots.filter(p => p.name.toLowerCase().includes(query) || p.id.includes(query)).slice(0, 3)
                    .forEach(p => suggestions.push({ type: 'plot', label: `Dzia≈Çka: ${p.name}`, value: p.name }));
                // W≈Ça≈õciciele
                [...new Set(allPlots.map(p => p.owner))].filter(o => o && o.toLowerCase().includes(query)).slice(0, 2)
                    .forEach(o => suggestions.push({ type: 'owner', label: `W≈Ça≈õciciel: ${o}`, value: o }));
                // Ulice
                [...new Set(streets.map(s => s.name))].filter(s => s && s.toLowerCase().includes(query)).slice(0, 2)
                    .forEach(s => suggestions.push({ type: 'street', label: `Ulica: ${s}`, value: s }));
                // Adresy Lokali
                allLocals.filter(l => {
                    const fullAddress = `${l.street.toLowerCase()} ${l.building}${l.klatka || ''}/${l.localNum}`;
                    return l.street && l.building && l.localNum && fullAddress.includes(query);
                }).slice(0, 3)
                    .forEach(l => {
                        const address = `${l.street} ${l.building}${l.klatka || ''}/${l.localNum}`;
                        suggestions.push({ type: 'local_address', label: `Lokal: ${address}`, value: address });
                    });
                // Adresy
                allPlots.filter(p => p.street && p.buildingNumber && `${p.street.toLowerCase()} ${p.buildingNumber}`.includes(query)).slice(0, 3)
                    .forEach(p => {
                        const address = `${p.street} ${p.buildingNumber}`;
                        suggestions.push({ type: 'address', label: `Adres: ${address}`, value: address });
                    });

                if (suggestions.length > 0) {
                    suggestions.forEach(s => {
                        const div = document.createElement('div');
                        div.className = 'p-2 hover:bg-purple-600 cursor-pointer';
                        div.textContent = s.label;
                        div.addEventListener('click', () => findAndCenter(s));
                        searchSuggestions.appendChild(div);
                    });
                    searchSuggestions.classList.remove('hidden');
                } else {
                    searchSuggestions.classList.add('hidden');
                }
            });

            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target)) {
                    searchSuggestions.classList.add('hidden');
                }
            });

            searchButton.addEventListener('click', () => {
                const firstSuggestion = searchSuggestions.querySelector('div');
                if (firstSuggestion) firstSuggestion.click();
            });
            searchInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    const firstSuggestion = searchSuggestions.querySelector('div');
                    if (firstSuggestion) firstSuggestion.click();
                }
            });

            // Pozosta≈Çe listenery
            mapContainer.addEventListener('mousedown', (e) => { if (e.button === 0) { isPanning = true; mapContainer.classList.add('grabbing'); startPoint = { x: e.x, y: e.y }; } });
            document.addEventListener('mouseup', () => { isPanning = false; mapContainer.classList.remove('grabbing'); });
            mapContainer.addEventListener('mousemove', (e) => {
                // Obliczanie koordynat√≥w SVG na podstawie pozycji kursora
                const pt = svg.createSVGPoint();
                pt.x = e.clientX;
                pt.y = e.clientY;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

                // Aktualizuj wy≈õwietlacz tylko na urzƒÖdzeniach niedotykowych
                if (!('ontouchstart' in window)) {
                    coordsDisplay.textContent = `X: ${Math.round(svgP.x)}, Z: ${Math.round(svgP.y)}`;
                }

                // Logika przesuwania mapy (pozostaje bez zmian)
                if (!isPanning) return;
                if (Math.abs(e.x - startPoint.x) > 5 || Math.abs(e.y - startPoint.y) > 5) {
                    isDragging = true;
                }
                const dx = (startPoint.x - e.x) * (viewBox.w / mapContainer.clientWidth);
                const dy = (startPoint.y - e.y) * (viewBox.h / mapContainer.clientHeight);
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                startPoint = { x: e.x, y: e.y };
            });
            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const w = viewBox.w; const h = viewBox.h; const mx = e.offsetX; const my = e.offsetY;
                const dw = w * -Math.sign(e.deltaY) * 0.1; const dh = h * -Math.sign(e.deltaY) * 0.1;
                const dx = dw * mx / mapContainer.clientWidth; const dy = dh * my / mapContainer.clientHeight;
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w - dw, viewBox.h - dh);
            }, { passive: false });

            closeModalBtn.addEventListener('click', closeModal);
            document.getElementById('back-modal').addEventListener('click', goBackModal);
            mapContainer.addEventListener('click', (e) => { if (e.target === mapContainer || e.target === svg || e.target.id === 'map-svg') closeModal(); });
            document.getElementById('zoom-in').addEventListener('click', () => { const dw = viewBox.w * -0.2; setViewBox(viewBox.x - dw / 2, viewBox.y - (dw / initialViewBox.w * initialViewBox.h) / 2, viewBox.w + dw, viewBox.h + (dw / initialViewBox.w * initialViewBox.h)); });
            document.getElementById('zoom-out').addEventListener('click', () => { const dw = viewBox.w * 0.2; setViewBox(viewBox.x - dw / 2, viewBox.y - (dw / initialViewBox.w * initialViewBox.h) / 2, viewBox.w + dw, viewBox.h + (dw / initialViewBox.w * initialViewBox.h)); });
            document.getElementById('reset-view').addEventListener('click', () => { setViewBox(initialViewBox.x, initialViewBox.y, initialViewBox.w, initialViewBox.h); });
            document.getElementById('toggle-plots').addEventListener('click', () => toggleLayer('plots'));
            document.getElementById('toggle-streets').addEventListener('click', () => toggleLayer('streets'));
            document.getElementById('toggle-districts').addEventListener('click', () => toggleLayer('districts'));
            document.getElementById('toggle-merged').addEventListener('click', () => toggleLayer('merged'));

            // --- OBS≈ÅUGA INTERAKJI Z MAPƒÑ (MYSZ I DOTYK) ---
            let touchPanning = false;
            let pinchZooming = false;
            let lastTouchDistance = 0;

            mapContainer.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    isDragging = false;
                    isPanning = true;
                    mapContainer.classList.add('grabbing');
                    startPoint = { x: e.x, y: e.y };
                }
            });
            document.addEventListener('mouseup', () => {
                isPanning = false;
                mapContainer.classList.remove('grabbing');
                setTimeout(() => { isDragging = false; }, 50);
            });
            mapContainer.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                if (Math.abs(e.x - startPoint.x) > 5 || Math.abs(e.y - startPoint.y) > 5) {
                    isDragging = true;
                }
                const dx = (startPoint.x - e.x) * (viewBox.w / mapContainer.clientWidth);
                const dy = (startPoint.y - e.y) * (viewBox.h / mapContainer.clientHeight);
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                startPoint = { x: e.x, y: e.y };
            });
            mapContainer.addEventListener('wheel', (e) => { e.preventDefault(); const dw = viewBox.w * -Math.sign(e.deltaY) * 0.1; const dx = dw * e.offsetX / mapContainer.clientWidth; const dy = (dw / initialViewBox.w * initialViewBox.h) * e.offsetY / mapContainer.clientHeight; setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w - dw, viewBox.h - (dw / initialViewBox.w * initialViewBox.h)); }, { passive: false });
            mapContainer.addEventListener('touchstart', (e) => {
                isDragging = false;
                if (e.touches.length === 1) {
                    touchPanning = true;
                    startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length >= 2) {
                    pinchZooming = true;
                    touchPanning = false;
                    lastTouchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                }
            }, { passive: true });
            mapContainer.addEventListener('touchmove', (e) => {
                if (Math.abs(e.touches[0].clientX - startPoint.x) > 5 || Math.abs(e.touches[0].clientY - startPoint.y) > 5) {
                    isDragging = true;
                }
                if (touchPanning && e.touches.length === 1) {
                    const dx = (startPoint.x - e.touches[0].clientX) * (viewBox.w / mapContainer.clientWidth);
                    const dy = (startPoint.y - e.touches[0].clientY) * (viewBox.h / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                    startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (pinchZooming && e.touches.length >= 2) {
                    const newDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const scale = lastTouchDistance / newDist;
                    const w = viewBox.w * scale, h = viewBox.h * scale;
                    const { left, top } = mapContainer.getBoundingClientRect();
                    const centerX = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - left;
                    const centerY = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - top;
                    const dx = (viewBox.w - w) * (centerX / mapContainer.clientWidth);
                    const dy = (viewBox.h - h) * (centerY / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, w, h);
                    lastTouchDistance = newDist;
                }
            }, { passive: true });
            mapContainer.addEventListener('touchend', (e) => {
                touchPanning = false;
                pinchZooming = false;
                setTimeout(() => { isDragging = false; }, 50);
            });

            const loginButton = document.getElementById('login-button');
            const profileButton = document.getElementById('profile-button');
            const profilePic = document.getElementById('profile-pic');
            const loginModal = document.getElementById('login-modal');
            const closeLoginModalButton = document.getElementById('close-login-modal');
            const loginForm = document.getElementById('login-form');
            const loginError = document.getElementById('login-error');

            function attemptAutoLogin() {
                const savedIdentifier = localStorage.getItem('userIdentifier');
                const savedPIN = localStorage.getItem('userPIN');

                if (savedIdentifier && savedPIN) {
                    loginUser(savedIdentifier, savedPIN, true);
                }
            }

            function loginUser(identifier, pin, isAutoLogin = false) {
                const identifierLower = identifier.toLowerCase();
                const user = allOwners.find(o =>
                    o.pin === pin &&
                    o.type === 'fizyczna' &&
                    (o.nio === identifier || o.name.toLowerCase() === identifierLower)
                );

                if (user) {
                    currentUser = user;
                    localStorage.setItem('userIdentifier', user.nio || user.name);
                    localStorage.setItem('userPIN', user.pin);

                    loginModal.classList.add('hidden');
                    loginButton.classList.add('hidden');

                    profilePic.src = user.photo || 'placeholder.webp';
                    profileButton.classList.remove('hidden');

                    loginError.classList.add('hidden');
                    loginForm.reset();

                    if (modalHistory.length > 0) {
                        renderCurrentModal();
                    }
                } else if (!isAutoLogin) {
                    loginError.textContent = 'Nieprawid≈Çowe dane logowania.';
                    loginError.classList.remove('hidden');
                }
            }

            function logoutUser() {
                currentUser = null;
                localStorage.removeItem('userIdentifier');
                localStorage.removeItem('userPIN');

                loginButton.classList.remove('hidden');
                profileButton.classList.add('hidden');
                profilePic.src = 'placeholder.webp';

                if (modalHistory.length > 0) {
                    renderCurrentModal();
                }
            }

            loginButton.addEventListener('click', () => {
                loginModal.classList.remove('hidden');
            });

            profileButton.addEventListener('click', () => {
                if (currentUser) {
                    openNewModal({ type: 'owner', data: currentUser.name });
                }
            });

            closeLoginModalButton.addEventListener('click', () => {
                loginModal.classList.add('hidden');
                loginError.classList.add('hidden');
            });

            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const identifier = e.target.loginIdentifier.value;
                const pin = e.target.pin.value;
                loginUser(identifier, pin);
            });

            // --- NOWE FUNKCJE LOTERII ---
            const lotteryButton = document.getElementById('lottery-button');
            const lotteryOverlay = document.getElementById('lottery-overlay');
            const closeLotteryButton = document.getElementById('close-lottery-button');
            const wheelCanvas = document.getElementById('wheelCanvas');
            const spinButton = document.getElementById('spin-button');
            const lotteryResult = document.getElementById('lottery-result');

            function setupLottery() {
                if (!lotterySettings.plot_lottery_enabled) return;

                physicalPersons = allOwners.filter(o => o.type === 'fizyczna');
                const lotteryHistoryPlots = new Set(lotteryHistory.map(l => l.plotName));

                const legalEntityOwners = new Set(allOwners.filter(o => o.type === 'prawna' && o.name !== 'Skarb Miasta Amoguszowice').map(o => o.name));

                eligibleForLottery = allPlots.filter(plot => {
                    if (lotteryHistoryPlots.has(plot.name)) return false;

                    // Znajd≈∫ ostatniƒÖ OP≈ÅACONƒÑ transakcjƒô
                    const lastPaidTransaction = [...plot.history].reverse().find(t => t.paid);
                    if (!lastPaidTransaction || lastPaidTransaction.type !== 'Darowizna') return false;

                    // Sprawd≈∫, kto by≈Ç darczy≈ÑcƒÖ w tej transakcji. Darczy≈Ñca to w≈Ça≈õciciel z poprzedniej transakcji.
                    const transactionIndex = plot.history.findIndex(h => h.date === lastPaidTransaction.date && h.newOwner === lastPaidTransaction.newOwner);
                    const donorName = (transactionIndex > 0) ? plot.history[transactionIndex - 1].newOwner : 'Skarb Miasta';

                    return legalEntityOwners.has(donorName);
                });

                if (eligibleForLottery.length > 0) {
                    lotteryButton.classList.remove('hidden');
                }
            }

            lotteryButton.addEventListener('click', () => {
                lotteryOverlay.classList.remove('hidden');
                drawWheel();
                spinButton.disabled = !(currentUser && currentUser.staff);
            });
            closeLotteryButton.addEventListener('click', () => lotteryOverlay.classList.add('hidden'));

            function drawWheel() {
                const ctx = wheelCanvas.getContext('2d');
                const numOptions = eligibleForLottery.length;
                if (numOptions === 0) return;
                const arcSize = 2 * Math.PI / numOptions;
                const radius = wheelCanvas.width / 2;

                ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = 2;

                for (let i = 0; i < numOptions; i++) {
                    const angle = i * arcSize;
                    ctx.beginPath();
                    ctx.fillStyle = i % 2 === 0 ? '#4f46e5' : '#7c3aed';
                    ctx.moveTo(radius, radius);
                    ctx.arc(radius, radius, radius - 5, angle, angle + arcSize);
                    ctx.lineTo(radius, radius);
                    ctx.fill();
                    ctx.stroke();

                    ctx.save();
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Inter';
                    ctx.translate(radius + Math.cos(angle + arcSize / 2) * (radius * 0.7), radius + Math.sin(angle + arcSize / 2) * (radius * 0.7));
                    ctx.rotate(angle + arcSize / 2 + Math.PI / 2);
                    ctx.fillText(eligibleForLottery[i].name, -ctx.measureText(eligibleForLottery[i].name).width / 2, 0);
                    ctx.restore();
                }
            }

            function spinWheel() {
                if (eligibleForLottery.length === 0) return;
                spinButton.disabled = true;
                const numOptions = eligibleForLottery.length;
                const degrees = Math.random() * 360 + 360 * 5; // min 5 obrot√≥w
                const currentRotation = parseFloat(wheelCanvas.style.transform.replace(/[^0-9.-]/g, '')) || 0;
                wheelCanvas.style.transform = `rotate(${currentRotation + degrees}deg)`;

                setTimeout(() => {
                    const finalAngle = (currentRotation + degrees) % 360;
                    const winningIndex = Math.floor(numOptions - (finalAngle / (360 / numOptions))) % numOptions;
                    const winningPlot = eligibleForLottery[winningIndex];

                    const winner = physicalPersons[nextWinnerIndex % physicalPersons.length];
                    nextWinnerIndex++;

                    showLotteryResult(winningPlot, winner);
                }, 5100);
            }

            spinButton.addEventListener('click', spinWheel);

            function showLotteryResult(plot, winner) {
                lotteryResult.innerHTML = `
                    <div class="space-y-4">
                        <h2 class="text-4xl font-bold text-yellow-400">Gratulacje!</h2>
                        <p class="text-2xl">${winner.name}</p>
                        <p class="text-lg">wygrywa dzia≈Çkƒô</p>
                        <p class="text-3xl font-bold text-purple-400">${plot.name}</p>
                        <button id="close-result-button" class="mt-8 bg-purple-600 text-white font-bold py-2 px-6 rounded-lg">OK</button>
                    </div>
                `;
                lotteryResult.classList.remove('hidden');

                for (let i = 0; i < 100; i++) { createConfetti(); }

                document.getElementById('close-result-button').addEventListener('click', () => {
                    lotteryResult.classList.add('hidden');
                    lotteryOverlay.classList.add('hidden');
                    spinButton.disabled = !(currentUser && currentUser.staff);
                });
            }

            function createConfetti() {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.animationDuration = `${Math.random() * 1 + 1}s`;
                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                lotteryResult.appendChild(confetti);
                setTimeout(() => confetti.remove(), 2000);
            }

            fetchAllData();
        });
    </script>
</body>

</html>