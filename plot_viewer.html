<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>System Dziaek Minecraft</title>
    <link rel="icon" type="image/x-icon" href="Red.ico">
    <script src="[https://cdn.tailwindcss.com](https://cdn.tailwindcss.com)"></script>
    <script
        src="[https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js](https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js)"></script>
    <script src="[https://cdn.jsdelivr.net/npm/chart.js](https://cdn.jsdelivr.net/npm/chart.js)"></script>
    <link
        href="[https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap](https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap)"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        #map-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        #map-svg {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111827;
        }

        .plot-rect {
            stroke-width: 0.5;
            transition: fill 0.2s ease-in-out, fill-opacity 0.3s ease-in-out, filter 0.3s ease-in-out, stroke 0.3s, stroke-width 0.3s;
        }

        .plot-rect:hover {
            fill-opacity: 0.7;
        }

        .plot-rect.dimmed {
            fill-opacity: 0.2 !important;
            filter: grayscale(80%);
        }

        .plot-rect.highlighted {
            fill-opacity: 1 !important;
            filter: brightness(1.2);
            stroke: #facc15;
            /* yellow-400 */
            stroke-width: 1.5;
        }

        .street-rect {
            fill: #4b5563;
            /* gray-600 */
            fill-opacity: 0.9;
            stroke: transparent;
            /* No stroke by default */
            stroke-width: 0.25;
            transition: fill-opacity 0.2s, stroke 0.2s;
        }

        .street-rect:hover {
            fill-opacity: 0.7;
            stroke: #9ca3af;
            /* Add stroke on hover */
        }

        .merged-plot {
            stroke: #f59e0b;
            stroke-width: 1.5;
            stroke-dasharray: 4, 2;
            fill: none;
            pointer-events: all;
            cursor: pointer;
        }

        .plot-text {
            font-size: 4px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 0.5px;
            stroke-linecap: butt;
            stroke-linejoin: miter;
        }

        .street-text {
            font-size: 3px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .street-text.street-vertical {
            writing-mode: vertical-rl;
            /* Vertical text for vertical streets */
        }

        #tooltip {
            background-color: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid #4b5563;
            transition: opacity 0.2s ease-in-out;
        }

        #modal {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }

        #modal.show {
            transform: translateX(0);
        }

        .grab {
            cursor: grab;
        }

        .grabbing {
            cursor: grabbing;
        }

        .toggle-button {
            opacity: 0.5;
            border: 1px solid #4b5563;
        }

        .toggle-button.active {
            opacity: 1;
            background-color: #4338ca;
            /* indigo-700 */
            border-color: #6d28d9;
            /* purple-700 */
        }

        .hidden-layer {
            display: none;
        }

        .chart-container {
            height: 200px;
            width: 100%;
        }

        .clickable-name {
            cursor: pointer;
            text-decoration: underline;
            text-underline-offset: 2px;
        }

        .clickable-name:hover {
            color: #a78bfa;
            /* purple-400 */
        }

        @media (max-width: 768px) {
            #tooltip {
                font-size: 12px;
                max-width: 90vw;
                max-height: 50vh;
                overflow-y: auto;
            }

            .plot-text {
                font-size: 3px;
            }

            .controls {
                bottom: 10px !important;
                right: 10px !important;
            }

            .control-button {
                width: 44px;
                height: 44px;
            }

            #modal {
                width: 100vw;
            }
        }
    </style>
</head>

<body class="bg-gray-900 text-white">

    <!-- Search Bar -->
    <div class="absolute top-5 left-5 z-30">
        <div class="flex bg-gray-800 rounded-lg border border-gray-600 shadow-lg">
            <input type="text" id="search-input" placeholder="Wyszukaj (np. D4/021 lub 21)"
                class="bg-transparent text-white px-4 py-2 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-purple-500 w-48 md:w-auto"
                maxlength="15">
            <button id="search-button"
                class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-r-lg transition-colors"></button>
        </div>
    </div>

    <!-- Main container for the map -->
    <div id="map-container" class="grab">
        <svg id="map-svg"></svg>
    </div>

    <!-- Simple Tooltip -->
    <div id="tooltip" class="hidden absolute p-2 rounded-lg shadow-xl text-sm z-40 pointer-events-none"></div>

    <!-- Right Side Modal -->
    <div id="modal"
        class="fixed top-0 right-0 w-full md:w-96 h-full bg-gray-800 border-l border-gray-600 shadow-2xl z-50 overflow-y-auto">
        <div class="p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 id="modal-title" class="text-xl font-bold">Szczeg贸y</h2><button id="close-modal"
                    class="text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>
            <div id="modal-content" class="space-y-4"></div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loader" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50">
        <div class="text-center">
            <svg class="animate-spin h-8 w-8 text-white mx-auto mb-3"
                xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                </path>
            </svg>
            <p class="text-lg font-medium">Pobieranie danych...</p>
            <p class="text-sm text-gray-400">Prosz czeka</p>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls absolute flex flex-col items-end z-30" style="bottom: 20px; right: 20px;">
        <div class="flex flex-col space-y-2">
            <button id="zoom-in"
                class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600"
                title="Powiksz"><svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" width="20"
                    height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg></button>
            <button id="zoom-out"
                class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600"
                title="Pomniejsz"><svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" width="20"
                    height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg></button>
            <button id="reset-view"
                class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600"
                title="Resetuj widok"><svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" width="20"
                    height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 2v6h6"></path>
                    <path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path>
                    <path d="M21 22v-6h-6"></path>
                    <path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path>
                </svg></button>
        </div>
        <div id="layer-toggles" class="mt-2 flex flex-col space-y-2">
            <button id="toggle-plots"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka偶/Ukryj Dziaki"><svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)"
                    width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                </svg></button>
            <button id="toggle-streets"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka偶/Ukryj Ulice"><svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)"
                    width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <line x1="4" y1="20" x2="4" y2="4"></line>
                    <line x1="20" y1="20" x2="20" y2="4"></line>
                    <line x1="12" y1="4" x2="12" y2="20"></line>
                </svg></button>
            <button id="toggle-districts"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka偶/Ukryj Dzielnice"><svg xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)"
                    width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg></button>
            <button id="toggle-merged"
                class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700"
                title="Poka偶/Ukryj Poczone Dziaki"><svg
                    xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)" width="20" height="20"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                </svg></button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const SHEET_ID = '1swtElpz27sqLMNbATocFe9VHc1yZTSRxvHyikFL_R7U';
            const PLOTS_GID = '0';
            const MERGED_GID = '43897086';
            const STREETS_GID = '2101138806';
            const LOCALS_GID = '875214507'; // New GID for locals

            const PLOTS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${PLOTS_GID}`;
            const MERGED_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${MERGED_GID}`;
            const STREETS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${STREETS_GID}`;
            const LOCALS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${LOCALS_GID}`;

            const MAP_IMAGE_URL = 'map.png';
            const MAP_WIDTH = 4296;
            const MAP_HEIGHT = 2360;

            const svg = document.getElementById('map-svg');
            const tooltip = document.getElementById('tooltip');
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContent = document.getElementById('modal-content');
            const loader = document.getElementById('loader');
            const mapContainer = document.getElementById('map-container');
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const closeModalBtn = document.getElementById('close-modal');

            let viewBox = { x: 0, y: 0, w: 0, h: 0 };
            let mapBounds = { minX: -MAP_WIDTH / 2, maxX: MAP_WIDTH / 2, minY: -MAP_HEIGHT / 2, maxY: MAP_HEIGHT / 2 };
            let isPanning = false;
            let startPoint = { x: 0, y: 0 };
            let lastTouchDistance = 0;
            const initialViewBox = {};
            let layerVisibility = { plots: true, streets: true, districts: true, merged: true };
            let touchStartInfo = { time: 0, x: 0, y: 0 };
            let activeCharts = [];

            let allPlots = [];
            let allLocals = [];
            let mergedPlots = [];
            let streets = [];

            const layers = {
                districts: document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'g'),
                merged: document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'g'),
                streets: document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'g'),
                plots: document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'g')
            };

            function setViewBox(x, y, w, h) {
                const isMobile = window.innerWidth <= 768;
                const minZoom = isMobile ? 50 : 100;
                const maxZoom = Math.max(MAP_WIDTH, MAP_HEIGHT) * 2;

                w = Math.max(minZoom, Math.min(w, maxZoom));
                if (initialViewBox.w) {
                    h = (w / initialViewBox.w) * initialViewBox.h;
                }

                if (x < mapBounds.minX) x = mapBounds.minX;
                if (y < mapBounds.minY) y = mapBounds.minY;
                if (x + w > mapBounds.maxX) x = mapBounds.maxX - w;
                if (y + h > mapBounds.maxY) y = mapBounds.maxY - h;

                viewBox = { x, y, w, h };
                svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
            }

            function getColorForType(type, alpha = 0.8) {
                switch (type) {
                    case 'Parkowa': return `rgba(0, 170, 0, ${alpha})`;
                    case 'Rolna': return `rgba(180, 104, 77, ${alpha})`;
                    case 'Hotelowa': return `rgba(44, 186, 168, ${alpha})`;
                    case 'Mieszkalna': return `rgba(222, 177, 45, ${alpha})`;
                    case 'Sakralna': return `rgba(154, 92, 198, ${alpha})`;
                    case 'Przemysowo-biurowa': return `rgba(255, 85, 255, ${alpha})`;
                    case 'Mieszkalno-usugowa': return `rgba(33, 73, 123, ${alpha})`;
                    case 'Publiczna': return `rgba(255, 170, 0, ${alpha})`;
                    case 'Medyczna': return `rgba(170, 0, 0, ${alpha})`;
                    case 'Usugowa': return `rgba(17, 160, 54, ${alpha})`;
                    default: return `rgba(255, 255, 255, 0.1)`;
                }
            }

            async function fetchAllData() {
                try {
                    const responses = await Promise.all([
                        fetch(PLOTS_URL), fetch(MERGED_URL), fetch(STREETS_URL), fetch(LOCALS_URL)
                    ]);

                    if (responses.some(res => !res.ok)) throw new Error('Network response was not ok');

                    const texts = await Promise.all(responses.map(res => res.text()));

                    const [plotsResult, mergedResult, streetsResult, localsResult] = await Promise.all([
                        new Promise(resolve => Papa.parse(texts[0], { header: true, skipEmptyLines: true, complete: resolve })),
                        new Promise(resolve => Papa.parse(texts[1], { header: true, skipEmptyLines: true, complete: resolve })),
                        new Promise(resolve => Papa.parse(texts[2], { header: true, skipEmptyLines: true, complete: resolve })),
                        new Promise(resolve => Papa.parse(texts[3], { header: true, skipEmptyLines: true, complete: resolve }))
                    ]);

                    allPlots = plotsResult.data.filter(p => p['Nr porzdkowy'] && p['X (lewy g贸rny)'])
                        .map(d => ({
                            id: d['Nr porzdkowy'], name: d['Nazwa porzdkowa dziaki'], type: d['Typ'],
                            x1: parseInt(d['X (lewy g贸rny)'], 10), z1: parseInt(d['Z (lewy g贸rny)'], 10),
                            x2: parseInt(d['X (prawy dolny)'], 10), z2: parseInt(d['Z (prawy dolny)'], 10),
                            width: parseInt(d['Bok X'], 10), height: parseInt(d['Bok Z'], 10), area: d['Powierzchnia'],
                            value: d['Warto'], owner: d['Aktualny waciciel'], district: d['Dzielnica'],
                            street: d['Ulica'], buildingNumber: d['Numer budynku']
                        }));

                    allLocals = localsResult.data.filter(l => l['Numer porzdkowy'] && l['Numer dziaki'])
                        .map(l => ({
                            id: l['Numer porzdkowy'], plotName: l['Numer dziaki'], street: l['Ulica'],
                            building: l['Numer budynku'], localNum: l['Numer lokalu'], floor: l['Pitro'],
                            area: parseInt(l['Powierzchnia']) || 0, beds: parseInt(l['Ilo 贸偶ek']) || 0,
                            workplaces: parseInt(l['Ilo miejsc pracy']) || 0, tenant: l['Najemca']
                        }));

                    const connections = mergedResult.data.filter(m => m['Dziaka g贸wna'] && m['Dziaka doczana'])
                        .map(d => ({ plot1: d['Dziaka g贸wna'], plot2: d['Dziaka doczana'] }));
                    mergedPlots = processMergedPlots(connections);

                    streets = streetsResult.data.filter(s => s['X (lewy g贸rny)'])
                        .map(d => ({
                            name: d['Nazwa ulicy'],
                            x1: parseInt(d['X (lewy g贸rny)'], 10), z1: parseInt(d['Z (lewy g贸rny)'], 10),
                            width: parseInt(d['X (prawy dolny)'], 10) - parseInt(d['X (lewy g贸rny)'], 10),
                            height: parseInt(d['Z (prawy dolny)'], 10) - parseInt(d['Z (lewy g贸rny)'], 10)
                        }));

                    drawMap();
                    loader.style.display = 'none';

                } catch (error) {
                    console.error("Bd podczas pobierania danych:", error);
                    loader.innerHTML = `<div class="text-center"><p class="text-lg font-medium text-red-500">Bd adowania danych</p><p class="text-sm text-gray-400">Sprawd藕 konsol.</p></div>`;
                }
            }

            function processMergedPlots(connections) {
                const adj = new Map();
                const allPlotIdsInConnections = new Set();

                connections.forEach(({ plot1, plot2 }) => {
                    if (!adj.has(plot1)) adj.set(plot1, []);
                    if (!adj.has(plot2)) adj.set(plot2, []);
                    adj.get(plot1).push(plot2);
                    adj.get(plot2).push(plot1);
                    allPlotIdsInConnections.add(plot1);
                    allPlotIdsInConnections.add(plot2);
                });

                const visited = new Set();
                const groups = [];

                for (const plotId of allPlotIdsInConnections) {
                    if (!visited.has(plotId)) {
                        const group = [];
                        const stack = [plotId];
                        visited.add(plotId);
                        while (stack.length > 0) {
                            const currentId = stack.pop();
                            group.push(currentId);
                            const neighbors = adj.get(currentId) || [];
                            for (const neighbor of neighbors) {
                                if (!visited.has(neighbor)) {
                                    visited.add(neighbor);
                                    stack.push(neighbor);
                                }
                            }
                        }
                        groups.push(group);
                    }
                }

                return groups.map(group => {
                    const plotsInGroup = group.map(id => allPlots.find(p => p.name === id)).filter(Boolean);
                    if (plotsInGroup.length === 0) return null;

                    const minX = Math.min(...plotsInGroup.map(p => p.x1));
                    const maxX = Math.max(...plotsInGroup.map(p => p.x2));
                    const minZ = Math.min(...plotsInGroup.map(p => p.z1));
                    const maxZ = Math.max(...plotsInGroup.map(p => p.z2));
                    const originalArea = plotsInGroup.reduce((sum, p) => sum + (parseInt(p.area) || 0), 0);
                    const mergedArea = (maxX - minX) * (maxZ - minZ);

                    return {
                        plots: group, x1: minX, z1: minZ, x2: maxX, z2: maxZ,
                        width: maxX - minX, height: maxZ - minZ, originalArea, mergedArea
                    };
                }).filter(Boolean);
            }

            function drawMap() {
                if (!allPlots.length) return;
                svg.innerHTML = '';

                const mapImage = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'image');
                mapImage.setAttribute('href', MAP_IMAGE_URL);
                mapImage.setAttribute('x', -MAP_WIDTH / 2);
                mapImage.setAttribute('y', -MAP_HEIGHT / 2);
                mapImage.setAttribute('width', MAP_WIDTH);
                mapImage.setAttribute('height', MAP_HEIGHT);
                svg.appendChild(mapImage);

                Object.values(layers).forEach(layer => layer.innerHTML = '');

                // Set layer IDs for toggling
                layers.districts.id = 'districts-layer';
                layers.merged.id = 'merged-layer';
                layers.streets.id = 'streets-layer';
                layers.plots.id = 'plots-layer';

                // Append layers in correct Z-order (bottom to top)
                svg.appendChild(layers.districts);
                svg.appendChild(layers.merged);
                svg.appendChild(layers.streets);
                svg.appendChild(layers.plots);

                drawStreets();
                drawPlots();
                drawMergedPlots();
                drawDistrictBoundaries();

                const padding = 100;
                const minX = Math.min(...allPlots.map(p => p.x1));
                const maxX = Math.max(...allPlots.map(p => p.x2));
                const minZ = Math.min(...allPlots.map(p => p.z1));
                const maxZ = Math.max(...allPlots.map(p => p.z2));

                viewBox.w = (maxX - minX) + (padding * 2);
                viewBox.h = (maxZ - minZ) + (padding * 2);
                viewBox.x = minX - padding;
                viewBox.y = minZ - padding;

                Object.assign(initialViewBox, viewBox);
                setViewBox(viewBox.x, viewBox.y, viewBox.w, viewBox.h);
            }

            function drawStreets() {
                streets.forEach(street => {
                    const g = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'g');
                    const rect = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'rect');
                    rect.setAttribute('x', street.x1); rect.setAttribute('y', street.z1);
                    rect.setAttribute('width', street.width); rect.setAttribute('height', street.height);
                    rect.setAttribute('class', 'street-rect');

                    const text = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'text');
                    text.setAttribute('x', street.x1 + street.width / 2);
                    text.setAttribute('y', street.z1 + street.height / 2);
                    text.setAttribute('class', 'street-text');
                    if (street.height > street.width) {
                        text.classList.add('street-vertical');
                    }
                    text.textContent = street.name;
                    g.appendChild(rect); g.appendChild(text);

                    g.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold">${street.name}</div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    g.addEventListener('mouseleave', hideTooltip);
                    g.addEventListener('mousemove', moveTooltip);
                    layers.streets.appendChild(g);
                });
            }

            function drawMergedPlots() {
                mergedPlots.forEach((merged) => {
                    const rect = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'rect');
                    rect.setAttribute('x', merged.x1); rect.setAttribute('y', merged.z1);
                    rect.setAttribute('width', merged.width); rect.setAttribute('height', merged.height);
                    rect.setAttribute('class', 'merged-plot');

                    rect.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold mb-1">Poczone dziaki</div><div class="text-xs">Kliknij, by zobaczy szczeg贸y</div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    rect.addEventListener('mouseleave', hideTooltip);
                    rect.addEventListener('mousemove', moveTooltip);

                    rect.addEventListener('click', (e) => { e.stopPropagation(); showMergedModal(merged); });

                    let mergedTouchStartInfo = {};
                    rect.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 1) mergedTouchStartInfo = { time: Date.now(), x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }, { passive: true });

                    rect.addEventListener('touchend', (e) => {
                        if (mergedTouchStartInfo.time) {
                            const timeDiff = Date.now() - mergedTouchStartInfo.time;
                            const dist = Math.hypot(e.changedTouches[0].clientX - mergedTouchStartInfo.x, e.changedTouches[0].clientY - mergedTouchStartInfo.y);
                            if (timeDiff < 250 && dist < 10) { e.preventDefault(); showMergedModal(merged); }
                            mergedTouchStartInfo = {};
                        }
                    });

                    layers.merged.appendChild(rect);
                });
            }

            function drawPlots() {
                allPlots.forEach(plot => {
                    const g = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'g');
                    g.dataset.plotId = plot.id;
                    g.dataset.plotName = plot.name;
                    g.dataset.plotDistrict = plot.district || '';

                    const rect = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'rect');
                    rect.setAttribute('x', plot.x1); rect.setAttribute('y', plot.z1);
                    rect.setAttribute('width', plot.width); rect.setAttribute('height', plot.height);
                    rect.setAttribute('class', 'plot-rect');
                    rect.style.fill = getColorForType(plot.type);
                    const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                    rect.style.stroke = isOwned ? '#ef4444' : '#22c55e';

                    const text = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'text');
                    text.setAttribute('x', plot.x1 + plot.width / 2);
                    text.setAttribute('y', plot.z1 + plot.height / 2);
                    text.setAttribute('class', 'plot-text');
                    text.textContent = plot.id.padStart(3, '0');

                    g.appendChild(rect); g.appendChild(text);

                    g.addEventListener('mouseenter', (e) => { showSimpleTooltip(e, plot); if (plot.district) highlightDistrict(plot.district); });
                    g.addEventListener('mouseleave', () => { hideTooltip(); clearHighlight(); });
                    g.addEventListener('mousemove', moveTooltip);
                    g.addEventListener('click', (e) => { e.stopPropagation(); showModal(plot); });

                    g.addEventListener('touchend', (e) => {
                        if (touchStartInfo.time) {
                            const timeDiff = Date.now() - touchStartInfo.time;
                            const dist = Math.hypot(e.changedTouches[0].clientX - touchStartInfo.x, e.changedTouches[0].clientY - touchStartInfo.y);
                            if (timeDiff < 250 && dist < 10) { e.preventDefault(); showModal(plot); }
                        }
                    });

                    layers.plots.appendChild(g);
                });
            }

            function drawDistrictBoundaries() {
                const districts = {};
                allPlots.forEach(plot => {
                    if (plot.district && plot.district.trim() !== '') {
                        const districtName = plot.district.trim();
                        if (!districts[districtName]) districts[districtName] = [];
                        districts[districtName].push(plot);
                    }
                });

                Object.entries(districts).forEach(([districtName, districtPlots]) => {
                    if (districtPlots.length === 0) return;
                    const clusters = createDistrictClusters(districtPlots, 1);
                    clusters.forEach((cluster) => {
                        const boundary = createDistrictOutline(cluster);
                        if (!boundary) return;

                        const path = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'path');
                        path.setAttribute('d', boundary);
                        path.style.cssText = "fill:none; stroke:#8b5cf6; stroke-width:2; stroke-dasharray:8,4; opacity:0.7; cursor:pointer; pointer-events:all;";
                        path.dataset.districtName = districtName;

                        path.addEventListener('mouseenter', () => highlightDistrict(districtName));
                        path.addEventListener('mouseleave', () => clearHighlight());

                        path.addEventListener('click', (e) => { e.stopPropagation(); showDistrictModal(districtName, cluster); });

                        let districtTouchStartInfo = {};
                        path.addEventListener('touchstart', (e) => {
                            if (e.touches.length === 1) districtTouchStartInfo = { time: Date.now(), x: e.touches[0].clientX, y: e.touches[0].clientY };
                        }, { passive: true });

                        path.addEventListener('touchend', (e) => {
                            if (districtTouchStartInfo.time) {
                                const timeDiff = Date.now() - districtTouchStartInfo.time;
                                const dist = Math.hypot(e.changedTouches[0].clientX - districtTouchStartInfo.x, e.changedTouches[0].clientY - districtTouchStartInfo.y);
                                if (timeDiff < 250 && dist < 10) { e.preventDefault(); showDistrictModal(districtName, cluster); }
                                districtTouchStartInfo = {};
                            }
                        });

                        layers.districts.appendChild(path);

                        const minX = Math.min(...cluster.map(p => p.x1));
                        const maxX = Math.max(...cluster.map(p => p.x2));
                        const minZ = Math.min(...cluster.map(p => p.z1));

                        const districtLabel = document.createElementNS('[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)', 'text');
                        districtLabel.setAttribute('x', minX + (maxX - minX) / 2);
                        districtLabel.setAttribute('y', minZ - 8);
                        districtLabel.style.cssText = "fill:#a78bfa; font-size:7px; font-weight:bold; text-anchor:middle; pointer-events:none;";
                        districtLabel.textContent = districtName;
                        layers.districts.appendChild(districtLabel);
                    });
                });
            }

            function createDistrictClusters(plots, maxDistance) {
                const clusters = [];
                let visited = new Set();
                plots.forEach(plot => {
                    if (!visited.has(plot.id)) {
                        const newCluster = [];
                        const queue = [plot];
                        visited.add(plot.id);
                        while (queue.length > 0) {
                            const currentPlot = queue.shift();
                            newCluster.push(currentPlot);
                            plots.forEach(otherPlot => {
                                if (!visited.has(otherPlot.id)) {
                                    const isAdjacent = (
                                        currentPlot.x1 <= otherPlot.x2 + maxDistance &&
                                        currentPlot.x2 >= otherPlot.x1 - maxDistance &&
                                        currentPlot.z1 <= otherPlot.z2 + maxDistance &&
                                        currentPlot.z2 >= otherPlot.z1 - maxDistance
                                    );
                                    if (isAdjacent) {
                                        visited.add(otherPlot.id);
                                        queue.push(otherPlot);
                                    }
                                }
                            });
                        }
                        clusters.push(newCluster);
                    }
                });
                return clusters;
            }

            /**
             * Tworzy kontur SVG wok贸 klastra (grupy) ssiadujcych dziaek.
             * @param {Array} plots - Tablica obiekt贸w dziaek nale偶cych do jednego klastra.
             * @returns {string} - Cig znak贸w 'd' dla atrybutu cie偶ki SVG lub pusty cig.
             */
            function createDistrictOutline(plots) {
                if (!plots || plots.length === 0) return '';

                const edges = new Map();
                const PADDING = 2; // Odstp wizualny granicy od dziaek

                // Funkcja pomocnicza do dodawania krawdzi do mapy.
                // Klucz jest kanoniczny (zawsze w tej samej kolejnoci), aby krawd藕 (p1, p2) bya taka sama jak (p2, p1).
                const addEdge = (x1, y1, x2, y2) => {
                    const p1 = `${x1},${y1}`;
                    const p2 = `${x2},${y2}`;
                    const key = p1 < p2 ? `${p1}|${p2}` : `${p2}|${p1}`;
                    edges.set(key, (edges.get(key) || 0) + 1);
                };

                // 1. Zbierz wszystkie krawdzie ze wszystkich dziaek w klastrze.
                plots.forEach(plot => {
                    addEdge(plot.x1, plot.z1, plot.x2, plot.z1); // G贸rna
                    addEdge(plot.x1, plot.z2, plot.x2, plot.z2); // Dolna
                    addEdge(plot.x1, plot.z1, plot.x1, plot.z2); // Lewa
                    addEdge(plot.x2, plot.z1, plot.x2, plot.z2); // Prawa
                });

                // 2. Filtruj krawdzie, aby znale藕 tylko te zewntrzne (wystpujce raz).
                // Krawdzie wewntrzne wystpuj dwa razy (raz dla ka偶dej ssiadujcej dziaki).
                const boundaryEdges = [];
                for (const [key, count] of edges.entries()) {
                    if (count === 1) {
                        boundaryEdges.push(key);
                    }
                }

                if (boundaryEdges.length === 0) return '';

                // 3. Zbuduj list ssiedztwa, aby poczy punkty w cie偶k.
                const adj = new Map();
                boundaryEdges.forEach(key => {
                    const [p1, p2] = key.split('|');
                    if (!adj.has(p1)) adj.set(p1, []);
                    if (!adj.has(p2)) adj.set(p2, []);
                    adj.get(p1).push(p2);
                    adj.get(p2).push(p1);
                });

                // 4. Przeled藕 cie偶k, czc punkty graniczne.
                const pathPoints = [];
                const visited = new Set();
                let [startNode,] = boundaryEdges[0].split('|'); // Wybierz dowolny punkt startowy
                let currentNode = startNode;

                while (currentNode && !visited.has(currentNode)) {
                    pathPoints.push(currentNode);
                    visited.add(currentNode);

                    const neighbors = adj.get(currentNode);
                    let nextNode = null;
                    for (const neighbor of neighbors) {
                        if (!visited.has(neighbor)) {
                            nextNode = neighbor;
                            break;
                        }
                    }
                    currentNode = nextNode;
                }

                if (pathPoints.length < 3) return ''; // Nie mo偶na utworzy wielokta

                // 5. Dodaj wizualny padding, odsuwajc punkty od rodka.
                let centroidX = 0, centroidY = 0;
                pathPoints.forEach(pStr => {
                    const [x, y] = pStr.split(',').map(Number);
                    centroidX += x;
                    centroidY += y;
                });
                centroidX /= pathPoints.length;
                centroidY /= pathPoints.length;

                const paddedPath = pathPoints.map(pStr => {
                    const [x, y] = pStr.split(',').map(Number);
                    const vecX = x - centroidX;
                    const vecY = y - centroidY;
                    const len = Math.hypot(vecX, vecY);
                    if (len === 0) return `${x},${y}`;
                    return `${x + (vecX / len) * PADDING},${y + (vecY / len) * PADDING}`;
                });

                // 6. Zwr贸 sformatowan cie偶k dla atrybutu 'd' SVG.
                return `M ${paddedPath.join(' L ')} Z`;
            }

            function highlightDistrict(districtName) {
                svg.querySelectorAll('.plot-rect').forEach(rect => {
                    if (rect.parentElement.dataset.plotDistrict !== districtName) {
                        rect.classList.add('dimmed');
                    }
                });
            }

            function clearHighlight() {
                svg.querySelectorAll('.plot-rect.dimmed').forEach(rect => rect.classList.remove('dimmed'));
                svg.querySelectorAll('.plot-rect.highlighted').forEach(rect => rect.classList.remove('highlighted'));
            }

            function showSimpleTooltip(e, plot) {
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                tooltip.innerHTML = `<div class="font-bold">${plot.name || `Dziaka ${plot.id}`}</div><div class="text-xs ${isOwned ? 'text-red-400' : 'text-green-400'}">${isOwned ? 'Zajta' : 'Wolna'}</div>`;
                tooltip.classList.remove('hidden');
                moveTooltip(e);
            }

            function showModal(plot) {
                destroyActiveCharts();
                modalTitle.textContent = 'Szczeg贸y dziaki';
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                const ownerInfo = isOwned ? plot.owner : 'Skarb Miasta';

                const localsOnPlot = allLocals.filter(l => l.plotName === plot.name);
                let localsHTML = '';
                if (localsOnPlot.length > 0) {
                    const totalBeds = localsOnPlot.reduce((sum, l) => sum + l.beds, 0);
                    const totalWorkplaces = localsOnPlot.reduce((sum, l) => sum + l.workplaces, 0);
                    const totalLocalArea = localsOnPlot.reduce((sum, l) => sum + l.area, 0);

                    const localLinks = localsOnPlot.map(l =>
                        `<li><a href="#" class="text-purple-400 hover:underline" data-local-id="${l.id}">Lokal #${l.localNum} (${l.area} m虏)</a></li>`
                    ).join('');

                    localsHTML = `
                        <div class="border-t border-gray-700 pt-3 mt-3">
                             <h4 class="text-md font-semibold mb-2">Lokale w budynku</h4>
                             <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm mb-2">
                                <span class="text-gray-400">czna pow. lokali:</span><span class="font-medium">${totalLocalArea} m虏</span>
                                <span class="text-gray-400">Miejsca pracy:</span><span class="font-medium">${totalWorkplaces}</span>
                                <span class="text-gray-400">Ilo 贸偶ek:</span><span class="font-medium">${totalBeds}</span>
                             </div>
                             ${localsOnPlot.length > 1 ? `<ul class="list-disc list-inside text-sm">${localLinks}</ul>` : ''}
                        </div>
                    `;
                }

                modalContent.innerHTML = `
                    <div><h3 class="text-2xl font-bold ${isOwned ? 'text-red-400' : 'text-green-400'}">${plot.name || `Dziaka ${plot.id}`}</h3><p class="text-gray-400">${plot.district || 'Brak dzielnicy'}</p></div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                        <span class="text-gray-400">Waciciel:</span><span class="font-medium clickable-name" data-owner-name="${ownerInfo}">${ownerInfo}</span>
                        <span class="text-gray-400">Typ:</span><span class="font-medium">${plot.type || 'Brak'}</span>
                        <span class="text-gray-400">Warto:</span><span class="font-medium flex items-center">${plot.value || '0'} <img src="minecoin.png" class="inline w-4 h-4 ml-1" alt="MC"></span>
                        <span class="text-gray-400">Powierzchnia:</span><span class="font-medium">${plot.area || 'Brak'} m虏</span>
                    </div>
                    ${localsHTML}`;

                modal.classList.add('show');
                addModalEventListeners();
            }

            function showMergedModal(mergedPlot) {
                destroyActiveCharts();
                modalTitle.textContent = 'Szczeg贸y poczenia';
                const constituentPlotsDetails = mergedPlot.plots.map(plotName => {
                    const plotData = allPlots.find(p => p.name === plotName);
                    return `<div class="pl-2">- <strong>${plotName}</strong> (${plotData ? plotData.area + ' m虏' : 'Brak danych'})</div>`;
                }).join('');

                modalContent.innerHTML = `
                    <div><h3 class="text-2xl font-bold text-amber-400">Poczone Dziaki</h3><p class="text-gray-400">Grupa ${mergedPlot.plots.length} dziaek</p></div>
                    <div class="space-y-3 text-sm">
                        <div>
                            <span class="text-gray-400 block">Dziaki wchodzce w skad:</span>
                            <div class="font-medium space-y-1 mt-1">${constituentPlotsDetails}</div>
                        </div>
                        <div class="grid grid-cols-2 gap-x-4 gap-y-2 pt-2 border-t border-gray-700">
                            <span class="text-gray-400">Pow. oryginalna:</span><span class="font-medium">${mergedPlot.originalArea} m虏</span>
                            <span class="text-gray-400">Pow. poczona:</span><span class="font-medium">${mergedPlot.mergedArea} m虏</span>
                            <span class="text-gray-400">R贸偶nica:</span><span class="font-medium">${mergedPlot.mergedArea - mergedPlot.originalArea} m虏</span>
                        </div>
                    </div>`;
                modal.classList.add('show');
            }

            function showLocalModal(localId) {
                destroyActiveCharts();
                const local = allLocals.find(l => l.id === localId);
                if (!local) return;

                const plot = allPlots.find(p => p.name === local.plotName);
                const owner = plot ? plot.owner : 'Nieznany';

                modalTitle.textContent = `Lokal #${local.localNum}`;
                modalContent.innerHTML = `
                    <div><h3 class="text-2xl font-bold text-cyan-400">Lokal #${local.localNum}</h3><p class="text-gray-400">${local.street}, ${local.building}</p></div>
                     <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                        <span class="text-gray-400">Najemca:</span><span class="font-medium clickable-name" data-owner-name="${local.tenant || 'Brak'}">${local.tenant || 'Brak'}</span>
                        <span class="text-gray-400">Waciciel:</span><span class="font-medium clickable-name" data-owner-name="${owner}">${owner}</span>
                        <span class="text-gray-400">Powierzchnia:</span><span class="font-medium">${local.area} m虏</span>
                        <span class="text-gray-400">Pitro:</span><span class="font-medium">${local.floor}</span>
                        <span class="text-gray-400">Miejsca pracy:</span><span class="font-medium">${local.workplaces}</span>
                        <span class="text-gray-400">Ilo 贸偶ek:</span><span class="font-medium">${local.beds}</span>
                    </div>`;
                modal.classList.add('show');
                addModalEventListeners();
            }

            function showOwnerModal(ownerName) {
                destroyActiveCharts();
                if (!ownerName || ownerName.toLowerCase() === 'skarb miasta' || ownerName.toLowerCase() === 'brak') return;

                modalTitle.textContent = `Aktywa: ${ownerName}`;

                const ownedPlots = allPlots.filter(p => p.owner === ownerName);
                const rentedLocals = allLocals.filter(l => l.tenant === ownerName);
                const ownedLocals = allLocals.filter(l => {
                    const plot = allPlots.find(p => p.name === l.plotName);
                    return plot && plot.owner === ownerName;
                });

                const totalPlotArea = ownedPlots.reduce((sum, p) => sum + (parseInt(p.area) || 0), 0);
                const totalPlotValue = ownedPlots.reduce((sum, p) => sum + (parseInt(p.value) || 0), 0);

                const totalOwnedLocalArea = ownedLocals.reduce((sum, l) => sum + l.area, 0);
                const totalOwnedBeds = ownedLocals.reduce((sum, l) => sum + l.beds, 0);
                const totalOwnedWorkplaces = ownedLocals.reduce((sum, l) => sum + l.workplaces, 0);

                const ownedPlotsHTML = ownedPlots.map(p => `<li><a href="#" data-plot-name="${p.name}" class="text-purple-400 hover:underline">${p.name}</a> (${p.area} m虏)</li>`).join('');
                const rentedLocalsHTML = rentedLocals.map(l => {
                    const plot = allPlots.find(p => p.name === l.plotName);
                    return `<li>Lokal #${l.localNum} od <span class="font-medium clickable-name" data-owner-name="${plot.owner}">${plot.owner}</span></li>`
                }).join('');

                modalContent.innerHTML = `
                    <div><h3 class="text-2xl font-bold text-green-400">${ownerName}</h3></div>
                    <div class="space-y-4 text-sm">
                        <div>
                            <h4 class="font-semibold text-md mb-1">Posiadane Dziaki (${ownedPlots.length})</h4>
                            <div class="grid grid-cols-2 gap-x-4 gap-y-1">
                                <span class="text-gray-400">czna pow.:</span><span>${totalPlotArea.toLocaleString()} m虏</span>
                                <span class="text-gray-400">czna warto:</span><span class="flex items-center">${totalPlotValue.toLocaleString()} <img src="minecoin.png" class="inline w-4 h-4 ml-1" alt="MC"></span>
                            </div>
                            ${ownedPlots.length > 0 ? `<ul class="list-disc list-inside mt-2">${ownedPlotsHTML}</ul>` : ''}
                        </div>
                        <div class="border-t border-gray-700 pt-3">
                            <h4 class="font-semibold text-md mb-1">Posiadane Lokale (${ownedLocals.length})</h4>
                            <div class="grid grid-cols-2 gap-x-4 gap-y-1">
                                <span class="text-gray-400">czna pow.:</span><span>${totalOwnedLocalArea.toLocaleString()} m虏</span>
                                <span class="text-gray-400">Miejsca pracy:</span><span>${totalOwnedWorkplaces}</span>
                                <span class="text-gray-400">贸偶ka:</span><span>${totalOwnedBeds}</span>
                            </div>
                        </div>
                         <div class="border-t border-gray-700 pt-3">
                            <h4 class="font-semibold text-md mb-1">Wynajmowane Lokale (${rentedLocals.length})</h4>
                             ${rentedLocals.length > 0 ? `<ul class="list-disc list-inside mt-2">${rentedLocalsHTML}</ul>` : '<p class="text-gray-500">Brak</p>'}
                        </div>
                    </div>
                `;
                modal.classList.add('show');
                addModalEventListeners();
            }

            function showDistrictModal(districtName, plotsInDistrict) {
                destroyActiveCharts();
                modalTitle.textContent = `Dzielnica: ${districtName}`;

                const plotTypes = {};
                const occupancy = { Zajte: 0, Wolne: 0 };
                const owners = {};
                let totalArea = 0;
                let totalValue = 0;

                plotsInDistrict.forEach(p => {
                    const type = p.type || 'Inne';
                    plotTypes[type] = (plotTypes[type] || 0) + 1;
                    const isOwned = p.owner && p.owner.trim() !== '' && p.owner.toLowerCase().trim() !== 'skarb miasta';
                    if (isOwned) {
                        occupancy.Zajte++;
                        const owner = p.owner.trim();
                        owners[owner] = (owners[owner] || 0) + 1;
                    } else {
                        occupancy.Wolne++;
                    }
                    totalArea += parseInt(p.area) || 0;
                    totalValue += parseInt(p.value) || 0;
                });

                const plotLinks = plotsInDistrict.map(p => `<a href="#" class="text-purple-400 hover:underline" data-plot-name="${p.name}">${p.name}</a>`).join(', ');

                modalContent.innerHTML = `
                    <div><h3 class="text-2xl font-bold text-purple-400">${districtName}</h3></div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm border-b border-gray-700 pb-3">
                        <span>Liczba dziaek:</span><span class="font-medium">${plotsInDistrict.length}</span>
                        <span>czna powierzchnia:</span><span class="font-medium">${totalArea.toLocaleString()} m虏</span>
                        <span>czna warto:</span><span class="font-medium flex items-center">${totalValue.toLocaleString()} <img src="minecoin.png" class="inline w-4 h-4 ml-1" alt="MC"></span>
                    </div>
                    <div class="text-sm"><span>Dziaki:</span> ${plotLinks}</div>
                    <div>
                        <h4 class="text-md font-semibold mt-4 mb-2">Struktura dziaek</h4>
                        <div class="chart-container"><canvas id="plot-type-chart"></canvas></div>
                        <h4 class="text-md font-semibold mt-4 mb-2">Zajto</h4>
                        <div class="chart-container"><canvas id="occupancy-chart"></canvas></div>
                        <h4 class="text-md font-semibold mt-4 mb-2">Waciciele</h4>
                        <div class="chart-container"><canvas id="owners-chart"></canvas></div>
                    </div>`;

                // Render charts with specific colors
                const typeLabels = Object.keys(plotTypes);
                const typeColors = typeLabels.map(label => getColorForType(label, 1));
                createChart('plot-type-chart', 'pie', { labels: typeLabels, data: Object.values(plotTypes), colors: typeColors }, 'Typy dziaek');

                const occupancyLabels = Object.keys(occupancy);
                createChart('occupancy-chart', 'doughnut', { labels: occupancyLabels, data: Object.values(occupancy), colors: ['rgba(239, 68, 68, 0.8)', 'rgba(34, 197, 94, 0.8)'] }, 'Zajto');

                const ownerLabels = Object.keys(owners);
                createChart('owners-chart', 'bar', { labels: ownerLabels, data: Object.values(owners) }, 'Waciciele dziaek');

                modal.classList.add('show');
                addModalEventListeners();
            }

            function createChart(canvasId, type, chartData, label) {
                const ctx = document.getElementById(canvasId);
                if (!ctx) return;

                if (chartData.data.length === 0) {
                    ctx.parentElement.innerHTML = `<div class="flex items-center justify-center h-full text-gray-500">Brak danych</div>`;
                    return;
                }

                const chart = new Chart(ctx, {
                    type: type,
                    data: {
                        labels: chartData.labels,
                        datasets: [{
                            label: label,
                            data: chartData.data,
                            backgroundColor: chartData.colors || chartData.labels.map((_, i) => `hsl(${(i * 137.5) % 360}, 50%, 60%)`),
                            borderColor: '#1f2937',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false, plugins: { legend: { position: type === 'bar' ? 'top' : 'right', labels: { color: '#d1d5db' } } },
                        scales: type === 'bar' ? { y: { beginAtZero: true, ticks: { color: '#9ca3af', stepSize: 1 } }, x: { ticks: { color: '#9ca3af' } } } : {}
                    }
                });
                activeCharts.push(chart);
            }

            function destroyActiveCharts() {
                activeCharts.forEach(chart => chart.destroy());
                activeCharts = [];
            }

            function hideTooltip() { tooltip.classList.add('hidden'); }
            function moveTooltip(e) {
                const PADDING = 20; let x = e.clientX + PADDING; let y = e.clientY + PADDING;
                if (x + tooltip.offsetWidth > window.innerWidth) x = e.clientX - tooltip.offsetWidth - PADDING;
                if (y + tooltip.offsetHeight > window.innerHeight) y = e.clientY - tooltip.offsetHeight - PADDING;
                tooltip.style.left = `${x}px`; tooltip.style.top = `${y}px`;
            }

            function findPlotAndCenter(query) {
                if (!query) return;
                const searchTerm = query.trim().toLowerCase();
                const searchNumber = parseInt(searchTerm.replace(/.*\//, ''), 10);

                const foundPlot = allPlots.find(p => {
                    const plotName = p.name ? p.name.toLowerCase() : '';
                    const plotId = parseInt(p.id, 10);
                    return plotName === searchTerm || plotId === searchNumber;
                });

                if (foundPlot) {
                    const newW = 300;
                    const newH = (newW / initialViewBox.w) * initialViewBox.h;
                    const newX = foundPlot.x1 + foundPlot.width / 2 - newW / 2;
                    const newY = foundPlot.z1 + foundPlot.height / 2 - newH / 2;
                    setViewBox(newX, newY, newW, newH);
                    highlightPlot(foundPlot.id);
                    showModal(foundPlot);
                    searchInput.value = '';
                } else {
                    searchInput.classList.add('ring-red-500');
                    setTimeout(() => searchInput.classList.remove('ring-red-500'), 2000);
                }
            }
            function highlightPlot(plotId) {
                clearHighlight();
                const plotElement = svg.querySelector(`g[data-plot-id='${plotId}'] .plot-rect`);
                if (plotElement) plotElement.classList.add('highlighted');
            }

            function toggleLayer(layerName) {
                layerVisibility[layerName] = !layerVisibility[layerName];
                document.getElementById(`${layerName}-layer`).classList.toggle('hidden-layer', !layerVisibility[layerName]);
                document.getElementById(`toggle-${layerName}`).classList.toggle('active', layerVisibility[layerName]);
            }

            function addModalEventListeners() {
                modalContent.querySelectorAll('a[data-plot-name]').forEach(a => a.addEventListener('click', e => { e.preventDefault(); findPlotAndCenter(e.target.dataset.plotName); }));
                modalContent.querySelectorAll('a[data-local-id]').forEach(a => a.addEventListener('click', e => { e.preventDefault(); showLocalModal(e.target.dataset.localId); }));
                modalContent.querySelectorAll('.clickable-name[data-owner-name]').forEach(span => span.addEventListener('click', e => { e.preventDefault(); showOwnerModal(e.target.dataset.ownerName); }));
            }

            // --- Event Listeners ---
            closeModalBtn.addEventListener('click', () => { modal.classList.remove('show'); destroyActiveCharts(); });
            mapContainer.addEventListener('click', (e) => {
                if (e.target === mapContainer || e.target === svg || e.target.id === 'map-svg') { modal.classList.remove('show'); destroyActiveCharts(); }
            });
            searchButton.addEventListener('click', () => findPlotAndCenter(searchInput.value));
            searchInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') findPlotAndCenter(searchInput.value); });

            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const w = viewBox.w; const h = viewBox.h; const mx = e.offsetX; const my = e.offsetY;
                const dw = w * Math.sign(e.deltaY) * 0.1; const dh = h * Math.sign(e.deltaY) * 0.1;
                const dx = dw * mx / mapContainer.clientWidth; const dy = dh * my / mapContainer.clientHeight;
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w - dw, viewBox.h - dh);
            }, { passive: false });

            mapContainer.addEventListener('mousedown', (e) => { if (e.button === 0) { isPanning = true; mapContainer.classList.add('grabbing'); startPoint = { x: e.x, y: e.y }; } });
            mapContainer.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const dx = (startPoint.x - e.x) * (viewBox.w / mapContainer.clientWidth);
                const dy = (startPoint.y - e.y) * (viewBox.h / mapContainer.clientHeight);
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                startPoint = { x: e.x, y: e.y };
            });
            document.addEventListener('mouseup', () => { isPanning = false; mapContainer.classList.remove('grabbing'); });

            let touchPanning = false; let pinchZooming = false;
            mapContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchPanning = true;
                    touchStartInfo = { time: Date.now(), x: e.touches[0].clientX, y: e.touches[0].clientY };
                    startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length >= 2) {
                    pinchZooming = true; touchPanning = false;
                    lastTouchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                }
            }, { passive: true });
            mapContainer.addEventListener('touchmove', (e) => {
                touchStartInfo.time = 0; // Invalidate tap if moving
                if (touchPanning && e.touches.length === 1) {
                    const dx = (startPoint.x - e.touches[0].clientX) * (viewBox.w / mapContainer.clientWidth);
                    const dy = (startPoint.y - e.touches[0].clientY) * (viewBox.h / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                    startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (pinchZooming && e.touches.length >= 2) {
                    const newDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const scale = lastTouchDistance / newDist;
                    const w = viewBox.w * scale; const h = viewBox.h * scale;
                    const { left, top } = mapContainer.getBoundingClientRect();
                    const mx = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - left;
                    const my = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - top;
                    const dx = (viewBox.w - w) * (mx / mapContainer.clientWidth);
                    const dy = (viewBox.h - h) * (my / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, w, h);
                    lastTouchDistance = newDist;
                }
            }, { passive: true });
            mapContainer.addEventListener('touchend', (e) => {
                touchPanning = false; pinchZooming = false;
                if (e.touches.length === 0) touchStartInfo.time = 0;
            });

            document.getElementById('zoom-in').addEventListener('click', () => { const dw = viewBox.w * -0.2; setViewBox(viewBox.x - dw / 2, viewBox.y - (dw / initialViewBox.w * initialViewBox.h) / 2, viewBox.w + dw, viewBox.h + (dw / initialViewBox.w * initialViewBox.h)); });
            document.getElementById('zoom-out').addEventListener('click', () => { const dw = viewBox.w * 0.2; setViewBox(viewBox.x - dw / 2, viewBox.y - (dw / initialViewBox.w * initialViewBox.h) / 2, viewBox.w + dw, viewBox.h + (dw / initialViewBox.w * initialViewBox.h)); });
            document.getElementById('reset-view').addEventListener('click', () => { setViewBox(initialViewBox.x, initialViewBox.y, initialViewBox.w, initialViewBox.h); });

            document.getElementById('toggle-plots').addEventListener('click', () => toggleLayer('plots'));
            document.getElementById('toggle-streets').addEventListener('click', () => toggleLayer('streets'));
            document.getElementById('toggle-districts').addEventListener('click', () => toggleLayer('districts'));
            document.getElementById('toggle-merged').addEventListener('click', () => toggleLayer('merged'));

            fetchAllData();
        });
    </script>
</body>

</html>