<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>System Działek Minecraft</title>
    <link rel="icon" type="image/x-icon" href="Red.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        #map-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        #map-svg {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111827;
        }
        .plot-rect {
            stroke-width: 0.5;
            transition: fill 0.2s ease-in-out;
        }
        .plot-rect:hover {
            fill-opacity: 0.6;
        }
        .plot-rect.highlighted {
            fill-opacity: 1 !important;
            filter: brightness(1.2);
        }
        .plot-rect.dimmed {
            fill-opacity: 0.2 !important;
        }
        .plot-text {
            font-size: 4px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        #tooltip {
            background-color: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid #4b5563;
            transition: opacity 0.2s ease-in-out;
        }
        .grab { cursor: grab; }
        .grabbing { cursor: grabbing; }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            #tooltip {
                font-size: 12px;
                max-width: 90vw;
                max-height: 50vh;
                overflow-y: auto;
            }
            .plot-text {
                font-size: 3px;
            }
            .controls {
                bottom: 10px;
                right: 10px;
            }
            .control-button {
                width: 44px;
                height: 44px;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Main container for the map -->
    <div id="map-container" class="grab">
        <svg id="map-svg"></svg>
    </div>

    <!-- Tooltip element -->
    <div id="tooltip" class="hidden absolute p-3 rounded-lg shadow-xl text-sm z-10 pointer-events-none"></div>

    <!-- Loading Indicator -->
    <div id="loader" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-20">
        <div class="text-center">
            <svg class="animate-spin h-8 w-8 text-white mx-auto mb-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-lg font-medium">Pobieranie danych o działkach...</p>
            <p class="text-sm text-gray-400">Proszę czekać</p>
        </div>
    </div>

    <!-- Controls -->
    <div class="absolute controls flex flex-col space-y-2" style="bottom: 20px; right: 20px;">
        <button id="zoom-in" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        </button>
        <button id="zoom-out" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600">
           <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        </button>
        <button id="reset-view" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"></path><path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path><path d="M21 22v-6h-6"></path><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path></svg>
        </button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const SHEET_ID = '1swtElpz27sqLMNbATocFe9VHc1yZTSRxvHyikFL_R7U';
            const GID = '0';
            const URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${GID}`;

            // --- MAP IMAGE CONFIGURATION ---
            const MAP_IMAGE_URL = 'map.png';
            const MAP_WIDTH = 4296;
            const MAP_HEIGHT = 2360;

            const svg = document.getElementById('map-svg');
            const tooltip = document.getElementById('tooltip');
            const loader = document.getElementById('loader');
            const mapContainer = document.getElementById('map-container');

            let viewBox = { x: 0, y: 0, w: 0, h: 0 };
            let mapBounds = { minX: -MAP_WIDTH / 2, maxX: MAP_WIDTH / 2, minY: -MAP_HEIGHT / 2, maxY: MAP_HEIGHT / 2 };
            let isPanning = false;
            let startPoint = { x: 0, y: 0 };
            let touchDistance = 0;
            let lastTouchTime = 0;
            const initialViewBox = {};

            // Detect if device is mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

            function setViewBox(x, y, w, h) {
                // Constrain viewBox to map boundaries
                const minZoom = isMobile ? 50 : 100; // Much closer zoom on mobile
                const maxZoom = Math.max(MAP_WIDTH, MAP_HEIGHT) * 2;
                
                // Limit zoom
                w = Math.max(minZoom, Math.min(w, maxZoom));
                h = Math.max(minZoom, Math.min(h, maxZoom));
                
                // Keep view within map bounds
                if (x < mapBounds.minX) x = mapBounds.minX;
                if (y < mapBounds.minY) y = mapBounds.minY;
                if (x + w > mapBounds.maxX) x = mapBounds.maxX - w;
                if (y + h > mapBounds.maxY) y = mapBounds.maxY - h;
                
                viewBox.x = x;
                viewBox.y = y;
                viewBox.w = w;
                viewBox.h = h;
                
                svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
            }

            function getColorForType(type) {
                const alpha = 0.8;
                switch (type) {
                    case 'Parkowa':               return `rgba(34, 197, 94, ${alpha})`;
                    case 'Rolna':                 return `rgba(126, 42, 12, ${alpha})`;
                    case 'Hotelowa':              return `rgba(6, 182, 212, ${alpha})`;
                    case 'Mieszkalna':            return `rgba(202, 138, 4, ${alpha})`;
                    case 'Sakralna':              return `rgba(168, 85, 247, ${alpha})`;
                    case 'Przemysłowo-biurowa':   return `rgba(236, 72, 153, ${alpha})`;
                    case 'Mieszkalno-usługowa':   return `rgba(59, 130, 246, ${alpha})`;
                    case 'Publiczna':             return `rgba(249, 115, 22, ${alpha})`;
                    case 'Medyczna':              return `rgba(251, 44, 54, ${alpha})`;
                    default:                      return `rgba(255, 255, 255, 0.1)`;
                }
            }

            async function fetchDataAndDraw() {
                try {
                    const response = await fetch(URL);
                    if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                    const csvText = await response.text();
                    
                    Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            const plots = results.data.filter(p => 
                                p['Nr porządkowy'] && p['X (lewy górny)'] && p['Z (lewy górny)'] && p['Bok X'] && p['Bok Z']
                            ).map(d => ({
                                id: d['Nr porządkowy'],
                                name: d['Nazwa porządkowa działki'],
                                type: d['Typ'],
                                x1: parseInt(d['X (lewy górny)'], 10),
                                z1: parseInt(d['Z (lewy górny)'], 10),
                                x2: parseInt(d['X (prawy dolny)'], 10),
                                z2: parseInt(d['Z (prawy dolny)'], 10),
                                width: parseInt(d['Bok X'], 10),
                                height: parseInt(d['Bok Z'], 10),
                                area: d['Powierzchnia'],
                                value: d['Wartość'],
                                prevOwner: d['Poprzedni właściciel'],
                                owner: d['Aktualny właściciel'],
                                sector: d['Sektor'],
                                district: d['Dzielnica']
                            }));
                            drawPlots(plots);
                            loader.style.display = 'none';
                        }
                    });
                } catch (error) {
                    console.error("Błąd podczas pobierania danych:", error);
                    loader.innerHTML = `<div class="text-center"><p class="text-lg font-medium text-red-500">Błąd ładowania danych</p><p class="text-sm text-gray-400">Sprawdź konsolę, aby uzyskać więcej informacji.</p></div>`;
                }
            }

            function drawPlots(plots) {
                if (!plots.length) return;
                svg.innerHTML = ''; 

                // Add map background image
                const mapImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                mapImage.setAttribute('href', MAP_IMAGE_URL);
                mapImage.setAttribute('x', -MAP_WIDTH / 2);
                mapImage.setAttribute('y', -MAP_HEIGHT / 2);
                mapImage.setAttribute('width', MAP_WIDTH);
                mapImage.setAttribute('height', MAP_HEIGHT);
                svg.appendChild(mapImage);

                const padding = 50;
                const minX = Math.min(...plots.map(p => p.x1));
                const maxX = Math.max(...plots.map(p => p.x2));
                const minZ = Math.min(...plots.map(p => p.z1));
                const maxZ = Math.max(...plots.map(p => p.z2));

                viewBox.x = minX - padding;
                viewBox.y = minZ - padding;
                viewBox.w = (maxX - minX) + (padding * 2);
                viewBox.h = (maxZ - minZ) + (padding * 2);

                Object.assign(initialViewBox, viewBox);
                setViewBox(viewBox.x, viewBox.y, viewBox.w, viewBox.h);

                // Draw district boundaries first (under plots)
                drawDistrictBoundaries(plots);

                const fragment = document.createDocumentFragment();
                plots.forEach(plot => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', plot.x1);
                    rect.setAttribute('y', plot.z1);
                    rect.setAttribute('width', plot.width);
                    rect.setAttribute('height', plot.height);
                    rect.setAttribute('class', 'plot-rect');
                    
                    rect.style.fill = getColorForType(plot.type);
                    
                    const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                    rect.style.stroke = isOwned ? '#ef4444' : '#22c55e';

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', plot.x1 + plot.width / 2);
                    text.setAttribute('y', plot.z1 + plot.height / 2);
                    text.setAttribute('class', 'plot-text');
                    text.textContent = plot.id;
                    
                    g.appendChild(rect);
                    g.appendChild(text);
                    g.dataset.plotData = JSON.stringify(plot);

                    // Event listeners for both mouse and touch
                    if (isMobile) {
                        g.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            showTooltip(e.touches[0], plot);
                        });
                        g.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            setTimeout(hideTooltip, 3000); // Auto hide after 3 seconds on mobile
                        });
                    } else {
                        g.addEventListener('mouseenter', (e) => showTooltip(e, plot));
                        g.addEventListener('mouseleave', hideTooltip);
                        g.addEventListener('mousemove', (e) => moveTooltip(e));
                    }

                    fragment.appendChild(g);
                });
                svg.appendChild(fragment);
            }

            function drawDistrictBoundaries(plots) {
                // Group plots by district
                const districts = {};
                plots.forEach(plot => {
                    if (plot.district && plot.district.trim() !== '') {
                        const districtName = plot.district.trim();
                        if (!districts[districtName]) {
                            districts[districtName] = [];
                        }
                        districts[districtName].push(plot);
                    }
                });

                // Draw boundary for each district
                Object.entries(districts).forEach(([districtName, districtPlots]) => {
                    if (districtPlots.length === 0) return;

                    // Create clusters of plots that are close to each other
                    const clusters = createDistrictClusters(districtPlots, 30);

                    clusters.forEach((cluster, clusterIndex) => {
                        // Find cluster bounds
                        const minX = Math.min(...cluster.map(p => p.x1));
                        const maxX = Math.max(...cluster.map(p => p.x2));
                        const minZ = Math.min(...cluster.map(p => p.z1));
                        const maxZ = Math.max(...cluster.map(p => p.z2));

                        // Create district boundary rectangle
                        const districtRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        districtRect.setAttribute('x', minX - 3);
                        districtRect.setAttribute('y', minZ - 3);
                        districtRect.setAttribute('width', maxX - minX + 6);
                        districtRect.setAttribute('height', maxZ - minZ + 6);
                        districtRect.style.fill = 'none';
                        districtRect.style.stroke = '#8b5cf6';
                        districtRect.style.strokeWidth = '2';
                        districtRect.style.strokeDasharray = '8,4';
                        districtRect.style.opacity = '0.7';
                        districtRect.style.cursor = 'pointer';
                        districtRect.dataset.districtName = districtName;
                        
                        // Add hover effects for district highlighting
                        districtRect.addEventListener('mouseenter', () => highlightDistrict(districtName));
                        districtRect.addEventListener('mouseleave', () => clearHighlight());

                        svg.appendChild(districtRect);

                        // Add district label (only for the first cluster or if clusters are far apart)
                        if (clusterIndex === 0 || clusters.length > 1) {
                            const districtLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            districtLabel.setAttribute('x', minX + (maxX - minX) / 2);
                            districtLabel.setAttribute('y', minZ - 8);
                            districtLabel.style.fill = '#8b5cf6';
                            districtLabel.style.fontSize = '7px';
                            districtLabel.style.fontWeight = 'bold';
                            districtLabel.style.textAnchor = 'middle';
                            districtLabel.style.pointerEvents = 'none';
                            districtLabel.textContent = clusters.length > 1 ? `${districtName} (${clusterIndex + 1})` : districtName;
                            svg.appendChild(districtLabel);
                        }
                    });
                });
            }

            function createDistrictClusters(plots, maxDistance) {
                if (plots.length === 0) return [];
                
                const clusters = [];
                const processed = new Set();

                plots.forEach((plot, index) => {
                    if (processed.has(index)) return;

                    const cluster = [plot];
                    processed.add(index);

                    // Find nearby plots
                    const findNearbyPlots = (centerPlot) => {
                        plots.forEach((otherPlot, otherIndex) => {
                            if (processed.has(otherIndex)) return;

                            // Calculate distance between plot centers
                            const centerX1 = centerPlot.x1 + centerPlot.width / 2;
                            const centerZ1 = centerPlot.z1 + centerPlot.height / 2;
                            const centerX2 = otherPlot.x1 + otherPlot.width / 2;
                            const centerZ2 = otherPlot.z1 + otherPlot.height / 2;
                            
                            const distance = Math.sqrt(
                                Math.pow(centerX2 - centerX1, 2) + Math.pow(centerZ2 - centerZ1, 2)
                            );

                            if (distance <= maxDistance) {
                                cluster.push(otherPlot);
                                processed.add(otherIndex);
                                // Recursively find plots near this newly added plot
                                findNearbyPlots(otherPlot);
                            }
                        });
                    };

                    findNearbyPlots(plot);
                    clusters.push(cluster);
                });

                return clusters;
            }

            function highlightDistrict(districtName) {
                const allPlots = svg.querySelectorAll('.plot-rect');
                allPlots.forEach(plotRect => {
                    const plotGroup = plotRect.parentElement;
                    const plotData = JSON.parse(plotGroup.dataset.plotData);
                    
                    if (plotData.district === districtName) {
                        plotRect.classList.add('highlighted');
                        plotRect.classList.remove('dimmed');
                    } else {
                        plotRect.classList.add('dimmed');
                        plotRect.classList.remove('highlighted');
                    }
                });
            }

            function clearHighlight() {
                const allPlots = svg.querySelectorAll('.plot-rect');
                allPlots.forEach(plotRect => {
                    plotRect.classList.remove('highlighted', 'dimmed');
                });
            }

            function showTooltip(event, plotData) {
                if (!plotData && event.currentTarget) {
                    plotData = JSON.parse(event.currentTarget.dataset.plotData);
                }
                
                const isOwned = plotData.owner && plotData.owner.trim() !== '' && plotData.owner.toLowerCase().trim() !== 'skarb miasta';
                tooltip.innerHTML = `
                    <h3 class="font-bold text-base mb-2 border-b border-gray-600 pb-1">${plotData.name || `Działka nr ${plotData.id}`}</h3>
                    <div class="grid grid-cols-2 gap-x-3 gap-y-1 text-sm">
                        <span class="text-gray-400">Status:</span>
                        <span class="font-semibold ${isOwned ? 'text-red-400' : 'text-green-400'}">${isOwned ? 'Zajęta' : 'Wolna'}</span>
                        <span class="text-gray-400">Właściciel:</span>
                        <span class="break-words">${plotData.owner || 'Brak'}</span>
                        <span class="text-gray-400">Sektor:</span>
                        <span>${plotData.sector}</span>
                        ${plotData.district ? `<span class="text-gray-400">Dzielnica:</span><span class="break-words">${plotData.district}</span>` : ''}
                        <span class="text-gray-400">Typ:</span>
                        <span class="break-words">${plotData.type}</span>
                        <span class="text-gray-400">Pow.:</span>
                        <span>${plotData.area} m²</span>
                        <span class="text-gray-400">Wymiary:</span>
                        <span>${plotData.width}x${plotData.height}</span>
                        <span class="text-gray-400">Wartość:</span>
                        <span class="flex items-center gap-1">${plotData.value || 'Brak'} ${plotData.value ? '<img src="minecoin.png" class="inline w-4 h-4" alt="MC">' : ''}</span>
                        <span class="text-gray-400">Koordynaty:</span>
                        <span>(${plotData.x1}, ${plotData.z1})</span>
                    </div>`;
                tooltip.classList.remove('hidden');
                moveTooltip(event);
            }

            function hideTooltip() {
                tooltip.classList.add('hidden');
            }
            
            function moveTooltip(event) {
                const PADDING = 15;
                const rect = mapContainer.getBoundingClientRect();
                
                let clientX = event.clientX || (event.touches && event.touches[0] ? event.touches[0].clientX : 0);
                let clientY = event.clientY || (event.touches && event.touches[0] ? event.touches[0].clientY : 0);
                
                // Get tooltip dimensions
                tooltip.style.visibility = 'hidden';
                tooltip.classList.remove('hidden');
                const tooltipRect = tooltip.getBoundingClientRect();
                tooltip.style.visibility = 'visible';
                
                let x = clientX + PADDING;
                let y = clientY + PADDING;
                
                // Adjust if tooltip would go off screen
                if (x + tooltipRect.width > window.innerWidth) {
                    x = clientX - tooltipRect.width - PADDING;
                }
                if (y + tooltipRect.height > window.innerHeight) {
                    y = clientY - tooltipRect.height - PADDING;
                }
                
                // Ensure tooltip stays within screen bounds
                x = Math.max(PADDING, Math.min(x, window.innerWidth - tooltipRect.width - PADDING));
                y = Math.max(PADDING, Math.min(y, window.innerHeight - tooltipRect.height - PADDING));
                
                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;
            }

            function getEventPoint(event) {
                if (event.touches && event.touches.length > 0) {
                    return { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
                return { x: event.clientX, y: event.clientY };
            }

            function getTouchDistance(touches) {
                if (touches.length < 2) return 0;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Mouse events
            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = mapContainer.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const w = viewBox.w;
                const h = viewBox.h;
                const dw = w * -Math.sign(e.deltaY) * 0.1; // Inverted sign
                const dh = h * -Math.sign(e.deltaY) * 0.1; // Inverted sign
                const dx = dw * mx / mapContainer.clientWidth;
                const dy = dh * my / mapContainer.clientHeight;
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w - dw, viewBox.h - dh);
            });

            mapContainer.addEventListener('mousedown', (e) => {
                isPanning = true;
                mapContainer.classList.remove('grab');
                mapContainer.classList.add('grabbing');
                startPoint = getEventPoint(e);
            });

            mapContainer.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const endPoint = getEventPoint(e);
                const dx = (startPoint.x - endPoint.x) * (viewBox.w / mapContainer.clientWidth);
                const dy = (startPoint.y - endPoint.y) * (viewBox.h / mapContainer.clientHeight);
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                startPoint = endPoint;
            });

            mapContainer.addEventListener('mouseup', () => {
                isPanning = false;
                mapContainer.classList.remove('grabbing');
                mapContainer.classList.add('grab');
            });

            mapContainer.addEventListener('mouseleave', () => {
                if (isPanning) {
                    isPanning = false;
                    mapContainer.classList.remove('grabbing');
                    mapContainer.classList.add('grab');
                }
            });

            // Touch events
            mapContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const now = Date.now();
                
                if (e.touches.length === 1) {
                    isPanning = true;
                    startPoint = getEventPoint(e);
                    
                    // Handle double tap to zoom
                    if (now - lastTouchTime < 300) {
                        const w = viewBox.w;
                        const h = viewBox.h;
                        const dw = w * -0.3;
                        const dh = h * -0.3;
                        setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh);
                    }
                    lastTouchTime = now;
                } else if (e.touches.length === 2) {
                    isPanning = false;
                    touchDistance = getTouchDistance(e.touches);
                }
            });

            mapContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                if (e.touches.length === 1 && isPanning) {
                    const endPoint = getEventPoint(e);
                    const dx = (startPoint.x - endPoint.x) * (viewBox.w / mapContainer.clientWidth);
                    const dy = (startPoint.y - endPoint.y) * (viewBox.h / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                    startPoint = endPoint;
                } else if (e.touches.length === 2) {
                    const newDistance = getTouchDistance(e.touches);
                    if (touchDistance > 0) {
                        const scale = touchDistance / newDistance; // Back to original for correct mobile behavior
                        const w = viewBox.w;
                        const h = viewBox.h;
                        const dw = w * (1 - scale); // Inverted the math operation instead
                        const dh = h * (1 - scale); // Inverted the math operation instead
                        setViewBox(viewBox.x + dw/2, viewBox.y + dh/2, viewBox.w - dw, viewBox.h - dh);
                    }
                    touchDistance = newDistance;
                }
            });

            mapContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                isPanning = false;
                touchDistance = 0;
            });

            // Control buttons
            document.getElementById('zoom-in').addEventListener('click', () => {
                const w = viewBox.w;
                const h = viewBox.h;
                const dw = w * -0.2;
                const dh = h * -0.2;
                setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh);
            });

            document.getElementById('zoom-out').addEventListener('click', () => {
                const w = viewBox.w;
                const h = viewBox.h;
                const dw = w * 0.2;
                const dh = h * 0.2;
                setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh);
            });

            document.getElementById('reset-view').addEventListener('click', () => {
                Object.assign(viewBox, initialViewBox);
                setViewBox(viewBox.x, viewBox.y, viewBox.w, viewBox.h);
            });

            // Hide tooltip on outside touch/click
            document.addEventListener('touchstart', (e) => {
                if (!tooltip.contains(e.target) && !svg.contains(e.target)) {
                    hideTooltip();
                }
            });

            fetchDataAndDraw();
        });
    </script>
</body>
</html>