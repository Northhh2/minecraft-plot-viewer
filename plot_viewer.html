<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>System Dziaek Minecraft</title>
    <link rel="icon" type="image/x-icon" href="Red.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        #map-container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        #map-svg {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111827;
        }
        .plot-rect {
            stroke-width: 0.5;
            transition: fill 0.2s ease-in-out, fill-opacity 0.3s ease-in-out, filter 0.3s ease-in-out, stroke 0.3s, stroke-width 0.3s;
        }
        .plot-rect:hover {
            fill-opacity: 0.7;
        }
        .plot-rect.dimmed {
            fill-opacity: 0.2 !important;
            filter: grayscale(80%);
        }
        .plot-rect.highlighted {
            fill-opacity: 1 !important;
            filter: brightness(1.2);
            stroke: #facc15; /* yellow-400 */
            stroke-width: 1.5;
        }
        .street-rect {
            fill: #4b5563; /* gray-600 */
            fill-opacity: 0.9;
            stroke: transparent; /* No stroke by default */
            stroke-width: 0.25;
            transition: fill-opacity 0.2s, stroke 0.2s;
        }
        .street-rect:hover {
            fill-opacity: 0.7;
            stroke: #9ca3af; /* Add stroke on hover */
        }
        .merged-plot {
            stroke: #f59e0b;
            stroke-width: 1.5;
            stroke-dasharray: 4,2;
            fill: none;
            pointer-events: all;
        }
        .plot-text {
            font-size: 4px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 0.5px;
            stroke-linecap: butt;
            stroke-linejoin: miter;
        }
        .street-text {
            font-size: 3px;
            fill: #ffffff;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        .street-text.street-vertical {
            writing-mode: vertical-rl; /* Vertical text for vertical streets */
        }
        #tooltip {
            background-color: rgba(31, 41, 55, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid #4b5563;
            transition: opacity 0.2s ease-in-out;
        }
        #modal {
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
        }
        #modal.show {
            transform: translateX(0);
        }
        .grab { cursor: grab; }
        .grabbing { cursor: grabbing; }

        .toggle-button {
            opacity: 0.5;
            border: 1px solid #4b5563;
        }
        .toggle-button.active {
            opacity: 1;
            background-color: #4338ca; /* indigo-700 */
            border-color: #6d28d9; /* purple-700 */
        }
        .hidden-layer {
            display: none;
        }
        
        @media (max-width: 768px) {
            #tooltip { font-size: 12px; max-width: 90vw; max-height: 50vh; overflow-y: auto; }
            .plot-text { font-size: 3px; }
            .controls { bottom: 10px !important; right: 10px !important; }
            .control-button { width: 44px; height: 44px; }
            #modal { width: 100vw; }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Search Bar -->
    <div class="absolute top-5 left-5 z-30">
        <div class="flex bg-gray-800 rounded-lg border border-gray-600 shadow-lg">
            <input type="text" id="search-input" placeholder="Wyszukaj (np. D4/021 lub 21)" class="bg-transparent text-white px-4 py-2 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-purple-500 w-48 md:w-auto" maxlength="15">
            <button id="search-button" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-r-lg transition-colors"></button>
        </div>
    </div>

    <!-- Main container for the map -->
    <div id="map-container" class="grab">
        <svg id="map-svg"></svg>
    </div>

    <!-- Simple Tooltip -->
    <div id="tooltip" class="hidden absolute p-2 rounded-lg shadow-xl text-sm z-40 pointer-events-none"></div>

    <!-- Right Side Modal -->
    <div id="modal" class="fixed top-0 right-0 w-full md:w-96 h-full bg-gray-800 border-l border-gray-600 shadow-2xl z-50 overflow-y-auto">
        <div class="p-6">
            <div class="flex justify-between items-center mb-4"><h2 class="text-xl font-bold">Szczeg贸y dziaki</h2><button id="close-modal" class="text-gray-400 hover:text-white text-2xl">&times;</button></div>
            <div id="modal-content" class="space-y-4"></div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loader" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50">
        <div class="text-center">
            <svg class="animate-spin h-8 w-8 text-white mx-auto mb-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
            <p class="text-lg font-medium">Pobieranie danych...</p><p class="text-sm text-gray-400">Prosz czeka</p>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls absolute flex flex-col items-end z-30" style="bottom: 20px; right: 20px;">
        <div class="flex flex-col space-y-2">
            <button id="zoom-in" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600" title="Powiksz"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
            <button id="zoom-out" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600" title="Pomniejsz"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg></button>
            <button id="reset-view" class="control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700 transition-colors shadow-lg border border-gray-600" title="Resetuj widok"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"></path><path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path><path d="M21 22v-6h-6"></path><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path></svg></button>
        </div>
        <div id="layer-toggles" class="mt-2 flex flex-col space-y-2">
             <button id="toggle-plots" class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700" title="Poka偶/Ukryj Dziaki"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg></button>
             <button id="toggle-streets" class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700" title="Poka偶/Ukryj Ulice"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="20" x2="4" y2="4"></line><line x1="20" y1="20" x2="20" y2="4"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg></button>
             <button id="toggle-districts" class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700" title="Poka偶/Ukryj Dzielnice"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg></button>
             <button id="toggle-merged" class="toggle-button active control-button w-10 h-10 bg-gray-800 text-white rounded-md flex items-center justify-center hover:bg-gray-700" title="Poka偶/Ukryj Poczone Dziaki"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const SHEET_ID = '1swtElpz27sqLMNbATocFe9VHc1yZTSRxvHyikFL_R7U';
            const PLOTS_GID = '0';
            const MERGED_GID = '43897086';
            const STREETS_GID = '2101138806';

            const PLOTS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${PLOTS_GID}`;
            const MERGED_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${MERGED_GID}`;
            const STREETS_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${STREETS_GID}`;

            const MAP_IMAGE_URL = 'map.png';
            const MAP_WIDTH = 4296;
            const MAP_HEIGHT = 2360;

            const svg = document.getElementById('map-svg');
            const tooltip = document.getElementById('tooltip');
            const modal = document.getElementById('modal');
            const modalContent = document.getElementById('modal-content');
            const loader = document.getElementById('loader');
            const mapContainer = document.getElementById('map-container');
            const searchInput = document.getElementById('search-input');
            const searchButton = document.getElementById('search-button');
            const closeModalBtn = document.getElementById('close-modal');

            let viewBox = { x: 0, y: 0, w: 0, h: 0 };
            let mapBounds = { minX: -MAP_WIDTH / 2, maxX: MAP_WIDTH / 2, minY: -MAP_HEIGHT / 2, maxY: MAP_HEIGHT / 2 };
            let isPanning = false;
            let startPoint = { x: 0, y: 0 };
            let lastTouchDistance = 0;
            const initialViewBox = {};
            let layerVisibility = { plots: true, streets: true, districts: true, merged: true };
            
            let allPlots = [];
            let mergedPlots = [];
            let streets = [];

            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
            
            const layers = {
                streets: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                districts: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                plots: document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                merged: document.createElementNS('http://www.w3.org/2000/svg', 'g')
            };

            function setViewBox(x, y, w, h) {
                const minZoom = isMobile ? 50 : 100;
                const maxZoom = Math.max(MAP_WIDTH, MAP_HEIGHT) * 2;
                
                w = Math.max(minZoom, Math.min(w, maxZoom));
                if (initialViewBox.w) {
                    h = (w / initialViewBox.w) * initialViewBox.h;
                }
                
                if (x < mapBounds.minX) x = mapBounds.minX;
                if (y < mapBounds.minY) y = mapBounds.minY;
                if (x + w > mapBounds.maxX) x = mapBounds.maxX - w;
                if (y + h > mapBounds.maxY) y = mapBounds.maxY - h;
                
                viewBox = { x, y, w, h };
                svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
            }

            function getColorForType(type) {
                const alpha = 0.8;
                switch (type) {
                    case 'Parkowa':               return `rgba(34, 197, 94, ${alpha})`;
                    case 'Rolna':                 return `rgba(126, 42, 12, ${alpha})`;
                    case 'Hotelowa':              return `rgba(6, 182, 212, ${alpha})`;
                    case 'Mieszkalna':            return `rgba(202, 138, 4, ${alpha})`;
                    case 'Sakralna':              return `rgba(168, 85, 247, ${alpha})`;
                    case 'Przemysowo-biurowa':   return `rgba(236, 72, 153, ${alpha})`;
                    case 'Mieszkalno-usugowa':   return `rgba(59, 130, 246, ${alpha})`;
                    case 'Publiczna':             return `rgba(249, 115, 22, ${alpha})`;
                    case 'Medyczna':              return `rgba(251, 44, 54, ${alpha})`;
                    default:                      return `rgba(255, 255, 255, 0.1)`;
                }
            }

            async function fetchAllData() {
                try {
                    const [plotsResponse, mergedResponse, streetsResponse] = await Promise.all([
                        fetch(PLOTS_URL), fetch(MERGED_URL), fetch(STREETS_URL)
                    ]);

                    if (!plotsResponse.ok || !mergedResponse.ok || !streetsResponse.ok) throw new Error('Network response was not ok');

                    const [plotsText, mergedText, streetsText] = await Promise.all([
                        plotsResponse.text(), mergedResponse.text(), streetsResponse.text()
                    ]);
                    
                    const plotsPromise = new Promise(resolve => Papa.parse(plotsText, { header: true, skipEmptyLines: true, complete: resolve }));
                    const mergedPromise = new Promise(resolve => Papa.parse(mergedText, { header: true, skipEmptyLines: true, complete: resolve }));
                    const streetsPromise = new Promise(resolve => Papa.parse(streetsText, { header: true, skipEmptyLines: true, complete: resolve }));

                    const [plotsResult, mergedResult, streetsResult] = await Promise.all([plotsPromise, mergedPromise, streetsPromise]);

                    allPlots = plotsResult.data.filter(p => p['Nr porzdkowy'] && p['X (lewy g贸rny)'] && p['Z (lewy g贸rny)'] && p['Bok X'] && p['Bok Z'])
                        .map(d => ({
                            id: d['Nr porzdkowy'], name: d['Nazwa porzdkowa dziaki'], type: d['Typ'],
                            x1: parseInt(d['X (lewy g贸rny)'], 10), z1: parseInt(d['Z (lewy g贸rny)'], 10),
                            x2: parseInt(d['X (prawy dolny)'], 10), z2: parseInt(d['Z (prawy dolny)'], 10),
                            width: parseInt(d['Bok X'], 10), height: parseInt(d['Bok Z'], 10), area: d['Powierzchnia'],
                            value: d['Warto'], prevOwner: d['Poprzedni waciciel'], owner: d['Aktualny waciciel'],
                            sector: d['Sektor'], district: d['Dzielnica'], street: d['Ulica'],
                            buildingNumber: d['Numer budynku'], apartmentCount: d['Ilo lokali']
                        }));
                    
                    const connections = mergedResult.data.filter(m => m['Dziaka g贸wna'] && m['Dziaka doczana'])
                        .map(d => ({ plot1: d['Dziaka g贸wna'], plot2: d['Dziaka doczana'] }));
                    mergedPlots = processMergedPlots(connections);

                    streets = streetsResult.data.filter(s => s['Numer porzdkowy'] && s['X (lewy g贸rny)'] && s['Z (lewy g贸rny)'] && s['X (prawy dolny)'] && s['Z (prawy dolny)'])
                        .map(d => ({
                            id: d['Numer porzdkowy'], name: d['Nazwa ulicy'],
                            x1: parseInt(d['X (lewy g贸rny)'], 10), z1: parseInt(d['Z (lewy g贸rny)'], 10),
                            x2: parseInt(d['X (prawy dolny)'], 10), z2: parseInt(d['Z (prawy dolny)'], 10),
                            width: parseInt(d['X (prawy dolny)'], 10) - parseInt(d['X (lewy g贸rny)'], 10),
                            height: parseInt(d['Z (prawy dolny)'], 10) - parseInt(d['Z (lewy g贸rny)'], 10)
                        }));

                    drawMap();
                    loader.style.display = 'none';

                } catch (error) {
                    console.error("Bd podczas pobierania danych:", error);
                    loader.innerHTML = `<div class="text-center"><p class="text-lg font-medium text-red-500">Bd adowania danych</p><p class="text-sm text-gray-400">Sprawd藕 konsol.</p></div>`;
                }
            }
            
            function processMergedPlots(connections) {
                const adj = new Map();
                const allPlotIdsInConnections = new Set();

                connections.forEach(({ plot1, plot2 }) => {
                    if (!adj.has(plot1)) adj.set(plot1, []);
                    if (!adj.has(plot2)) adj.set(plot2, []);
                    adj.get(plot1).push(plot2);
                    adj.get(plot2).push(plot1);
                    allPlotIdsInConnections.add(plot1);
                    allPlotIdsInConnections.add(plot2);
                });

                const visited = new Set();
                const groups = [];

                for (const plotId of allPlotIdsInConnections) {
                    if (!visited.has(plotId)) {
                        const group = [];
                        const stack = [plotId];
                        visited.add(plotId);
                        while (stack.length > 0) {
                            const currentId = stack.pop();
                            group.push(currentId);
                            const neighbors = adj.get(currentId) || [];
                            for (const neighbor of neighbors) {
                                if (!visited.has(neighbor)) {
                                    visited.add(neighbor);
                                    stack.push(neighbor);
                                }
                            }
                        }
                        groups.push(group);
                    }
                }
                
                return groups.map(group => {
                    const plotsInGroup = group.map(id => allPlots.find(p => p.name === id)).filter(Boolean);
                    if (plotsInGroup.length === 0) return null;

                    const minX = Math.min(...plotsInGroup.map(p => p.x1));
                    const maxX = Math.max(...plotsInGroup.map(p => p.x2));
                    const minZ = Math.min(...plotsInGroup.map(p => p.z1));
                    const maxZ = Math.max(...plotsInGroup.map(p => p.z2));
                    const originalArea = plotsInGroup.reduce((sum, p) => sum + parseInt(p.area || 0), 0);
                    const mergedArea = (maxX - minX) * (maxZ - minZ);

                    return {
                        plots: group, x1: minX, z1: minZ, x2: maxX, z2: maxZ,
                        width: maxX - minX, height: maxZ - minZ, originalArea, mergedArea
                    };
                }).filter(Boolean);
            }

            function drawMap() {
                if (!allPlots.length) return;
                svg.innerHTML = ''; 

                const mapImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                mapImage.setAttribute('href', MAP_IMAGE_URL);
                mapImage.setAttribute('x', -MAP_WIDTH / 2);
                mapImage.setAttribute('y', -MAP_HEIGHT / 2);
                mapImage.setAttribute('width', MAP_WIDTH);
                mapImage.setAttribute('height', MAP_HEIGHT);
                svg.appendChild(mapImage);

                layers.streets.id = 'streets-layer';
                layers.districts.id = 'districts-layer';
                layers.plots.id = 'plots-layer';
                layers.merged.id = 'merged-layer';
                svg.appendChild(layers.streets);
                svg.appendChild(layers.districts);
                svg.appendChild(layers.plots);
                svg.appendChild(layers.merged);

                drawStreets();
                drawDistrictBoundaries();
                drawMergedPlots();
                drawPlots();

                const padding = 100;
                const minX = Math.min(...allPlots.map(p => p.x1));
                const maxX = Math.max(...allPlots.map(p => p.x2));
                const minZ = Math.min(...allPlots.map(p => p.z1));
                const maxZ = Math.max(...allPlots.map(p => p.z2));

                const contentWidth = (maxX - minX) + (padding * 2);
                const contentHeight = (maxZ - minZ) + (padding * 2);
                const aspectRatio = contentWidth / contentHeight;

                viewBox.w = contentWidth;
                viewBox.h = contentHeight;
                viewBox.x = minX - padding;
                viewBox.y = minZ - padding;
                
                Object.assign(initialViewBox, viewBox);
                setViewBox(viewBox.x, viewBox.y, viewBox.w, viewBox.h);
            }

            function drawStreets() {
                layers.streets.innerHTML = '';
                streets.forEach(street => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', street.x1); rect.setAttribute('y', street.z1);
                    rect.setAttribute('width', street.width); rect.setAttribute('height', street.height);
                    rect.setAttribute('class', 'street-rect');

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', street.x1 + street.width / 2);
                    text.setAttribute('y', street.z1 + street.height / 2);
                    text.setAttribute('class', 'street-text');
                    if(street.height > street.width) {
                        text.classList.add('street-vertical');
                    }
                    text.textContent = street.name;
                    g.appendChild(rect); g.appendChild(text);

                    g.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold">${street.name}</div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    g.addEventListener('mouseleave', hideTooltip);
                    g.addEventListener('mousemove', moveTooltip);
                    layers.streets.appendChild(g);
                });
            }

            function drawMergedPlots() {
                layers.merged.innerHTML = '';
                mergedPlots.forEach((merged) => {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', merged.x1); rect.setAttribute('y', merged.z1);
                    rect.setAttribute('width', merged.width); rect.setAttribute('height', merged.height);
                    rect.setAttribute('class', 'merged-plot');

                    rect.addEventListener('mouseenter', (e) => {
                        tooltip.innerHTML = `<div class="font-semibold mb-1">Poczone dziaki</div><div class="text-xs"><div>Dziaki: ${merged.plots.join(', ')}</div><div>Powierzchnia: ${merged.mergedArea} m虏</div></div>`;
                        tooltip.classList.remove('hidden');
                        moveTooltip(e);
                    });
                    rect.addEventListener('mouseleave', hideTooltip);
                    rect.addEventListener('mousemove', moveTooltip);
                    layers.merged.appendChild(rect);
                });
            }

            function drawPlots() {
                layers.plots.innerHTML = '';
                const fragment = document.createDocumentFragment();
                allPlots.forEach(plot => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.dataset.plotId = plot.id;
                    g.dataset.plotDistrict = plot.district || '';
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', plot.x1); rect.setAttribute('y', plot.z1);
                    rect.setAttribute('width', plot.width); rect.setAttribute('height', plot.height);
                    rect.setAttribute('class', 'plot-rect');
                    rect.style.fill = getColorForType(plot.type);
                    const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                    rect.style.stroke = isOwned ? '#ef4444' : '#22c55e';

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', plot.x1 + plot.width / 2);
                    text.setAttribute('y', plot.z1 + plot.height / 2);
                    text.setAttribute('class', 'plot-text');
                    text.textContent = plot.id.padStart(3, '0');
                    
                    g.appendChild(rect); g.appendChild(text);
                    g.dataset.plotData = JSON.stringify(plot);

                    g.addEventListener('mouseenter', (e) => {
                        showSimpleTooltip(e, plot);
                        if (plot.district) highlightDistrict(plot.district);
                    });
                    g.addEventListener('mouseleave', () => { hideTooltip(); clearHighlight(); });
                    g.addEventListener('mousemove', moveTooltip);
                    g.addEventListener('click', (e) => { e.stopPropagation(); showModal(plot); });

                    if (isMobile) {
                        g.addEventListener('touchstart', (e) => { e.preventDefault(); showModal(plot); }, { passive: false });
                    }
                    fragment.appendChild(g);
                });
                layers.plots.appendChild(fragment);
            }

            function drawDistrictBoundaries() {
                layers.districts.innerHTML = '';
                const districts = {};
                allPlots.forEach(plot => {
                    if (plot.district && plot.district.trim() !== '') {
                        const districtName = plot.district.trim();
                        if (!districts[districtName]) districts[districtName] = [];
                        districts[districtName].push(plot);
                    }
                });

                Object.entries(districts).forEach(([districtName, districtPlots]) => {
                    if (districtPlots.length === 0) return;
                    const clusters = createDistrictClusters(districtPlots, 30);
                    clusters.forEach((cluster, clusterIndex) => {
                        const boundary = createComplexBoundary(cluster);
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', boundary);
                        path.style.cssText = "fill:none; stroke:#8b5cf6; stroke-width:2; stroke-dasharray:8,4; opacity:0.7; cursor:pointer; pointer-events:all;";
                        path.dataset.districtName = districtName;
                        
                        path.addEventListener('mouseenter', () => highlightDistrict(districtName));
                        path.addEventListener('mouseleave', () => clearHighlight());
                        layers.districts.appendChild(path);

                        const minX = Math.min(...cluster.map(p => p.x1));
                        const maxX = Math.max(...cluster.map(p => p.x2));
                        const minZ = Math.min(...cluster.map(p => p.z1));
                        
                        const districtLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        districtLabel.setAttribute('x', minX + (maxX - minX) / 2);
                        districtLabel.setAttribute('y', minZ - 8);
                        districtLabel.style.cssText = "fill:#a78bfa; font-size:7px; font-weight:bold; text-anchor:middle; pointer-events:none;";
                        districtLabel.textContent = clusters.length > 1 ? `${districtName} (${clusterIndex + 1})` : districtName;
                        layers.districts.appendChild(districtLabel);
                    });
                });
            }

            function createDistrictClusters(plots, maxDistance) {
                const clusters = [];
                let visited = new Set();
                plots.forEach(plot => {
                    if (!visited.has(plot.id)) {
                        const newCluster = [];
                        const queue = [plot];
                        visited.add(plot.id);
                        while (queue.length > 0) {
                            const currentPlot = queue.shift();
                            newCluster.push(currentPlot);
                            plots.forEach(otherPlot => {
                                if (!visited.has(otherPlot.id)) {
                                    const dist = Math.sqrt(Math.pow( (currentPlot.x1+currentPlot.width/2) - (otherPlot.x1+otherPlot.width/2), 2) + Math.pow( (currentPlot.z1+currentPlot.height/2) - (otherPlot.z1+otherPlot.height/2), 2));
                                    if (dist < (currentPlot.width/2 + otherPlot.width/2 + maxDistance) && dist < (currentPlot.height/2 + otherPlot.height/2 + maxDistance) ) {
                                        visited.add(otherPlot.id);
                                        queue.push(otherPlot);
                                    }
                                }
                            });
                        }
                        clusters.push(newCluster);
                    }
                });
                return clusters;
            }

            function createComplexBoundary(plots) {
                if (plots.length === 0) return '';
                const padding = 3;
                if (plots.length === 1) {
                    const p = plots[0];
                    return `M ${p.x1 - padding} ${p.z1 - padding} L ${p.x2 + padding} ${p.z1 - padding} L ${p.x2 + padding} ${p.z2 + padding} L ${p.x1 - padding} ${p.z2 + padding} Z`;
                }

                const allPoints = [];
                plots.forEach(plot => {
                    allPoints.push({ x: plot.x1, y: plot.z1 }, { x: plot.x2, y: plot.z1 }, { x: plot.x2, y: plot.z2 }, { x: plot.x1, y: plot.z2 });
                });

                const hull = convexHull(allPoints);
                if (hull.length < 3) {
                    const minX = Math.min(...plots.map(p => p.x1)) - padding;
                    const maxX = Math.max(...plots.map(p => p.x2)) + padding;
                    const minZ = Math.min(...plots.map(p => p.z1)) - padding;
                    const maxZ = Math.max(...plots.map(p => p.z2)) + padding;
                    return `M ${minX} ${minZ} L ${maxX} ${minZ} L ${maxX} ${maxZ} L ${minX} ${maxZ} Z`;
                }

                return hull.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ') + ' Z';
            }

            function convexHull(points) {
                points.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
                const crossProduct = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
                const lower = [];
                for (const p of points) {
                    while (lower.length >= 2 && crossProduct(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();
                    lower.push(p);
                }
                const upper = [];
                for (let i = points.length - 1; i >= 0; i--) {
                    const p = points[i];
                    while (upper.length >= 2 && crossProduct(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();
                    upper.push(p);
                }
                return lower.slice(0, -1).concat(upper.slice(0, -1));
            }

            function highlightDistrict(districtName) {
                svg.querySelectorAll('.plot-rect').forEach(rect => {
                    const parent = rect.parentElement;
                    if (parent.dataset.plotDistrict !== districtName) {
                        rect.classList.add('dimmed');
                    }
                });
            }

            function clearHighlight() {
                svg.querySelectorAll('.plot-rect.dimmed').forEach(rect => rect.classList.remove('dimmed'));
                svg.querySelectorAll('.plot-rect.highlighted').forEach(rect => rect.classList.remove('highlighted'));
            }

            function showSimpleTooltip(e, plot) {
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                tooltip.innerHTML = `<div class="font-bold">${plot.name || `Dziaka ${plot.id}`}</div><div class="text-xs ${isOwned ? 'text-red-400' : 'text-green-400'}">${isOwned ? 'Zajta' : 'Wolna'}</div>`;
                tooltip.classList.remove('hidden');
                moveTooltip(e);
            }

            function showModal(plot) {
                const isOwned = plot.owner && plot.owner.trim() !== '' && plot.owner.toLowerCase().trim() !== 'skarb miasta';
                const ownerInfo = isOwned ? plot.owner : 'Skarb Miasta';
                modalContent.innerHTML = `
                    <div><h3 class="text-2xl font-bold ${isOwned ? 'text-red-400' : 'text-green-400'}">${plot.name || `Dziaka ${plot.id}`}</h3><p class="text-gray-400">${plot.district || 'Brak dzielnicy'}</p></div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                        <span class="text-gray-400">Waciciel:</span><span class="font-medium">${ownerInfo}</span>
                        <span class="text-gray-400">Typ:</span><span class="font-medium">${plot.type || 'Brak'}</span>
                        <span class="text-gray-400">Sektor:</span><span class="font-medium">${plot.sector || 'Brak'}</span>
                        <span class="text-gray-400">Adres:</span><span class="font-medium">${plot.street || 'Brak'}, ${plot.buildingNumber || 'Brak'}</span>
                        <span class="text-gray-400">Powierzchnia:</span><span class="font-medium">${plot.area || 'Brak'} m虏</span>
                        <span class="text-gray-400">Wymiary:</span><span class="font-medium">${plot.width}x${plot.height}</span>
                        <span class="text-gray-400">Warto:</span><span class="font-medium">${plot.value || '0'} </span>
                        <span class="text-gray-400">Ilo lokali:</span><span class="font-medium">${plot.apartmentCount || '0'}</span>
                        <span class="text-gray-400">Koordynaty:</span><span class="font-medium">(${plot.x1}, ${plot.z1})</span>
                    </div>`;
                modal.classList.add('show');
            }

            function hideTooltip() { tooltip.classList.add('hidden'); }
            function moveTooltip(e) {
                const PADDING = 20; let x = e.clientX + PADDING; let y = e.clientY + PADDING;
                if (x + tooltip.offsetWidth > window.innerWidth) x = e.clientX - tooltip.offsetWidth - PADDING;
                if (y + tooltip.offsetHeight > window.innerHeight) y = e.clientY - tooltip.offsetHeight - PADDING;
                tooltip.style.left = `${x}px`; tooltip.style.top = `${y}px`;
            }

            function findPlotAndCenter(query) {
                if (!query) return;
                const searchTerm = query.trim().toLowerCase();
                const searchNumber = parseInt(searchTerm.replace(/.*\//, ''), 10);

                const foundPlot = allPlots.find(p => {
                    const plotName = p.name.toLowerCase();
                    const plotId = parseInt(p.id, 10);
                    return plotName === searchTerm || plotId === searchNumber;
                });

                if (foundPlot) {
                    const newW = 300;
                    const newH = (newW / initialViewBox.w) * initialViewBox.h;
                    const newX = foundPlot.x1 + foundPlot.width / 2 - newW / 2;
                    const newY = foundPlot.z1 + foundPlot.height / 2 - newH / 2;
                    setViewBox(newX, newY, newW, newH);
                    highlightPlot(foundPlot.id);
                    showModal(foundPlot);
                    searchInput.value = '';
                } else {
                    searchInput.classList.add('ring-red-500');
                    setTimeout(() => searchInput.classList.remove('ring-red-500'), 2000);
                }
            }
            function highlightPlot(plotId) {
                clearHighlight();
                const plotElement = svg.querySelector(`g[data-plot-id='${plotId}'] .plot-rect`);
                if (plotElement) plotElement.classList.add('highlighted');
            }

            function toggleLayer(layerName) {
                layerVisibility[layerName] = !layerVisibility[layerName];
                document.getElementById(`${layerName}-layer`).classList.toggle('hidden-layer', !layerVisibility[layerName]);
                document.getElementById(`toggle-${layerName}`).classList.toggle('active', layerVisibility[layerName]);
            }

            // --- Event Listeners ---
            closeModalBtn.addEventListener('click', () => modal.classList.remove('show'));
            mapContainer.addEventListener('click', () => { if(modal.classList.contains('show')) modal.classList.remove('show'); });
            searchButton.addEventListener('click', () => findPlotAndCenter(searchInput.value));
            searchInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') findPlotAndCenter(searchInput.value); });

            mapContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const w = viewBox.w; const h = viewBox.h; const mx = e.offsetX; const my = e.offsetY;
                const dw = w * Math.sign(e.deltaY) * 0.1; const dh = h * Math.sign(e.deltaY) * 0.1;
                const dx = dw * mx / mapContainer.clientWidth; const dy = dh * my / mapContainer.clientHeight;
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w - dw, viewBox.h - dh);
            }, { passive: false });

            mapContainer.addEventListener('mousedown', (e) => { if (e.button === 0) { isPanning = true; mapContainer.classList.add('grabbing'); startPoint = { x: e.x, y: e.y }; }});
            mapContainer.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const endPoint = { x: e.x, y: e.y };
                const dx = (startPoint.x - endPoint.x) * (viewBox.w / mapContainer.clientWidth);
                const dy = (startPoint.y - endPoint.y) * (viewBox.h / mapContainer.clientHeight);
                setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                startPoint = { x: e.x, y: e.y };
            });
            mapContainer.addEventListener('mouseup', () => { isPanning = false; mapContainer.classList.remove('grabbing'); });
            mapContainer.addEventListener('mouseleave', () => { isPanning = false; mapContainer.classList.remove('grabbing'); });

            // Touch events
            let touchPanning = false; let pinchZooming = false;
            mapContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchPanning = true;
                    startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    pinchZooming = true;
                    touchPanning = false;
                    lastTouchDistance = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                }
            }, { passive: true });
            mapContainer.addEventListener('touchmove', (e) => {
                if (touchPanning && e.touches.length === 1) {
                    const endPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    const dx = (startPoint.x - endPoint.x) * (viewBox.w / mapContainer.clientWidth);
                    const dy = (startPoint.y - endPoint.y) * (viewBox.h / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, viewBox.w, viewBox.h);
                    startPoint = endPoint;
                } else if (pinchZooming && e.touches.length === 2) {
                    const newDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const scale = lastTouchDistance / newDist;
                    const w = viewBox.w * scale; const h = viewBox.h * scale;
                    const clientX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const clientY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    const { left, top } = mapContainer.getBoundingClientRect();
                    const mx = clientX - left; const my = clientY - top;
                    const dx = (viewBox.w - w) * (mx / mapContainer.clientWidth);
                    const dy = (viewBox.h - h) * (my / mapContainer.clientHeight);
                    setViewBox(viewBox.x + dx, viewBox.y + dy, w, h);
                    lastTouchDistance = newDist;
                }
            }, { passive: true });
            mapContainer.addEventListener('touchend', () => { touchPanning = false; pinchZooming = false; });
            
            document.getElementById('zoom-in').addEventListener('click', () => { const w = viewBox.w; const h = viewBox.h; const dw = w * -0.2; const dh = h * -0.2; setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh); });
            document.getElementById('zoom-out').addEventListener('click', () => { const w = viewBox.w; const h = viewBox.h; const dw = w * 0.2; const dh = h * 0.2; setViewBox(viewBox.x - dw/2, viewBox.y - dh/2, viewBox.w + dw, viewBox.h + dh); });
            document.getElementById('reset-view').addEventListener('click', () => { setViewBox(initialViewBox.x, initialViewBox.y, initialViewBox.w, initialViewBox.h); });

            document.getElementById('toggle-plots').addEventListener('click', () => toggleLayer('plots'));
            document.getElementById('toggle-streets').addEventListener('click', () => toggleLayer('streets'));
            document.getElementById('toggle-districts').addEventListener('click', () => toggleLayer('districts'));
            document.getElementById('toggle-merged').addEventListener('click', () => toggleLayer('merged'));

            fetchAllData();
        });
    </script>
</body>
</html>

